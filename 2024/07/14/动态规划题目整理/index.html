<!DOCTYPE html>
<html lang="zh-CN,en,zh-TW,default">
    <head hexo-theme='https://github.com/volantis-x/hexo-theme-volantis/#5.8.0'>
  <meta name="generator" content="Hexo 7.3.0">
  <meta name="Volantis" content="5.8.0">
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
  <link rel="canonical" href="https://ricky-daxia.github.io/2024/07/14/动态规划题目整理/"/>
  <!-- 渲染优化 -->
    <meta http-equiv='x-dns-prefetch-control' content='on' />
      <link rel='dns-prefetch' href='https://unpkg.com'>
      <link rel="preconnect" href="https://unpkg.com" crossorigin>
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Content-Security-Policy" content=" default-src 'self' https:; block-all-mixed-content; base-uri 'self' https:; form-action 'self' https:; worker-src 'self' https:; connect-src 'self' https: *; img-src 'self' data: https: *; media-src 'self' https: *; font-src 'self' data: https: *; frame-src 'self' https: *; manifest-src 'self' https: *; child-src https:; script-src 'self' https: 'unsafe-inline' *; style-src 'self' https: 'unsafe-inline' *; ">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta content="black-translucent" name="apple-mobile-web-app-status-bar-style">
  <meta content="telephone=no" name="format-detection">
  <!-- import head_begin begin -->
  <!-- import head_begin end -->
  <!-- Custom Files headBegin begin-->
  
  <!-- Custom Files headBegin end-->
  <!-- front-matter head_begin begin -->
  <!-- front-matter head_begin end -->
    <link rel="shortcut icon" type='image/x-icon' href="https://gcore.jsdelivr.net/gh/Ricky-Daxia/Hei_Xiu@1.0/happy.ico">
  <link rel="preload" href="/css/style.css" as="style">
  <link rel="preload" href="https://unpkg.com/volantis-static@0.0.1654736714924/media/fonts/VarelaRound/VarelaRound-Regular.ttf" as="font" type="font/ttf" crossorigin="anonymous">
<link rel="preload" href="https://unpkg.com/volantis-static@0.0.1654736714924/media/fonts/UbuntuMono/UbuntuMono-Regular.ttf" as="font" type="font/ttf" crossorigin="anonymous">

  <!-- feed -->
  <!-- 页面元数据 -->
  <title>动态规划题目整理 - Rikki's Blog</title>
  <meta name="keywords" content="题目,动态规划,null">
  <meta desc name="description" content="DP 题目分类整理 - Ligu - Rikki's Blog">
  
<meta property="og:type" content="article">
<meta property="og:title" content="动态规划题目整理">
<meta property="og:url" content="https://ricky-daxia.github.io/2024/07/14/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="Rikki&#39;s Blog">
<meta property="og:description" content="DP 题目分类整理">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png">
<meta property="article:published_time" content="2024-07-14T07:13:10.000Z">
<meta property="article:modified_time" content="2024-07-14T08:17:31.834Z">
<meta property="article:author" content="Ligu">
<meta property="article:tag" content="题目">
<meta property="article:tag" content="动态规划">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png">
  <style>
    /* 首屏样式 */
    #safearea {
  display: none;
}
:root {
  --color-site-body: #f4f4f4;
  --color-site-bg: #f4f4f4;
  --color-site-inner: #fff;
  --color-site-footer: #666;
  --color-card: #fff;
  --color-text: #444;
  --color-block: #f6f6f6;
  --color-inlinecode: #c74f00;
  --color-codeblock: #fff7ea;
  --color-h1: #3a3a3a;
  --color-h2: #3a3a3a;
  --color-h3: #333;
  --color-h4: #444;
  --color-h5: #555;
  --color-h6: #666;
  --color-p: #444;
  --color-list: #666;
  --color-list-hl: #30ad91;
  --color-meta: #888;
  --color-read-bkg: #e0d8c8;
  --color-read-post: #f8f1e2;
  --color-copyright-bkg: #f5f5f5;
}
* {
  box-sizing: border-box;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  outline: none;
  margin: 0;
  padding: 0;
}
*::-webkit-scrollbar {
  height: 4px;
  width: 4px;
}
*::-webkit-scrollbar-track-piece {
  background: transparent;
}
*::-webkit-scrollbar-thumb {
  background: #3dd9b6;
  cursor: pointer;
  border-radius: 2px;
  -webkit-border-radius: 2px;
}
*::-webkit-scrollbar-thumb:hover {
  background: #ff5722;
}
html {
  color: var(--color-text);
  width: 100%;
  height: 100%;
  font-family: "Microsoft YaHei", Menlo, Monaco, monospace, sans-serif;
  font-size: 16px;
}
html >::-webkit-scrollbar {
  height: 4px;
  width: 4px;
}
html >::-webkit-scrollbar-track-piece {
  background: transparent;
}
html >::-webkit-scrollbar-thumb {
  background: #54b5a0 linear-gradient(45deg, rgba(255,255,255,0.4) 25%, transparent 25%, transparent 50%, rgba(255,255,255,0.4) 50%, rgba(255,255,255,0.4) 75%, transparent 75%, transparent);
  cursor: pointer;
  border-radius: 2px;
  -webkit-border-radius: 2px;
}
html >::-webkit-scrollbar-thumb:hover {
  background: #54b5a0 linear-gradient(45deg, rgba(255,255,255,0.4) 25%, transparent 25%, transparent 50%, rgba(255,255,255,0.4) 50%, rgba(255,255,255,0.4) 75%, transparent 75%, transparent);
}
body {
  background-color: var(--color-site-body);
  text-rendering: optimizelegibility;
  -webkit-tap-highlight-color: rgba(0,0,0,0);
  line-height: 1.6;
  -webkit-text-size-adjust: 100%;
  -ms-text-size-adjust: 100%;
}
body.modal-active {
  overflow: hidden;
}
@media screen and (max-width: 680px) {
  body.modal-active {
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
  }
}
a {
  color: #2092ec;
  cursor: pointer;
  text-decoration: none;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
a:hover {
  color: #ff5722;
}
a:active,
a:hover {
  outline: 0;
}
ul,
ol {
  padding-left: 0;
}
ul li,
ol li {
  list-style: none;
}
header {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
}
img {
  border: 0;
  background: none;
  max-width: 100%;
}
svg:not(:root) {
  overflow: hidden;
}
hr {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  -webkit-box-sizing: content-box;
  -moz-box-sizing: content-box;
  height: 0;
  border: 0;
  border-radius: 1px;
  -webkit-border-radius: 1px;
  border-bottom: 1px solid rgba(68,68,68,0.1);
}
button,
input {
  color: inherit;
  font: inherit;
  margin: 0;
}
button {
  overflow: visible;
  text-transform: none;
  -webkit-appearance: button;
  cursor: pointer;
}
@supports (backdrop-filter: blur(20px)) {
  .blur {
    background: rgba(255,255,255,0.9) !important;
    backdrop-filter: saturate(200%) blur(20px);
  }
}
.shadow {
  box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
  -webkit-box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
}
.shadow.floatable {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.shadow.floatable:hover {
  box-shadow: 0 2px 4px 0px rgba(0,0,0,0.1), 0 4px 8px 0px rgba(0,0,0,0.1), 0 8px 16px 0px rgba(0,0,0,0.1);
  -webkit-box-shadow: 0 2px 4px 0px rgba(0,0,0,0.1), 0 4px 8px 0px rgba(0,0,0,0.1), 0 8px 16px 0px rgba(0,0,0,0.1);
}
#l_cover {
  min-height: 64px;
}
.cover-wrapper {
  top: 0;
  left: 0;
  max-width: 100%;
  height: 100vh;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  flex-wrap: nowrap;
  -webkit-flex-wrap: nowrap;
  -khtml-flex-wrap: nowrap;
  -moz-flex-wrap: nowrap;
  -o-flex-wrap: nowrap;
  -ms-flex-wrap: nowrap;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: vertical;
  -moz-box-orient: vertical;
  -webkit-flex-direction: column;
  -ms-flex-direction: column;
  flex-direction: column;
  align-items: center;
  align-self: center;
  align-content: center;
  color: var(--color-site-inner);
  padding: 0 16px;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  position: relative;
  overflow: hidden;
  margin-bottom: -100px;
}
.cover-wrapper .cover-bg {
  position: absolute;
  width: 100%;
  height: 100%;
  background-position: center;
  background-size: cover;
  -webkit-background-size: cover;
  -moz-background-size: cover;
}
.cover-wrapper .cover-bg.lazyload:not(.loaded) {
  opacity: 0;
  -webkit-opacity: 0;
  -moz-opacity: 0;
}
.cover-wrapper .cover-bg.lazyload.loaded {
  animation-delay: 0s;
  animation-duration: 0.5s;
  animation-fill-mode: forwards;
  animation-timing-function: ease-out;
  animation-name: fadeIn;
}
@-moz-keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
    transform: scale(1.02);
    -webkit-transform: scale(1.02);
    -khtml-transform: scale(1.02);
    -moz-transform: scale(1.02);
    -o-transform: scale(1.02);
    -ms-transform: scale(1.02);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-webkit-keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
    transform: scale(1.02);
    -webkit-transform: scale(1.02);
    -khtml-transform: scale(1.02);
    -moz-transform: scale(1.02);
    -o-transform: scale(1.02);
    -ms-transform: scale(1.02);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-o-keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
    transform: scale(1.02);
    -webkit-transform: scale(1.02);
    -khtml-transform: scale(1.02);
    -moz-transform: scale(1.02);
    -o-transform: scale(1.02);
    -ms-transform: scale(1.02);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
    transform: scale(1.02);
    -webkit-transform: scale(1.02);
    -khtml-transform: scale(1.02);
    -moz-transform: scale(1.02);
    -o-transform: scale(1.02);
    -ms-transform: scale(1.02);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
.cover-wrapper .cover-body {
  z-index: 1;
  position: relative;
  width: 100%;
  height: 100%;
}
.cover-wrapper#full {
  height: calc(100vh + 100px);
  padding-bottom: 100px;
}
.cover-wrapper#half {
  max-height: 640px;
  min-height: 400px;
  height: calc(36vh - 64px + 200px);
}
.cover-wrapper #scroll-down {
  width: 100%;
  height: 64px;
  position: absolute;
  bottom: 100px;
  text-align: center;
  cursor: pointer;
}
.cover-wrapper #scroll-down .scroll-down-effects {
  color: #fff;
  font-size: 24px;
  line-height: 64px;
  position: absolute;
  width: 24px;
  left: calc(50% - 12px);
  text-shadow: 0 1px 2px rgba(0,0,0,0.1);
  animation: scroll-down-effect 1.5s infinite;
  -webkit-animation: scroll-down-effect 1.5s infinite;
  -khtml-animation: scroll-down-effect 1.5s infinite;
  -moz-animation: scroll-down-effect 1.5s infinite;
  -o-animation: scroll-down-effect 1.5s infinite;
  -ms-animation: scroll-down-effect 1.5s infinite;
}
@-moz-keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-webkit-keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-o-keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
.cover-wrapper .cover-body {
  margin-top: 64px;
  margin-bottom: 100px;
}
.cover-wrapper .cover-body,
.cover-wrapper .cover-body .top,
.cover-wrapper .cover-body .bottom {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: vertical;
  -moz-box-orient: vertical;
  -webkit-flex-direction: column;
  -ms-flex-direction: column;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  -webkit-justify-content: center;
  -khtml-justify-content: center;
  -moz-justify-content: center;
  -o-justify-content: center;
  -ms-justify-content: center;
  max-width: 100%;
}
.cover-wrapper .cover-body .bottom {
  margin-top: 32px;
}
.cover-wrapper .cover-body .title {
  font-family: CodeNewRoman Nerd Font Mono, "Microsoft YaHei", Helvetica, monospace;
  font-size: 3.125rem;
  line-height: 1.2;
  text-shadow: 0 1px 2px rgba(0,0,0,0.1);
}
.cover-wrapper .cover-body .subtitle {
  font-size: 20px;
}
.cover-wrapper .cover-body .logo {
  max-height: 120px;
  max-width: calc(100% - 4 * 16px);
}
@media screen and (min-height: 1024px) {
  .cover-wrapper .cover-body .title {
    font-size: 3rem;
  }
  .cover-wrapper .cover-body .subtitle {
    font-size: 1.05rem;
  }
  .cover-wrapper .cover-body .logo {
    max-height: 150px;
  }
}
.cover-wrapper .cover-body .m_search {
  position: relative;
  max-width: calc(100% - 16px);
  width: 320px;
  vertical-align: middle;
}
.cover-wrapper .cover-body .m_search .form {
  position: relative;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  width: 100%;
}
.cover-wrapper .cover-body .m_search .icon,
.cover-wrapper .cover-body .m_search .input {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.cover-wrapper .cover-body .m_search .icon {
  position: absolute;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  line-height: 2.5rem;
  width: 32px;
  top: 0;
  left: 5px;
  color: rgba(68,68,68,0.75);
}
.cover-wrapper .cover-body .m_search .input {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  height: 2.5rem;
  width: 100%;
  box-shadow: none;
  -webkit-box-shadow: none;
  box-sizing: border-box;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  font-size: 0.875rem;
  -webkit-appearance: none;
  padding-left: 36px;
  border-radius: 1.4rem;
  -webkit-border-radius: 1.4rem;
  background: rgba(255,255,255,0.6);
  backdrop-filter: blur(10px);
  border: none;
  color: var(--color-text);
}
@media screen and (max-width: 500px) {
  .cover-wrapper .cover-body .m_search .input {
    padding-left: 36px;
  }
}
.cover-wrapper .cover-body .m_search .input:hover {
  background: rgba(255,255,255,0.8);
}
.cover-wrapper .cover-body .m_search .input:focus {
  background: #fff;
}
.cover-wrapper .list-h {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: horizontal;
  -moz-box-orient: horizontal;
  -webkit-flex-direction: row;
  -ms-flex-direction: row;
  flex-direction: row;
  flex-wrap: wrap;
  -webkit-flex-wrap: wrap;
  -khtml-flex-wrap: wrap;
  -moz-flex-wrap: wrap;
  -o-flex-wrap: wrap;
  -ms-flex-wrap: wrap;
  align-items: stretch;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
}
.cover-wrapper .list-h a {
  -webkit-box-flex: 1;
  -moz-box-flex: 1;
  -webkit-flex: 1 0;
  -ms-flex: 1 0;
  flex: 1 0;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  font-weight: 600;
}
.cover-wrapper .list-h a img {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  border-radius: 2px;
  -webkit-border-radius: 2px;
  margin: 4px;
  min-width: 40px;
  max-width: 44px;
}
@media screen and (max-width: 768px) {
  .cover-wrapper .list-h a img {
    min-width: 36px;
    max-width: 40px;
  }
}
@media screen and (max-width: 500px) {
  .cover-wrapper .list-h a img {
    margin: 2px 4px;
    min-width: 32px;
    max-width: 36px;
  }
}
@media screen and (max-width: 375px) {
  .cover-wrapper .list-h a img {
    min-width: 28px;
    max-width: 32px;
  }
}
.cover-wrapper {
  max-width: 100%;
}
.cover-wrapper.search .bottom .menu {
  margin-top: 16px;
}
.cover-wrapper.search .bottom .menu .list-h a {
  white-space: nowrap;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: horizontal;
  -moz-box-orient: horizontal;
  -webkit-flex-direction: row;
  -ms-flex-direction: row;
  flex-direction: row;
  align-items: baseline;
  padding: 2px;
  margin: 4px;
  color: var(--color-site-inner);
  opacity: 0.75;
  -webkit-opacity: 0.75;
  -moz-opacity: 0.75;
  text-shadow: 0 1px 2px rgba(0,0,0,0.05);
  border-bottom: 2px solid transparent;
}
.cover-wrapper.search .bottom .menu .list-h a i {
  margin-right: 4px;
}
.cover-wrapper.search .bottom .menu .list-h a p {
  font-size: 0.9375rem;
}
.cover-wrapper.search .bottom .menu .list-h a:hover,
.cover-wrapper.search .bottom .menu .list-h a.active,
.cover-wrapper.search .bottom .menu .list-h a:active {
  opacity: 1;
  -webkit-opacity: 1;
  -moz-opacity: 1;
  border-bottom: 2px solid var(--color-site-inner);
}
.cover-wrapper.dock .menu,
.cover-wrapper.featured .menu,
.cover-wrapper.focus .menu {
  border-radius: 6px;
  -webkit-border-radius: 6px;
}
.cover-wrapper.dock .menu .list-h a,
.cover-wrapper.featured .menu .list-h a,
.cover-wrapper.focus .menu .list-h a {
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: vertical;
  -moz-box-orient: vertical;
  -webkit-flex-direction: column;
  -ms-flex-direction: column;
  flex-direction: column;
  align-items: center;
  padding: 12px;
  line-height: 24px;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  border-bottom: none;
  text-align: center;
  align-content: flex-end;
  color: rgba(68,68,68,0.7);
  font-size: 1.5rem;
}
@media screen and (max-width: 500px) {
  .cover-wrapper.dock .menu .list-h a,
  .cover-wrapper.featured .menu .list-h a,
  .cover-wrapper.focus .menu .list-h a {
    padding: 12px 8px;
  }
}
.cover-wrapper.dock .menu .list-h a i,
.cover-wrapper.featured .menu .list-h a i,
.cover-wrapper.focus .menu .list-h a i {
  margin: 8px;
}
.cover-wrapper.dock .menu .list-h a p,
.cover-wrapper.featured .menu .list-h a p,
.cover-wrapper.focus .menu .list-h a p {
  font-size: 0.875rem;
}
.cover-wrapper.dock .menu .list-h a.active,
.cover-wrapper.featured .menu .list-h a.active,
.cover-wrapper.focus .menu .list-h a.active {
  background: var(--color-card);
  backdrop-filter: none;
}
.cover-wrapper.dock .menu .list-h a.active i,
.cover-wrapper.featured .menu .list-h a.active i,
.cover-wrapper.focus .menu .list-h a.active i,
.cover-wrapper.dock .menu .list-h a.active i+p,
.cover-wrapper.featured .menu .list-h a.active i+p,
.cover-wrapper.focus .menu .list-h a.active i+p {
  color: #3dd9b6;
}
.cover-wrapper.dock .menu .list-h a.active img+p,
.cover-wrapper.featured .menu .list-h a.active img+p,
.cover-wrapper.focus .menu .list-h a.active img+p {
  color: var(--color-text);
}
.cover-wrapper.dock .menu .list-h a:hover,
.cover-wrapper.featured .menu .list-h a:hover,
.cover-wrapper.focus .menu .list-h a:hover {
  background: var(--color-card);
}
.cover-wrapper.dock .top {
  margin-bottom: 48px;
}
.cover-wrapper.dock .menu {
  background: rgba(255,255,255,0.5);
  position: absolute;
  bottom: 0;
  max-width: 100%;
}
.cover-wrapper.dock .menu .list-h {
  flex-wrap: nowrap;
  -webkit-flex-wrap: nowrap;
  -khtml-flex-wrap: nowrap;
  -moz-flex-wrap: nowrap;
  -o-flex-wrap: nowrap;
  -ms-flex-wrap: nowrap;
  margin: 4px;
}
.cover-wrapper.dock .menu .list-h a+a {
  margin-left: 4px;
}
@media screen and (max-width: 500px) {
  .cover-wrapper.dock .menu .list-h {
    overflow-x: scroll;
  }
  .cover-wrapper.dock .menu .list-h::-webkit-scrollbar {
    height: 0;
    width: 0;
  }
  .cover-wrapper.dock .menu .list-h::-webkit-scrollbar-track-piece {
    background: transparent;
  }
  .cover-wrapper.dock .menu .list-h::-webkit-scrollbar-thumb {
    background: #3dd9b6;
    cursor: pointer;
    border-radius: 0;
    -webkit-border-radius: 0;
  }
  .cover-wrapper.dock .menu .list-h::-webkit-scrollbar-thumb:hover {
    background: #ff5722;
  }
}
@supports (backdrop-filter: blur(20px)) {
  .cover-wrapper.dock .menu {
    background: rgba(255,255,255,0.5);
    backdrop-filter: saturate(200%) blur(20px);
  }
}
@font-face {
  font-family: 'UbuntuMono';
  src: url("https://unpkg.com/volantis-static@0.0.1654736714924/media/fonts/UbuntuMono/UbuntuMono-Regular.ttf");
  font-weight: 'normal';
  font-style: 'normal';
  font-display: swap;
}
@font-face {
  font-family: 'Varela Round';
  src: url("https://unpkg.com/volantis-static@0.0.1654736714924/media/fonts/VarelaRound/VarelaRound-Regular.ttf");
  font-weight: 'normal';
  font-style: 'normal';
  font-display: swap;
}
.l_header {
  position: fixed;
  z-index: 1000;
  top: 0;
  width: 100%;
  height: 64px;
  background: var(--color-card);
  box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
  -webkit-box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
}
.l_header.auto {
  transition: opacity 0.4s ease;
  -webkit-transition: opacity 0.4s ease;
  -khtml-transition: opacity 0.4s ease;
  -moz-transition: opacity 0.4s ease;
  -o-transition: opacity 0.4s ease;
  -ms-transition: opacity 0.4s ease;
  visibility: hidden;
}
.l_header.auto.show {
  opacity: 1 !important;
  -webkit-opacity: 1 !important;
  -moz-opacity: 1 !important;
  visibility: visible;
}
.l_header .container {
  margin-left: 16px;
  margin-right: 16px;
}
.l_header #wrapper {
  height: 100%;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
}
.l_header #wrapper .nav-main,
.l_header #wrapper .nav-sub {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  flex-wrap: nowrap;
  -webkit-flex-wrap: nowrap;
  -khtml-flex-wrap: nowrap;
  -moz-flex-wrap: nowrap;
  -o-flex-wrap: nowrap;
  -ms-flex-wrap: nowrap;
  justify-content: space-between;
  -webkit-justify-content: space-between;
  -khtml-justify-content: space-between;
  -moz-justify-content: space-between;
  -o-justify-content: space-between;
  -ms-justify-content: space-between;
  align-items: center;
}
.l_header #wrapper .nav-main {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.l_header #wrapper.sub .nav-main {
  transform: translateY(-64px);
  -webkit-transform: translateY(-64px);
  -khtml-transform: translateY(-64px);
  -moz-transform: translateY(-64px);
  -o-transform: translateY(-64px);
  -ms-transform: translateY(-64px);
}
.l_header #wrapper .nav-sub {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  opacity: 0;
  -webkit-opacity: 0;
  -moz-opacity: 0;
  height: 64px;
  width: calc(100% - 2 * 16px);
  position: absolute;
}
.l_header #wrapper .nav-sub ::-webkit-scrollbar {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
}
@media screen and (min-width: 2048px) {
  .l_header #wrapper .nav-sub {
    max-width: 55vw;
    margin: auto;
  }
}
.l_header #wrapper.sub .nav-sub {
  opacity: 1;
  -webkit-opacity: 1;
  -moz-opacity: 1;
}
.l_header #wrapper .title {
  position: relative;
  color: var(--color-text);
  padding-left: 24px;
  max-height: 64px;
}
.l_header #wrapper .nav-main .title {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  flex-shrink: 0;
  line-height: 64px;
  padding: 0 24px;
  font-size: 1.25rem;
  font-family: CodeNewRoman Nerd Font Mono, "Microsoft YaHei", Helvetica, monospace;
}
.l_header #wrapper .nav-main .title img {
  height: 64px;
}
.l_header .nav-sub {
  max-width: 1080px;
  margin: auto;
}
.l_header .nav-sub .title {
  font-weight: bold;
  font-family: "Microsoft YaHei", Menlo, Monaco, monospace, sans-serif;
  line-height: 1.2;
  max-height: 64px;
  white-space: normal;
  flex-shrink: 1;
}
.l_header .switcher {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  line-height: 64px;
  align-items: center;
}
.l_header .switcher .s-toc {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
}
@media screen and (max-width: 768px) {
  .l_header .switcher .s-toc {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: -ms-flexbox /* TWEENER - IE 10 */;
    display: -webkit-flex /* NEW - Chrome */;
    display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
    display: flex;
  }
}
.l_header .switcher >li {
  height: 48px;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  margin: 2px;
}
@media screen and (max-width: 500px) {
  .l_header .switcher >li {
    margin: 0 1px;
    height: 48px;
  }
}
.l_header .switcher >li >a {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  justify-content: center;
  -webkit-justify-content: center;
  -khtml-justify-content: center;
  -moz-justify-content: center;
  -o-justify-content: center;
  -ms-justify-content: center;
  align-items: center;
  width: 48px;
  height: 48px;
  padding: 0.85em 1.1em;
  border-radius: 100px;
  -webkit-border-radius: 100px;
  border: none;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  color: #3dd9b6;
}
.l_header .switcher >li >a:hover {
  border: none;
}
.l_header .switcher >li >a.active,
.l_header .switcher >li >a:active {
  border: none;
  background: var(--color-site-bg);
}
@media screen and (max-width: 500px) {
  .l_header .switcher >li >a {
    width: 36px;
    height: 48px;
  }
}
.l_header .nav-sub .switcher {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
}
.l_header .m_search {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  height: 64px;
  width: 240px;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
@media screen and (max-width: 1024px) {
  .l_header .m_search {
    width: 44px;
    min-width: 44px;
  }
  .l_header .m_search input::placeholder {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
  }
  .l_header .m_search:hover {
    width: 240px;
  }
  .l_header .m_search:hover input::placeholder {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@media screen and (min-width: 500px) {
  .l_header .m_search:hover .input {
    width: 100%;
  }
  .l_header .m_search:hover .input::placeholder {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@media screen and (max-width: 500px) {
  .l_header .m_search {
    min-width: 0;
  }
  .l_header .m_search input::placeholder {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
.l_header .m_search .form {
  position: relative;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  width: 100%;
  align-items: center;
}
.l_header .m_search .icon {
  position: absolute;
  width: 36px;
  left: 5px;
  color: var(--color-meta);
}
@media screen and (max-width: 500px) {
  .l_header .m_search .icon {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: none;
  }
}
.l_header .m_search .input {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  padding-top: 8px;
  padding-bottom: 8px;
  line-height: 1.3;
  width: 100%;
  color: var(--color-text);
  background: #fafafa;
  box-shadow: none;
  -webkit-box-shadow: none;
  box-sizing: border-box;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  padding-left: 40px;
  font-size: 0.875rem;
  border-radius: 8px;
  -webkit-border-radius: 8px;
  border: none;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
@media screen and (min-width: 500px) {
  .l_header .m_search .input:focus {
    box-shadow: 0 4px 8px 0px rgba(0,0,0,0.1);
    -webkit-box-shadow: 0 4px 8px 0px rgba(0,0,0,0.1);
  }
}
@media screen and (max-width: 500px) {
  .l_header .m_search .input {
    background: var(--color-block);
    padding-left: 8px;
    border: none;
  }
  .l_header .m_search .input:hover,
  .l_header .m_search .input:focus {
    border: none;
  }
}
@media (max-width: 500px) {
  .l_header .m_search {
    left: 0;
    width: 0;
    overflow: hidden;
    position: absolute;
    background: #fff;
    transition: all 0.28s ease;
    -webkit-transition: all 0.28s ease;
    -khtml-transition: all 0.28s ease;
    -moz-transition: all 0.28s ease;
    -o-transition: all 0.28s ease;
    -ms-transition: all 0.28s ease;
  }
  .l_header .m_search .input {
    border-radius: 32px;
    -webkit-border-radius: 32px;
    margin-left: 16px;
    padding-left: 16px;
  }
  .l_header.z_search-open .m_search {
    width: 100%;
  }
  .l_header.z_search-open .m_search .input {
    width: calc(100% - 120px);
  }
}
ul.m-pc >li>a {
  color: inherit;
  border-bottom: 2px solid transparent;
}
ul.m-pc >li>a:active,
ul.m-pc >li>a.active {
  border-bottom: 2px solid #3dd9b6;
}
ul.m-pc li:hover >ul.list-v,
ul.list-v li:hover >ul.list-v {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
}
ul.nav-list-h {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  align-items: stretch;
}
ul.nav-list-h>li {
  position: relative;
  justify-content: center;
  -webkit-justify-content: center;
  -khtml-justify-content: center;
  -moz-justify-content: center;
  -o-justify-content: center;
  -ms-justify-content: center;
  height: 100%;
  line-height: 2.4;
  border-radius: 4px;
  -webkit-border-radius: 4px;
}
ul.nav-list-h>li >a {
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  font-weight: 600;
}
ul.list-v {
  z-index: 1;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  position: absolute;
  background: var(--color-card);
  box-shadow: 0 2px 4px 0px rgba(0,0,0,0.08), 0 4px 8px 0px rgba(0,0,0,0.08), 0 8px 16px 0px rgba(0,0,0,0.08);
  -webkit-box-shadow: 0 2px 4px 0px rgba(0,0,0,0.08), 0 4px 8px 0px rgba(0,0,0,0.08), 0 8px 16px 0px rgba(0,0,0,0.08);
  margin-top: -6px;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  padding: 8px 0;
}
ul.list-v.show {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
}
ul.list-v hr {
  margin-top: 8px;
  margin-bottom: 8px;
}
ul.list-v >li {
  white-space: nowrap;
  word-break: keep-all;
}
ul.list-v >li.header {
  font-size: 0.78125rem;
  font-weight: bold;
  line-height: 2em;
  color: var(--color-meta);
  margin: 8px 16px 4px;
}
ul.list-v >li.header i {
  margin-right: 8px;
}
ul.list-v >li ul {
  margin-left: 0;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  margin-top: -40px;
}
ul.list-v .aplayer-container {
  min-height: 64px;
  padding: 6px 16px;
}
ul.list-v >li>a {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  color: var(--color-list);
  font-size: 0.875rem;
  font-weight: bold;
  line-height: 36px;
  padding: 0 20px 0 16px;
  text-overflow: ellipsis;
  margin: 0 4px;
  border-radius: 4px;
  -webkit-border-radius: 4px;
}
@media screen and (max-width: 1024px) {
  ul.list-v >li>a {
    line-height: 40px;
  }
}
ul.list-v >li>a >i {
  margin-right: 8px;
}
ul.list-v >li>a:active,
ul.list-v >li>a.active {
  color: var(--color-list-hl);
}
ul.list-v >li>a:hover {
  color: var(--color-list-hl);
  background: var(--color-site-bg);
}
.l_header .menu >ul>li>a {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  padding: 0 8px;
}
.l_header .menu >ul>li>a >i {
  margin-right: 4px;
}
.l_header ul.nav-list-h>li {
  color: var(--color-list);
  line-height: 64px;
}
.l_header ul.nav-list-h>li >a {
  max-height: 64px;
  overflow: hidden;
  color: inherit;
}
.l_header ul.nav-list-h>li >a:active,
.l_header ul.nav-list-h>li >a.active {
  color: #3dd9b6;
}
.l_header ul.nav-list-h>li:hover>a {
  color: var(--color-list-hl);
}
.l_header ul.nav-list-h>li i.music {
  animation: rotate-effect 1.5s linear infinite;
  -webkit-animation: rotate-effect 1.5s linear infinite;
  -khtml-animation: rotate-effect 1.5s linear infinite;
  -moz-animation: rotate-effect 1.5s linear infinite;
  -o-animation: rotate-effect 1.5s linear infinite;
  -ms-animation: rotate-effect 1.5s linear infinite;
}
@-moz-keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
@-webkit-keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
@-o-keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
@keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
.menu-phone li ul.list-v {
  right: calc(100% - 0.5 * 16px);
}
.menu-phone li ul.list-v ul {
  right: calc(100% - 0.5 * 16px);
}
#wrapper {
  max-width: 1080px;
  margin: auto;
}
@media screen and (min-width: 2048px) {
  #wrapper {
    max-width: 55vw;
  }
}
#wrapper .menu {
  -webkit-box-flex: 1;
  -moz-box-flex: 1;
  -webkit-flex: 1 1;
  -ms-flex: 1 1;
  flex: 1 1;
  margin: 0 16px 0 0;
}
#wrapper .menu .list-v ul {
  left: calc(100% - 0.5 * 16px);
}
.menu-phone {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  margin-top: 16px;
  right: 8px;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.menu-phone ul {
  right: calc(100% - 0.5 * 16px);
}
@media screen and (max-width: 500px) {
  .menu-phone {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: block;
  }
}
.l_header {
  max-width: 65vw;
  left: calc((100% - 65vw) * 0.5);
  border-bottom-left-radius: 8px;
  border-bottom-right-radius: 8px;
}
@media screen and (max-width: 2048px) {
  .l_header {
    max-width: 1112px;
    left: calc((100% - 1112px) * 0.5);
  }
}
@media screen and (max-width: 1112px) {
  .l_header {
    left: 0;
    border-radius: 0;
    -webkit-border-radius: 0;
    max-width: 100%;
  }
}
@media screen and (max-width: 500px) {
  .l_header .container {
    margin-left: 0;
    margin-right: 0;
  }
  .l_header #wrapper .nav-main .title {
    padding-left: 16px;
    padding-right: 16px;
  }
  .l_header #wrapper .nav-sub {
    width: 100%;
  }
  .l_header #wrapper .nav-sub .title {
    overflow-y: scroll;
    margin-top: 2px;
    padding: 8px 16px;
  }
  .l_header #wrapper .switcher {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: -ms-flexbox /* TWEENER - IE 10 */;
    display: -webkit-flex /* NEW - Chrome */;
    display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
    display: flex;
    margin-right: 8px;
  }
  .l_header .menu {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: none;
  }
}
@media screen and (max-width: 500px) {
  .list-v li {
    max-width: 270px;
  }
}
#u-search {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  padding: 60px 20px;
  z-index: 1001;
}
@media screen and (max-width: 680px) {
  #u-search {
    padding: 0px;
  }
}

  </style>
  <link rel="stylesheet" href="/css/style.css" media="print" onload="this.media='all';this.onload=null">
  <noscript><link rel="stylesheet" href="/css/style.css"></noscript>
  
<script>
if (/*@cc_on!@*/false || (!!window.MSInputMethodContext && !!document.documentMode))
    document.write(
	'<style>'+
		'html{'+
			'overflow-x: hidden !important;'+
			'overflow-y: hidden !important;'+
		'}'+
		'.kill-ie{'+
			'text-align:center;'+
			'height: 100%;'+
			'margin-top: 15%;'+
			'margin-bottom: 5500%;'+
		'}'+
    '.kill-t{'+
      'font-size: 2rem;'+
    '}'+
    '.kill-c{'+
      'font-size: 1.2rem;'+
    '}'+
		'#l_header,#l_body{'+
			'display: none;'+
		'}'+
	'</style>'+
    '<div class="kill-ie">'+
        `<span class="kill-t"><b>抱歉，您的浏览器无法访问本站</b></span><br/>`+
        `<span class="kill-c">微软已经于2016年终止了对 Internet Explorer (IE) 10 及更早版本的支持，<br/>继续使用存在极大的安全隐患，请使用当代主流的浏览器进行访问。</span><br/>`+
        `<a target="_blank" rel="noopener" href="https://blogs.windows.com/windowsexperience/2021/05/19/the-future-of-internet-explorer-on-windows-10-is-in-microsoft-edge/"><strong>了解详情 ></strong></a>`+
    '</div>');
</script>


<noscript>
	<style>
		html{
			overflow-x: hidden !important;
			overflow-y: hidden !important;
		}
		.kill-noscript{
			text-align:center;
			height: 100%;
			margin-top: 15%;
			margin-bottom: 5500%;
		}
    .kill-t{
      font-size: 2rem;
    }
    .kill-c{
      font-size: 1.2rem;
    }
		#l_header,#l_body{
			display: none;
		}
	</style>
    <div class="kill-noscript">
        <span class="kill-t"><b>抱歉，您的浏览器无法访问本站</b></span><br/>
        <span class="kill-c">本页面需要浏览器支持（启用）JavaScript</span><br/>
        <a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=启用JavaScript"><strong>了解详情 ></strong></a>
    </div>
</noscript>


  <script>
  /************这个文件存放不需要重载的全局变量和全局函数*********/
  window.volantis = {}; // volantis 全局变量
  volantis.debug = "env"; // 调试模式
  volantis.dom = {}; // 页面Dom see: /source/js/app.js etc.

  volantis.GLOBAL_CONFIG ={
    debug: "env",
    cdn: {"js":{"app":"/js/app.js","parallax":"/js/plugins/parallax.js","rightMenu":"/js/plugins/rightMenu.js","rightMenus":"/js/plugins/rightMenus.js","sites":"/js/plugins/tags/sites.js","friends":"/js/plugins/tags/friends.js","contributors":"/js/plugins/tags/contributors.js","search":"/js/search/hexo.js"},"css":{"style":"/css/style.css"}},
    default: {"avatar":"https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/avatar/round/3442075.svg","link":"https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/link/8f277b4ee0ecd.svg","cover":"https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/cover/76b86c0226ffd.svg","image":"https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/image/2659360.svg"},
    lastupdate: new Date(1720947040480),
    sidebar: {
      for_page: ["blogger","category","tagcloud"],
      for_post: ["toc"],
      webinfo: {
        lastupd: {
          enable: true,
          friendlyShow: true
        },
        runtime: {
          data: "2024/07/13",
          unit: "天"
        }
      }
    },
    plugins: {
      message: {"enable":true,"css":"https://unpkg.com/volantis-static@0.0.1654736714924/libs/izitoast/dist/css/iziToast.min.css","js":"https://unpkg.com/volantis-static@0.0.1654736714924/libs/izitoast/dist/js/iziToast.min.js","icon":{"default":"fa-solid fa-info-circle light-blue","quection":"fa-solid fa-question-circle light-blue"},"time":{"default":5000,"quection":20000},"position":"topRight","transitionIn":"bounceInLeft","transitionOut":"fadeOutRight","titleColor":"var(--color-text)","messageColor":"var(--color-text)","backgroundColor":"var(--color-card)","zindex":2147483647,"copyright":{"enable":true,"title":"知识共享许可协议","message":"请遵守 CC BY-NC-SA 4.0 协议。","icon":"far fa-copyright light-blue"},"aplayer":{"enable":true,"play":"fa-solid fa-play","pause":"fa-solid fa-pause"},"rightmenu":{"enable":true,"notice":true}},
      fancybox: {"css":"https://unpkg.com/volantis-static@0.0.1654736714924/libs/@fancyapps/ui/dist/fancybox.css","js":"https://unpkg.com/volantis-static@0.0.1654736714924/libs/@fancyapps/ui/dist/fancybox.umd.js"},
      
      
      
    }
  }

  /******************** volantis.EventListener ********************************/
  // 事件监听器 see: /source/js/app.js
  volantis.EventListener = {}
  // 这里存放pjax切换页面时将被移除的事件监听器
  volantis.EventListener.list = []
  //构造方法
  function volantisEventListener(type, f, ele) {
    this.type = type
    this.f = f
    this.ele = ele
  }
  // 移除事件监听器
  volantis.EventListener.remove = () => {
    volantis.EventListener.list.forEach(function (i) {
      i.ele.removeEventListener(i.type, i.f, false)
    })
    volantis.EventListener.list = []
  }
  /******************** volantis.dom.$ ********************************/
  // 注：这里没有选择器，也没有forEach一次只处理一个dom，这里重新封装主题常用的dom方法，返回的是dom对象，对象包含了以下方法，同时保留dom的原生API
  function volantisDom(ele) {
    if (!ele) ele = document.createElement("div")
    this.ele = ele;
    // ==============================================================
    this.ele.find = (c) => {
      let q = this.ele.querySelector(c)
      if (q)
        return new volantisDom(q)
    }
    // ==============================================================
    this.ele.hasClass = (c) => {
      return this.ele.className.match(new RegExp('(\\s|^)' + c + '(\\s|$)'));
    }
    this.ele.addClass = (c) => {
      this.ele.classList.add(c);
      return this.ele
    }
    this.ele.removeClass = (c) => {
      this.ele.classList.remove(c);
      return this.ele
    }
    this.ele.toggleClass = (c) => {
      if (this.ele.hasClass(c)) {
        this.ele.removeClass(c)
      } else {
        this.ele.addClass(c)
      }
      return this.ele
    }
    // ==============================================================
    // 参数 r 为 true 表示pjax切换页面时事件监听器将被移除，false不移除
    this.ele.on = (c, f, r = 1) => {
      this.ele.addEventListener(c, f, false)
      if (r) {
        volantis.EventListener.list.push(new volantisEventListener(c, f, this.ele))
      }
      return this.ele
    }
    this.ele.click = (f, r) => {
      this.ele.on("click", f, r)
      return this.ele
    }
    this.ele.scroll = (f, r) => {
      this.ele.on("scroll", f, r)
      return this.ele
    }
    // ==============================================================
    this.ele.html = (c) => {
      // if(c=== undefined){
      //   return this.ele.innerHTML
      // }else{
      this.ele.innerHTML = c
      return this.ele
      // }
    }
    // ==============================================================
    this.ele.hide = (c) => {
      this.ele.style.display = "none"
      return this.ele
    }
    this.ele.show = (c) => {
      this.ele.style.display = "block"
      return this.ele
    }
    // ==============================================================
    return this.ele
  }
  volantis.dom.$ = (ele) => {
    return !!ele ? new volantisDom(ele) : null;
  }
  /******************** RunItem ********************************/
  function RunItem() {
    this.list = []; // 存放回调函数
    this.start = () => {
      for (var i = 0; i < this.list.length; i++) {
        this.list[i].run();
      }
    };
    this.push = (fn, name, setRequestAnimationFrame = true) => {
      let myfn = fn
      if (setRequestAnimationFrame) {
        myfn = ()=>{
          volantis.requestAnimationFrame(fn)
        }
      }
      var f = new Item(myfn, name);
      this.list.push(f);
    };
    this.remove = (name) =>{
      for (let index = 0; index < this.list.length; index++) {
        const e = this.list[index];
        if (e.name == name) {
          this.list.splice(index,1);
        }
      }
    }
    // 构造一个可以run的对象
    function Item(fn, name) {
      // 函数名称
      this.name = name || fn.name;
      // run方法
      this.run = () => {
        try {
          fn()
        } catch (error) {
          console.log(error);
        }
      };
    }
  }
  /******************** Pjax ********************************/
  // /layout/_plugins/pjax/index.ejs
  // volantis.pjax.send(callBack[,"callBackName"]) 传入pjax:send回调函数
  // volantis.pjax.push(callBack[,"callBackName"]) 传入pjax:complete回调函数
  // volantis.pjax.error(callBack[,"callBackName"]) 传入pjax:error回调函数
  volantis.pjax = {};
  volantis.pjax.method = {
    complete: new RunItem(),
    error: new RunItem(),
    send: new RunItem(),
  };
  volantis.pjax = Object.assign(volantis.pjax, {
    push: volantis.pjax.method.complete.push,
    error: volantis.pjax.method.error.push,
    send: volantis.pjax.method.send.push,
  });
  /******************** RightMenu ********************************/
  // volantis.rightmenu.handle(callBack[,"callBackName"]) 外部菜单项控制
  // 可在 volantis.mouseEvent 处获取右键事件
  volantis.rightmenu = {};
  volantis.rightmenu.method = {
    handle: new RunItem(),
  }
  volantis.rightmenu = Object.assign(volantis.rightmenu, {
    handle: volantis.rightmenu.method.handle.push,
  });
  /********************  Dark Mode  ********************************/
  // /layout/_partial/scripts/darkmode.ejs
  // volantis.dark.mode 当前模式 dark or light
  // volantis.dark.toggle() 暗黑模式触发器
  // volantis.dark.push(callBack[,"callBackName"]) 传入触发器回调函数
  volantis.dark = {};
  volantis.dark.method = {
    toggle: new RunItem(),
  };
  volantis.dark = Object.assign(volantis.dark, {
    push: volantis.dark.method.toggle.push,
  });
  /********************  Message  ********************************/
  // VolantisApp.message
  /********************  isMobile  ********************************/
  // /source/js/app.js
  // volantis.isMobile
  // volantis.isMobileOld
  /********************脚本动态加载函数********************************/
  // volantis.js(src, cb)  cb 可以传入onload回调函数 或者 JSON对象 例如: volantis.js("src", ()=>{}) 或 volantis.js("src", {defer:true,onload:()=>{}})
  // volantis.css(src)

  // 返回Promise对象，如下方法同步加载资源，这利于处理文件资源之间的依赖关系，例如：APlayer 需要在 MetingJS 之前加载
  // (async () => {
  //     await volantis.js("...theme.plugins.aplayer.js.aplayer...")
  //     await volantis.js("...theme.plugins.aplayer.js.meting...")
  // })();

  // 已经加入了setTimeout
  volantis.js = (src, cb) => {
    return new Promise(resolve => {
      setTimeout(function () {
        var HEAD = document.getElementsByTagName("head")[0] || document.documentElement;
        var script = document.createElement("script");
        script.setAttribute("type", "text/javascript");
        if (cb) {
          if (JSON.stringify(cb)) {
            for (let p in cb) {
              if (p == "onload") {
                script[p] = () => {
                  cb[p]()
                  resolve()
                }
              } else {
                script[p] = cb[p]
                script.onload = resolve
              }
            }
          } else {
            script.onload = () => {
              cb()
              resolve()
            };
          }
        } else {
          script.onload = resolve
        }
        script.setAttribute("src", src);
        HEAD.appendChild(script);
      });
    });
  }
  volantis.css = (src) => {
    return new Promise(resolve => {
      setTimeout(function () {
        var link = document.createElement('link');
        link.rel = "stylesheet";
        link.href = src;
        link.onload = resolve;
        document.getElementsByTagName("head")[0].appendChild(link);
      });
    });
  }
  /********************按需加载的插件********************************/
  // volantis.import.jQuery().then(()=>{})
  volantis.import = {
    jQuery: () => {
      if (typeof jQuery == "undefined") {
        return volantis.js("https://unpkg.com/volantis-static@0.0.1654736714924/libs/jquery/dist/jquery.min.js")
      } else {
        return new Promise(resolve => {
          resolve()
        });
      }
    }
  }
  /********************** requestAnimationFrame ********************************/
  // 1、requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。
  // 2、在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的的 cpu，gpu 和内存使用量。
  volantis.requestAnimationFrame = (fn)=>{
    if (!window.requestAnimationFrame) {
      window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame;
    }
    window.requestAnimationFrame(fn)
  }
  /************************ layoutHelper *****************************************/
  volantis.layoutHelper = (helper, html, opt)=>{
    opt = Object.assign({clean:false, pjax:true}, opt)
    function myhelper(helper, html, clean) {
      volantis.tempDiv = document.createElement("div");
      volantis.tempDiv.innerHTML = html;
      let layoutHelper = document.querySelector("#layoutHelper-"+helper)
      if (layoutHelper) {
        if (clean) {
          layoutHelper.innerHTML = ""
        }
        layoutHelper.append(volantis.tempDiv);
      }
    }
    myhelper(helper, html, opt.clean)
    if (opt.pjax) {
      volantis.pjax.push(()=>{
        myhelper(helper, html, opt.clean)
      },"layoutHelper-"+helper)
    }
  }
  /****************************** 滚动事件处理 ****************************************/
  volantis.scroll = {
    engine: new RunItem(),
    unengine: new RunItem(),
  };
  volantis.scroll = Object.assign(volantis.scroll, {
    push: volantis.scroll.engine.push,
  });
  // 滚动条距离顶部的距离
  volantis.scroll.getScrollTop = () =>{
    let scrollPos;
    if (window.pageYOffset) {
      scrollPos = window.pageYOffset;
    } else if (document.compatMode && document.compatMode != 'BackCompat') {
      scrollPos = document.documentElement.scrollTop;
    } else if (document.body) {
      scrollPos = document.body.scrollTop;
    }
    return scrollPos;
  }
  // 使用 requestAnimationFrame 处理滚动事件
  // `volantis.scroll.del` 中存储了一个数值, 该数值检测一定时间间隔内滚动条滚动的位移, 数值的检测频率是浏览器的刷新频率. 数值为正数时, 表示向下滚动. 数值为负数时, 表示向上滚动.
  volantis.scroll.handleScrollEvents = () => {
    volantis.scroll.lastScrollTop = volantis.scroll.getScrollTop()
    function loop() {
      const scrollTop = volantis.scroll.getScrollTop();
      if (volantis.scroll.lastScrollTop !== scrollTop) {
        volantis.scroll.del = scrollTop - volantis.scroll.lastScrollTop;
        volantis.scroll.lastScrollTop = scrollTop;
        // if (volantis.scroll.del > 0) {
        //   console.log("向下滚动");
        // } else {
        //   console.log("向上滚动");
        // }
        // 注销过期的unengine未滚动事件
        volantis.scroll.unengine.list=[]
        volantis.scroll.engine.start();
      }else{
        volantis.scroll.unengine.start();
      }
      volantis.requestAnimationFrame(loop)
    }
    volantis.requestAnimationFrame(loop)
  }
  volantis.scroll.handleScrollEvents()
  volantis.scroll.ele = null;
  // 触发页面滚动至目标元素位置
  volantis.scroll.to = (ele, option = {}) => {
    if (!ele) return;
    volantis.scroll.ele = ele;
    // 默认配置
    opt = {
      top: ele.getBoundingClientRect().top + document.documentElement.scrollTop,
      behavior: "smooth"
    }
    // 定义配置
    if ("top" in option) {
      opt.top = option.top
    }
    if ("behavior" in option) {
      opt.behavior = option.behavior
    }
    if ("addTop" in option) {
      opt.top += option.addTop
    }
    if (!("observerDic" in option)) {
      option.observerDic = 100
    }
    // 滚动
    window.scrollTo(opt);
    // 监视器
    // 监视并矫正元素滚动到指定位置
    // 用于处理 lazyload 引起的 cls 导致的定位失败问题
    // option.observer = false
    if (option.observer) {
      setTimeout(() => {
        if (volantis.scroll.ele != ele) {
          return
        }
        volantis.scroll.unengine.push(() => {
          let me = ele.getBoundingClientRect().top
          if(!(me >= -option.observerDic && me <= option.observerDic)){
            volantis.scroll.to(ele, option)
          }
          volantis.scroll.unengine.remove("unengineObserver")
        },"unengineObserver")
      },1000)
    }
  }
  /********************** Content Visibility ********************************/
  // 见 source/css/first.styl 如果遇到任何问题 删除 .post-story 即可
  // 一个元素被声明 content-visibility 属性后 如果元素不在 viewport 中 浏览器不会计算其后代元素样式和属性 从而节省 Style & Layout 耗时
  // content-visibility 的副作用: 锚点失效 等等(实验初期 暂不明确), 使用此方法清除样式
  volantis.cleanContentVisibility = ()=>{
    if (document.querySelector(".post-story")) {
      console.log("cleanContentVisibility");
      document.querySelectorAll(".post-story").forEach(e=>{
        e.classList.remove("post-story")
      })
    }
  }
  /******************************************************************************/
  /******************************************************************************/
  /******************************************************************************/
  //图像加载出错时的处理
  function errorImgAvatar(img) {
    img.src = "https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/avatar/round/3442075.svg";
    img.onerror = null;
  }
  function errorImgCover(img) {
    img.src = "https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/cover/76b86c0226ffd.svg";
    img.onerror = null;
  }
  /******************************************************************************/
</script>

  <!-- import head_end begin -->
  <!-- import head_end end -->
  <!-- Custom Files headEnd begin-->
  
  <!-- Custom Files headEnd end-->
  <!-- front-matter head_end begin -->
  <!-- front-matter head_end end -->
</head>
  <body itemscope itemtype="http://schema.org/WebPage">
    <!-- import body_begin begin-->
    <!-- import body_begin end-->
    <!-- Custom Files bodyBegin begin-->
    
    <!-- Custom Files bodyBegin end-->
    <!-- front-matter body_begin begin -->
    <!-- front-matter body_begin end -->
    <header itemscope itemtype="http://schema.org/WPHeader" id="l_header" class="l_header auto shadow floatable blur " style='opacity: 0' >
  <div class='container'>
  <div id='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h m-phone' id="pjax-header-nav-list">
        <li><a id="s-comment" class="fa-solid fa-comments fa-fw" target="_self"  href="/" onclick="return false;" title="comment"></a></li>
        
          <li><a id="s-toc" class="s-toc fa-solid fa-list fa-fw" target="_self"  href="/" onclick="return false;" title="toc"></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
            <img no-lazy class='logo' src='https://gcore.jsdelivr.net/gh/Ricky-Daxia/Hei_Xiu/202407132356265.png'/>
          
          
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h m-pc'>
          
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/" title="博客"
                  
                  
                  
                    active-action="action-home"
                  >
                  <i class='fa-solid fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/categories/" title="分类"
                  
                  
                  
                    active-action="action-categories"
                  >
                  <i class='fa-solid fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/tags/" title="标签"
                  
                  
                  
                    active-action="action-tags"
                  >
                  <i class='fa-solid fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/archives/" title="归档"
                  
                  
                  
                    active-action="action-archives"
                  >
                  <i class='fa-solid fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/friends/" title="友链"
                  
                  
                  
                    active-action="action-friends"
                  >
                  <i class='fa-solid fa-link fa-fw'></i>友链
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/about/" title="关于"
                  
                  
                  
                    active-action="action-about"
                  >
                  <i class='fa-solid fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
          
				</ul>
			</div>
      
      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fa-solid fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>
      

			<ul class='switcher nav-list-h m-phone'>
				
					<li><a class="s-search fa-solid fa-search fa-fw" target="_self" href="/" onclick="return false;" title="search"></a></li>
				
				<li>
          <a class="s-menu fa-solid fa-bars fa-fw" target="_self" href="/" onclick="return false;" title="menu"></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/" title="博客"
                  
                  
                  
                    active-action="action-home"
                  >
                  <i class='fa-solid fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/categories/" title="分类"
                  
                  
                  
                    active-action="action-categories"
                  >
                  <i class='fa-solid fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/tags/" title="标签"
                  
                  
                  
                    active-action="action-tags"
                  >
                  <i class='fa-solid fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/archives/" title="归档"
                  
                  
                  
                    active-action="action-archives"
                  >
                  <i class='fa-solid fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/friends/" title="友链"
                  
                  
                  
                    active-action="action-friends"
                  >
                  <i class='fa-solid fa-link fa-fw'></i>友链
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/about/" title="关于"
                  
                  
                  
                    active-action="action-about"
                  >
                  <i class='fa-solid fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>

      <!-- Custom Files header begin -->
      
      <!-- Custom Files header end -->
		</div>
	</div>
  </div>
</header>

    <div id="l_body">
      <div id="l_cover">
  
    
      <!-- see: /layout/_partial/scripts/_ctrl/coverCtrl.ejs -->
      <div id="half" class='cover-wrapper post dock' style="display: ;">
        
  <div class='cover-bg lazyload placeholder' data-bg="https://gcore.jsdelivr.net/gh/Ricky-Daxia/Hei_Xiu@1.0/20240713223219.jpg"></div>

<div class='cover-body'>
  <div class='top'>
    
    
      <p class="title">Rikki's Blog</p>
    
    
      <p class="subtitle">我还以为你永远都不会来看我呢</p>
    
  </div>
  <div class='bottom'>
    <div class='menu navigation'>
      <div class='list-h'>
        
          
            <a href="/"
              
              
              active-action="action-home">
              <img src='https://fastly.jsdelivr.net/gh/twitter/twemoji@13.0.0/assets/svg/1f3d5.svg'><p>主页</p>
            </a>
          
            <a href="/categories/"
              
              
              active-action="action-categories">
              <img src='https://fastly.jsdelivr.net/gh/twitter/twemoji@13.0.2/assets/svg/1f4c2.svg'><p>分类</p>
            </a>
          
            <a href="/tags/"
              
              
              active-action="action-tags">
              <img src='https://fastly.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f516.svg'><p>标签</p>
            </a>
          
            <a href="/archives/"
              
              
              active-action="action-archives">
              <img src='https://fastly.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f5c3.svg'><p>归档</p>
            </a>
          
            <a href="/friends/"
              
              
              active-action="action-friends">
              <img src='https://fastly.jsdelivr.net/gh/twitter/twemoji@13.0.0/assets/svg/1f37b.svg'><p>友链</p>
            </a>
          
            <a href="/about/"
              
              
              active-action="action-about">
              <img src='https://fastly.jsdelivr.net/gh/twitter/twemoji@13.0.2/assets/svg/2139.svg'><p>关于</p>
            </a>
          
        
      </div>
    </div>
  </div>
</div>

        <div id="scroll-down" style="display: none;"><i class="fa fa-chevron-down scroll-down-effects"></i></div>
      </div>
    
  
</div>

      <div id="safearea">
        <div class="body-wrapper">
          
<div id="l_main" class=''>
  <article itemscope itemtype="http://schema.org/Article" class="article post white-box reveal md shadow floatable blur article-type-post" id="post" itemscope itemprop="blogPost">
  <link itemprop="mainEntityOfPage" href="https://ricky-daxia.github.io/2024/07/14/动态规划题目整理/">
  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Rikki's Blog">
  </span>
  <span hidden itemprop="post" itemscope itemtype="http://schema.org/Post">
    <meta itemprop="name" content="Rikki's Blog">
    <meta itemprop="description" content="hhh">
  </span>
  


  
    <span hidden>
      <meta itemprop="image" content="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png">
    </span>
  
  <div class="article-meta" id="top">
    
    
    
      <h1 class="title" itemprop="name headline">
        动态规划题目整理
      </h1>
      <div class='new-meta-box'>
        
          
            
<div class='new-meta-item author' itemprop="author" itemscope itemtype="http://schema.org/Person">
  <a itemprop="url" class='author' target="_blank" href="https://github.com/Ricky-Daxia" rel="nofollow noopener">
    <img itemprop="image" src="https://gcore.jsdelivr.net/gh/Ricky-Daxia/Hei_Xiu/202407132303067.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/Ricky-Daxia/Hei_Xiu/202407132303067.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">
    <p itemprop="name">钱力古</p>
  </a>
</div>

          
        
          
            
  <div class='new-meta-item category'>
    <i class="fa-solid fa-folder-open fa-fw" aria-hidden="true"></i>
    <a class="category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
    
      <span hidden itemprop="about" itemscope itemtype="http://schema.org/Thing">
        <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url"><span itemprop="name">算法</span></a>
      </span>
    
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateCreated datePublished" datetime="2024-07-14T15:13:10+08:00">
  <a class='notlink'>
    <i class="fa-solid fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2024年7月14日</p>
  </a>
</div>

          
        
          
            



          
        
        <!-- Custom Files topMeta begin-->
        
        <!-- Custom Files topMeta end-->
      </div>
    
  </div>


  <div id="layoutHelper-page-plugins"></div>
  <div id="post-body" itemprop="articleBody">
    <h1 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h1><h3 id="小感想"><a href="#小感想" class="headerlink" title="小感想"></a>小感想</h3><ul>
<li>比如常规定义 <code>f[i][j]</code> 表示第 <code>i</code> 个物品放第 <code>j</code> 个位置的最大值，其实有一种复杂度更低的定义方式，<code>f[i][j]</code> 表示第 <code>i</code> 个物品放不放在 <code>j</code> 的最大值，转移时就两种情况，放-&gt;<code>f[i-1][j-1]</code>，不放-&gt;<code>f[i][j-1]</code></li>
<li>一道题缝了完全背包跟多重背包的话，根据容量分开计算（它们的枚举顺序都不同）</li>
<li>环形石子合并，变成 <code>2n</code> 的链，用记忆化搜索求一遍，最后遍历 <code>f[i][i+n-1]</code> 求最值</li>
<li>区间 DP，<strong>确定操作顺序</strong>，一个区间操作完的最优情况一定是最后一个操作边界，假如是中间的话，在从一个边界到另一个边界的过程中可以<strong>顺手操作中间这个</strong>，没必要留到最后</li>
<li>看到图论相关的 DP，想想这个图是有向图还是无向图？可能存在环吗？存在环的话要不要缩点？边的指向关系是谁指向谁</li>
<li>环形处理见 <strong>P1357 花园</strong></li>
<li>建图技巧：题目说要在矩阵或数组的单元格中跳跃，从值小的跳到大的，显然是有向无环图最长路。第一点：同一行&#x2F;列，只在大小相邻的点之间建边，即 <code>u&lt;v&lt;w</code>，建 <code>(u,v)</code> 和 <code>(v,w)</code>。第二点：对于同值节点组成的集合，设 <code>S</code>、<code>T</code>，建立 <code>dummy</code> 节点，建 <code>(S, dummy)</code> 和 <code>(dummy, T)</code>，这样就把边数由 <code>|S||T|</code> 降为 <code>|S|+|T|</code></li>
</ul>
<h3 id="状态设计"><a href="#状态设计" class="headerlink" title="状态设计"></a>状态设计</h3><h4 id="求-1-号点到-n-号点长度不超过-d-n-K-的路径数"><a href="#求-1-号点到-n-号点长度不超过-d-n-K-的路径数" class="headerlink" title="求 1 号点到 n 号点长度不超过 d[n]+K 的路径数"></a>求 1 号点到 n 号点长度不超过 d[n]+K 的路径数</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3953">https://www.luogu.com.cn/problem/P3953</a><br>有向图，无重边和自环，存在权值为 <code>0</code> 的边，设 <code>1-&gt;n</code> 的最短路径为 <code>d</code>，求 <code>1-&gt;n</code> 的长度不超过 <code>d+K</code> 的路径数（可能存在无穷条，此时输出<code>-1</code>）<br>点数、边数范围是 <code>1e5</code>，<code>K</code> 范围是 <code>50</code></p>
</blockquote>
<p><img src="https://gcore.jsdelivr.net/gh/Ricky-Daxia/Hei_Xiu/202407141514642.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/Ricky-Daxia/Hei_Xiu/202407141514642.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<ul>
<li>怎么判断是不是无穷？当计算状态 <code>f[u][k]</code> 时记录 <code>st[u][k]=true</code>，如果在此过程中又碰到计算 <code>f[u][k]</code>，那就说明答案是无穷</li>
<li>由于状态转移方程是要寻找 <code>u-&gt;v</code> 的 <code>u</code>，可以存一个反图，方便转移</li>
</ul>
<pre><code class="cpp">int dp(int u, int k) &#123;
    if (k &lt; 0) &#123;
        return 0;
    &#125;
    if (st[u][k]) &#123;
        flag = true;
        return 0;
    &#125;
    if (f[u][k] != -1) &#123;
        return f[u][k];
    &#125;
    st[u][k] = true;
    int &amp;res = f[u][k];
    res = 0;
    for (auto &amp;[v, w]: g2[u]) &#123;
        res = (res + dp(v, dist[u] + k - dist[v] - w)) % P;
        if (flag) &#123;
            return 0;
        &#125;
    &#125;
    st[u][k] = false;
    return res;
&#125;

        cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; P;
        memset(f, -1, sizeof(f));
        memset(st, 0, sizeof(st));
        for (int i = 1; i &lt;= n; i++) &#123;
            g1[i].clear();
            g2[i].clear();
        &#125;
        for (int i = 0; i &lt; m; i++) &#123;
            int x, y, w;
            cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;
            g1[x].push_back(&#123;y, w&#125;);
            g2[y].push_back(&#123;x, w&#125;);
        &#125;
        dijkstra();
        dp(1, 0);
        f[1][0] = 1;
        int res = 0;
        for (int i = 0; i &lt;= k; i++) &#123;
            res = (res + dp(n, i)) % P;
        &#125;
        if (flag) &#123;
            cout &lt;&lt; -1 &lt;&lt; endl;
        &#125; else &#123;
            cout &lt;&lt; res &lt;&lt; endl;
        &#125;
        flag = false;
</code></pre>
<h3 id="树上背包"><a href="#树上背包" class="headerlink" title="树上背包"></a>树上背包</h3><h4 id="选课"><a href="#选课" class="headerlink" title="选课"></a><strong>选课</strong></h4><blockquote>
<p>现在有 <code>n</code> 门课程，第 <code>i</code> 门课程的学分为 <code>a[i]</code>，每门课程有零门或一门先修课，有先修课的课程需要先学完其先修课，才能学习该课程。<br>一位学生要学习 <code>m</code> 门课程，求其能获得的最多学分数。</p>
</blockquote>
<p>把父节点 <code>x</code> 和儿子看成物品，一共 <code>n</code> 个物品，容量为 <code>m</code>，典型的 01 背包。定义 <code>f(x, i, j)</code> 表示以 <code>x</code> 为根的子树，考虑了前 <code>i</code> 个子树，选了 <code>j</code> 个物品的最大价值。<code>f(x,i,j)&lt;-f(x,i-1,j)</code> 或者 <code>f(x,i,j)&lt;-f(x,i-1,j-v[i])+w[i]</code></p>
<p>转移方程就是：<strong>规定根节点必选（因为不选根节点就无法选子节点）</strong>，枚举子节点选多少个，即 <code>f[x][i][j]=max&#123;f[x][i-1][j], f[x][i-1][j-k]+f[v][sz[v]][k]</code>，其中 <code>0&lt;=k&lt;j</code>，其中前者又是 <code>k=0</code> 时的情况，因此可合并到后面的式子中</p>
<p>边界条件：<code>f[x][1][0]=0, f[x][1][1]=1</code>，分别代表不选和选根节点</p>
<p>优化思路：用已经求好的答案更新未来的问题，即 <code>f[x][i+1][j+k]=max&#123;f[v][sz[v]][k]+f[x][i][j]&#125;</code>，其中第二维可以通过倒序枚举来优化掉，复杂度的证明用到了 lca 的知识</p>
<p><strong>TODO：还没弄懂</strong></p>
<pre><code class="cpp">int dfs(int u) &#123;
    int p = 1;
    f[u][1] = s[u];
    for (int v: g[u]) &#123;
        int sz = dfs(v);
        for (int i = min(p, m + 1); i; i--) &#123;
            for (int j = 1; j &lt;= sz &amp;&amp; i + j &lt;= m + 1; j++) &#123;
                f[u][i + j] = max(f[u][i + j], f[u][i] + f[v][j]);
            &#125;
        &#125;
        p += sz;
    &#125;
    return p;
&#125;
</code></pre>
<h4 id="取气球"><a href="#取气球" class="headerlink" title="取气球"></a>取气球</h4><blockquote>
<p>有 <code>n</code> 个气球用绳子连接，构成一棵树，给出点权和边权</p>
<ul>
<li>要么删一条边，获得子树所有气球</li>
<li>要么删掉一个根节点，获得子树所有气球<br>  问不超过给定代价的情况下，最多拿走几个气球</li>
</ul>
</blockquote>
<p>对于树上背包，另一种定义状态是 <code>f[u][j]</code> 表示以 <code>u</code> 为根的子树，获得 <code>j</code> 个气球的最小代价</p>
<p><strong>边权转点权</strong>的技巧：把每个气球上方的边看成一个点，点权为 <code>b[u]</code>，表示花 <code>b[u]</code> 代价获得 <code>u</code> 这棵子树</p>
<ol>
<li>如果 <code>b[u]&lt;=j</code>，直接获得子树是最优的，<code>f[u][j]=b[u]</code></li>
<li>对子树转移：<code>f[u][j+k]=min(f[u][j+k], f[u][j]+f[v][k])</code></li>
<li>对于 <code>u</code> 的代价不小于 <code>a[u]</code> 的情况：<code>f[u][sz[u]-1]=min(f[u][sz[u]-1],a[u])，f[u][sz[u]]=min(f[u][sz[u]],b[u])</code></li>
</ol>
<pre><code class="cpp">int dfs(int u) &#123;
    memset(f[u], 0x3f, sizeof f[u]);
    f[u][0] = 0; // 获得 0 个气球
    int p = 1;
    for (auto &amp;v: g[u]) &#123;
        int sz = dfs(v);
        for (int i = min(p, n); i &gt;= 0; i--) &#123; // 当前选了 i 个点 属于第三维 倒序
            for (int j = 1; j &lt;= sz &amp;&amp; i + j &lt;= n; j++) &#123; // 更新未来的答案
                f[u][i + j] = min(f[u][i + j], f[u][i] + f[v][j]);
            &#125;
        &#125;
        p += sz;
    &#125;
    f[u][p - 1] = min(f[u][p - 1], a[u]); // 删掉根节点的代价是 a[u] 获得子树
    if (u &gt; 1) &#123;
        f[u][p] = min(f[u][p], b[u]); // 删掉根节点所连的边代价是 b[u] 获得整个子树
    &#125;
    return p;
&#125;

    int res = 0;
    for (int i = 1; i &lt;= n; i++) &#123;
        if (f[1][i] &lt;= m) &#123;
            res = i;
        &#125;
    &#125;
</code></pre>
<h4 id="洛谷-P1273-有线电视网"><a href="#洛谷-P1273-有线电视网" class="headerlink" title="洛谷 P1273 有线电视网"></a>洛谷 P1273 有线电视网</h4><p>对于这种树上问最多满足的节点数量的，要想到是背包</p>
<p>经典定义 <code>f[i][j]</code> 表示以 <code>i</code> 为根的子树，满足 <code>j</code> 个用户的最大收益。显然对于根节点，直接就是 <code>f[u][1] = w[u]</code>；然后就考虑背包部分，考虑每个子节点，递归计算，然后合并（倒序枚举体积，正序枚举当前子树选几个），这样做下来，对于树形背包似乎也挺清晰的。值得一提的是，<strong>树形背包的复杂度是 $O(nk)$或 $O(n^2)$ 的</strong>，证明看 oiwiki</p>
<pre><code class="cpp">int dfs(int u) &#123;
    if (u &gt;= n - m + 1) &#123;
        f[u][1] = w[u]; // 叶子节点
        return 1;
    &#125;
    int sum = 0;
    for (auto &amp;[v, c]: g[u]) &#123;
        int sz = dfs(v);
        sum += sz; // 更新体积
        for (int j = sum; j &gt;= 0; j--) &#123;
            for (int i = 1; i &lt;= min(j, sz); i++) &#123; // 子树中选 i 个
                if (j - i &gt;= 0) &#123; // 注意这个限制
                    f[u][j] = max(f[u][j], f[u][j - i] + f[v][i] - c);
                &#125;
            &#125;
        &#125;
    &#125;
    return sum;
&#125;
</code></pre>
<h3 id="划分型-DP"><a href="#划分型-DP" class="headerlink" title="划分型 DP"></a>划分型 DP</h3><h4 id="K-个不相交子数组的最大得分"><a href="#K-个不相交子数组的最大得分" class="headerlink" title="K 个不相交子数组的最大得分"></a>K 个不相交子数组的最大得分</h4><blockquote>
<ul>
<li><code>x</code> 个子数组的能量值定义为 <code>strength = sum[1] * x - sum[2] * (x - 1) + sum[3] * (x - 2) - sum[4] * (x - 3) + ... + sum[x] * 1</code> ，其中 <code>sum[i]</code> 是第 <code>i</code> 个子数组的和。更正式的，能量值是满足 <code>1 &lt;= i &lt;= x</code> 的所有 <code>i</code> 对应的 <code>(-1)(i+1)sum[i] * (x - i + 1)</code> 之和。<br>  你需要在 <code>nums</code> 中选择 <code>k</code> 个 <strong>不相交子数组</strong> ，使得 <strong>能量值最大</strong> 。</li>
</ul>
</blockquote>
<p>本题状态定义有些不一样，因为一定要选 <code>k</code> 个，所以定义 <code>f[i][j][0/1]</code> 表示考虑前 <code>i</code> 个数，第 <code>i</code> 个数是否在第 <code>j</code> 段的最大得分（而不是当前有 <code>j</code> 段）</p>
<p>这样定义有什么好处呢，当知道了 <code>a[i]</code> 在第几段后，可以直接求出对于答案的最终贡献！</p>
<p>转移是很简单的：不选，选（1）和前一个数分在一起（2）单独开一段</p>
<h3 id="区间-DP"><a href="#区间-DP" class="headerlink" title="区间 DP"></a>区间 DP</h3><h4 id="翻转子段"><a href="#翻转子段" class="headerlink" title="翻转子段"></a>翻转子段</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1519/problem/D">https://codeforces.com/contest/1519/problem/D</a><br>输入 <code>n(≤5000)</code> 和两个长为 <code>n</code> 的整数数组 <code>a</code> 和 <code>b</code>，元素值均在 <code>[1,1e7]</code> 中。<br>你可以至多反转一次 <code>a</code> 的某个子数组，求 <code>sum(a[i]*b[i])</code> 的最大值（即最大化 <code>a[0]*b[0]+a[1]*b[1]+...+a[n-1]*b[n-1]</code>）。</p>
</blockquote>
<p>用区间 DP 的思路想，设 <code>f[i][j]</code> 表示翻转 <code>[i,j]</code> 的最大和，扩展区间的转移方程很容易得到，考虑端点即可</p>
<p>注意初始化时，由于会用到 <code>f[i+1][i]</code>，因此把这个状态也初始化一下</p>
<pre><code class="cpp">LL s = 0;
    for (int i = 1; i &lt;= n; i++) 
    &#123;
        cin &gt;&gt; b[i];
        s += a[i] * b[i];
    &#125;
    for (int i = 1; i &lt;= n; i++) 
        f[i][i] = f[i + 1][i] = s;
    for (int len = 2; len &lt;= n; len++)
        for (int i = 1; i + len - 1 &lt;= n; i++)
        &#123;
            int j = i + len - 1;
            f[i][j] = f[i + 1][j - 1] - a[i] * b[i] - a[j] * b[j] + a[i] * b[j] + a[j] * b[i];
        &#125;
</code></pre>
<h4 id="砖块涂色"><a href="#砖块涂色" class="headerlink" title="砖块涂色"></a>砖块涂色</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1114/D">https://codeforces.com/problemset/problem/1114/D</a><br>有 <code>n</code> 个砖块排成一排，从左到右编号为 <code>1∼n（n &lt;= 5000）</code>。<br>其中，第 <code>i</code> 个砖块的初始颜色为 <code>ci</code>。<br>我们规定，如果编号范围 <code>[i,j]</code> 内的所有砖块的颜色都相同，且当第 <code>i−1</code> 和 第 <code>j+1</code> 个砖块存在时，这两个砖块的颜色和区间 <code>[i,j]</code> 的颜色均不同, 则砖块 <code>i</code> 和 <code>j</code> 属于同一个连通块。<br>例如，<code>[3,3,3]</code> 有 1 个连通块，<code>[5,2,4,4]</code> 有 3 个连通块。<br>现在，要对砖块进行涂色操作。<br>开始所有操作之前，你需要任选一个砖块作为<strong>起始砖块</strong>。<br>每次操作：</p>
<ol>
<li>任选一种颜色</li>
<li>将最开始选定的<strong>起始砖块</strong>所在连通块中包含的所有砖块都涂为选定颜色<br> 请问，至少需要多少次操作，才能使所有砖块都具有同一种颜色。</li>
</ol>
</blockquote>
<p>定义 <code>f[i][j][0/1]</code> 表示染 <code>[i,j]</code> 这个区间，最后颜色等于 <code>a[i]</code> 还是 <code>a[j]</code> 的步数</p>
<p>转移的时候考虑 <code>f[i+1][j]</code> 和 <code>f[i][j-1]</code> 即可，难点在于想到<strong>最后一步染的颜色必定是等于端点的颜色</strong></p>
<pre><code class="cpp">memset(f, 0x3f, sizeof f);
    for (int i = 1; i &lt;= n; i++) 
    &#123;
        f[i][i][0] = f[i][i][1] = 0;
        f[i + 1][i][0] = f[i + 1][i][1] = 0;
    &#125;
    for (int len = 2; len &lt;= n; len++)
        for (int i = 1; i + len - 1 &lt;= n; i++)
        &#123;
            int j = i + len - 1;
            for (int k = 0; k &lt;= 1; k++)
            &#123;
                int t = k ? a[j] : a[i + 1];
                f[i][j][0] = min(f[i][j][0], f[i + 1][j][k] + (a[i] != t));
                t = k ? a[j - 1] : a[i];
                f[i][j][1] = min(f[i][j][1], f[i][j - 1][k] + (a[j] != t));
            &#125;
        &#125;
    cout &lt;&lt; min(f[1][n][0], f[1][n][1]) &lt;&lt; endl;
</code></pre>
<h4 id="环形数组的区间-DP"><a href="#环形数组的区间-DP" class="headerlink" title="环形数组的区间 DP"></a>环形数组的区间 DP</h4><blockquote>
<p>每颗珠子有头尾标记（前一个的尾标记等于后一个的头标记），合并代价为 <code>m*r*n</code>，假设珠子为 <code>(m,r)(r,n)</code>，合并后变为 <code>(m,n)</code>。问环形珠子串合并的最大代价</p>
</blockquote>
<p>以往的区间 dp 我们把区间 <code>[a,b]</code> 分为 <code>[a,k],[k+1,b]</code>，但本题分割点 <code>k</code> 要作为两个区间的共同端点使用，因此是 <code>[a,k],[k,b]</code>。<br>此外，本题枚举的区间长度为 <code>n+1</code>，在处理上每次读入一个 <code>a[i]</code>，我们令 <code>a[i+n]=a[i]</code>；枚举时，窗口从 <code>1</code> 移到 <code>n*2</code> 的位置。注意，<code>len=2</code> 的时候只有一个球， 即 <code>len=k</code> 时只有 <code>k-1</code> 个球。<br>转移方程为 <code>f[i][j] = max(f[i][j], f[i][k] + f[k][j] + a[i] * a[k] * a[j])</code>。</p>
<pre><code class="cpp">for (int len = 3; len &lt;= n + 1; len ++)
        for (int i = 1; i + len - 1 &lt;= n * 2; i++)
        &#123;
            int j = i + len - 1;
            for (int k = i + 1; k &lt; j; k++)
                f[i][j] = max(f[i][j], f[i][k] + f[k][j] + a[i] * a[k] * a[j]);
        &#125;
    
    int res = 0;
    for (int i = 1; i &lt;= n; i++) res = max(res, f[i][i + n]);
</code></pre>
<h4 id="注意枚举顺序"><a href="#注意枚举顺序" class="headerlink" title="注意枚举顺序"></a>注意枚举顺序</h4><blockquote>
<p>你有一个凸的 <code>n</code> 边形，其每个顶点都有一个整数值。给定一个整数数组 <code>values</code> ，其中 <code>values[i]</code> 是第 <code>i</code> 个顶点的值（即 <strong>顺时针顺序</strong> ）。<br>假设将多边形 <strong>剖分</strong> 为 <code>n - 2</code> 个三角形。对于每个三角形，该三角形的值是顶点标记的<strong>乘积</strong>，三角剖分的分数是进行三角剖分后所有 <code>n - 2</code> 个三角形的值之和。<br>返回 <em>多边形进行三角剖分后可以得到的最低分</em> 。</p>
</blockquote>
<p>本题考虑枚举 <code>i</code> <code>j</code> 的做法：<code>f[i][j] = f[i][k] + f[k][j] = v[i]*v[j]*v[k]</code>，其中 k ∈ <code>[i+1,j-1]</code></p>
<ul>
<li>由于 <code>i</code> 小于 <code>k</code>，因此倒序枚举 <code>i</code></li>
<li>由于 <code>j</code> 大于 <code>k</code>，因此正序枚举 <code>j</code></li>
</ul>
<pre><code class="cpp">class Solution &#123;
public:
    int minScoreTriangulation(vector&lt;int&gt;&amp; values) &#123;
        int n = values.size();
        int f[n][n];
        memset(f, 0, sizeof f);
        for (int l = n - 3; l &gt;= 0; l--)
            for (int r = l + 2; r &lt; n; r++)
            &#123;
                f[l][r] = INT_MAX;
                for (int k = l + 1; k &lt; r; k++)
                    f[l][r] = min(f[l][r], f[l][k] + f[k][r] + values[l] * values[k] * values[r]);
            &#125;
        return f[0][n - 1];
    &#125;
&#125;;
</code></pre>
<h4 id="统计不同的回文子序列"><a href="#统计不同的回文子序列" class="headerlink" title="统计不同的回文子序列"></a>统计不同的回文子序列</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-different-palindromic-subsequences/">730. 统计不同回文子序列</a><br>返回不同的非空回文子序列个数，<code>n</code> 是 <code>1000</code></p>
</blockquote>
<p>怎么去重？定义 <code>f[i][j]</code> 表示区间 <code>[i,j]</code> 的不同回文子序列数，如果 <code>s[i]=s[j]=x</code>，那么 <code>f[i][j]</code> <strong>增加了</strong> <code>f[i-1][j+1]</code> 中的方案两端拼 <code>xx</code> + 单独的 <code>xx</code> + 单独的 <code>x</code>。去重的时候考虑<strong>枚举端点字符 x</strong>，寻找 <code>[i+1,j-1]</code> 中有没有出现一段区间 <code>[l,r]</code>，其中 <code>s[l]=s[r]=x</code>，有的话只需要减去 <code>f[l+1][r-1]</code> 即可。这个可以通过预处理 <code>nxt</code> 和 <code>pre</code> 数组得到。特别考虑如果 <code>l==r</code> 时怎么处理（单独的 <code>x</code> 不能算进去），以及 <code>s[i] != s[j]</code> 时，根据状态定义可以用容斥原理解决（<code>f[i+1][j]+f[i][j-1]-f[i+1][j-1]</code>）</p>
<pre><code class="go">for sz := 2; sz &lt;= n; sz++ &#123;
        for i := 0; i + sz - 1 &lt; n; i++ &#123;
            j := i + sz - 1
            if s[i] == s[j] &#123;
                low, high := nxt[i][s[i] - &#39;a&#39;], pre[j][s[i] - &#39;a&#39;]
                if low &gt; high &#123;
                    f[i][j] = (f[i + 1][j - 1] * 2 + 2) % MOD
                &#125; else if low == high &#123;
                    f[i][j] = (f[i + 1][j - 1] * 2 + 1) % MOD
                &#125; else &#123;
                    f[i][j] = (f[i + 1][j - 1] * 2 - f[low + 1][high - 1] + MOD) % MOD
                &#125;
            &#125; else &#123;
                f[i][j] = (f[i + 1][j] + f[i][j - 1] - f[i + 1][j - 1] + MOD) % MOD
            &#125;
        &#125;
    &#125;
</code></pre>
<h3 id="背包-DP"><a href="#背包-DP" class="headerlink" title="背包 DP"></a>背包 DP</h3><h4 id="01-背包求方案数"><a href="#01-背包求方案数" class="headerlink" title="01 背包求方案数"></a>01 背包求方案数</h4><blockquote>
<p>每件物品用一次，求最优选法的方案数</p>
</blockquote>
<p>维护 <code>f[i][j]</code> 表示前 <code>i</code> 个物品中选体积<strong>不超过</strong> <code>j</code> 的最大价值和，同时维护 <code>g[i][j]</code> 表示对应最大价值和时的方案数。初始化时，<code>g[i]</code> 都置成 <code>1</code>，一开始时最大价值为 <code>0</code>，对应什么都不选，是一种方案</p>
<pre><code class="cpp">for (int i = 0; i &lt;= m; i++) g[i] = 1;
    for (int i = 1; i &lt;= n; i++) &#123;
        cin &gt;&gt; v &gt;&gt; w;
        for (int j = m; j &gt;= v; j--) &#123;
            if (f[j] &lt; f[j - v] + w) &#123;
                f[j] = f[j - v] + w;
                g[j] = g[j - v];
            &#125; else if (f[j] == f[j - v] + w) &#123;
                g[j] = (g[j] + g[j - v]) % MOD;
            &#125;
        &#125;
    &#125;
    cout &lt;&lt; g[m] &lt;&lt; endl;
</code></pre>
<h4 id="可撤销多重背包方案数"><a href="#可撤销多重背包方案数" class="headerlink" title="可撤销多重背包方案数"></a>可撤销多重背包方案数</h4><p>参考 <a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/YnZBve/">https://leetcode.cn/circle/discuss/YnZBve/</a></p>
<blockquote>
<p><code>N</code> 种物品，第 <code>i</code> 种有 <code>c[i]</code> 个，重量为 <code>v[i]</code>。求对于 <code>j=1,2,...,M</code>，求背包重量为 <code>j</code> 时的方案数</p>
</blockquote>
<p>朴素计算是 $O(nm^2)$ 的，注意到 <code>f[i][j]</code> 只会由满足 <code>j</code> 与 <code>k</code> 模 <code>v[i]</code> 同余的状态转移过来，而且是某段区间的和，故可以用前缀和优化到 $O(nm)$</p>
<pre><code class="cpp">//dp : a array of zeros longer than M
dp[0] = 1;
for(int i = 1; i &lt;= N; i += 1)&#123;
    for(int j = v[i]; j &lt;= M; j += 1) dp[j] += dp[j - v[i]]; //prefix sum
    for(int j = M; j &gt;= (c[i] + 1) * v[i]; j -= 1) dp[j] -= dp[j - (c[i] + 1) * v[i]];
&#125;
</code></pre>
<blockquote>
<p>加强版：设 <code>f[i][j]</code> 表示不使用第 <code>i</code> 种物品时，总重量为 <code>j</code> 的方案数</p>
</blockquote>
<p>在上面得到 <code>i=N</code> 时的 dp 数组时，可以将操作反向，重新得到 <code>i=N-1</code> 时的 dp 数组</p>
<pre><code class="cpp">//tmp: another array longer than M
for(int i = 1; i &lt;= N; i += 1)&#123;
    for(int j = 0; j &lt;= M; j += 1) tmp[j] = dp[j];
    for(int j = (c[i] + 1) * v[i]; j &lt;= M; j += 1) tmp[j] += tmp[j - (c[i] + 1) * v[i]];
    for(int j = M; j &gt;= v[i]; j -= 1) tmp[j] -= tmp[j - v[i]];
    //now, tmp[j] is f(i, j)
&#125;
</code></pre>
<h4 id="多重背包求最值"><a href="#多重背包求最值" class="headerlink" title="多重背包求最值"></a>多重背包求最值</h4><p>朴素版是三重循环<br>II<br>怎么把多重背包问题变成一个 01 背包问题？朴素想法是拆分，一个一个拆，但这样会超时。<br>使用二进制枚举优化，比如说一个数$s$，最少用几个数（选或不选两种情况）就可以表示出来$s$内的所有数呢？答案是$\lceil{log_2n}\rceil$，分成$2^0$，$2^1$这样的数，核心代码看模板</p>
<pre><code class="cpp">int f[M];
int w[N], v[N];
int n, m;

int main()
&#123;
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    int cnt = 0;
    for (int i = 1; i &lt;= n; i++)
    &#123;
        int a, b, s;
        scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;s);
        int k = 1;
        while (k &lt;= s)
        &#123;
            cnt ++;
            v[cnt] = a * k;
            w[cnt] = b * k;
            s -= k;
            k *= 2;
        &#125;
        if (s &gt; 0)
        &#123;
            cnt ++;
            v[cnt] = a * s;
            w[cnt] = b * s;
        &#125;
    &#125;
    
    for (int i = 1; i &lt;= cnt; i++)
        for (int j = m; j &gt;= v[i]; j--)
            f[j] = max(f[j], f[j - v[i]] + w[i]);
    
    printf(&quot;%d\n&quot;, f[m]);
    return 0;
&#125;
</code></pre>
<p>III<br>数据范围比较大时需要使用单调队列优化。<br>核心思路是把 <code>f[m]</code> 分成若干类，按什么分呢？比如当前要枚举的物品的体积是$v$，那么按$m % v$即余数来分类（划分等价类），因为$m&#x3D;k*v+j$。因为这一类最多有$s$个物品，所以滑动窗口的大小为$s$。<br><code>(k - q[hh]) / v * w</code>：由于 <code>q[hh]</code> 存的是 <code>j - sv</code>，而这里用 <code>k</code> 表示体积那么一共有 <code>(k - q[hh]) / v</code> 个此物品，他的价值为 <code>(k - q[hh]) / v * w</code>。（这句话暂时看不懂）<br>难点在于不理解单调队列里存的元素是什么含义，首先它是体积，但具体的变化过程还不清晰</p>
<p>复制一些别人的题解：</p>
<pre><code class="cpp">所以，我们可以得到
dp[j]    =     dp[j]
dp[j+v]  = max(dp[j] +  w,  dp[j+v])
dp[j+2v] = max(dp[j] + 2w,  dp[j+v] +  w, dp[j+2v])
dp[j+3v] = max(dp[j] + 3w,  dp[j+v] + 2w, dp[j+2v] + w, dp[j+3v])
...
但是，这个队列中前面的数，每次都会增加一个 w ，所以我们需要做一些转换
dp[j]    =     dp[j]
dp[j+v]  = max(dp[j], dp[j+v] - w) + w
dp[j+2v] = max(dp[j], dp[j+v] - w, dp[j+2v] - 2w) + 2w
dp[j+3v] = max(dp[j], dp[j+v] - w, dp[j+2v] - 2w, dp[j+3v] - 3w) + 3w
...
这样，每次入队的值是 dp[j+k*v] - k*w
</code></pre>
<p>带注释的代码：</p>
<pre><code class="cpp">const int N = 1010, M = 20010;

int q[M];  // s的最大值为20000，v的最小值为1，所以队列里面最多是会有200010个元素的
int n, m;
int f[N][M];

int main()&#123;
    cin &gt;&gt; n &gt;&gt; m;

    for (int i = 1; i &lt;= n; ++ i) &#123;
        int v, w, s;
        cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;
        for (int j = 0; j &lt; v; ++ j) &#123;
            int hh = 0, tt = -1;
            for (int k = j; k &lt;= m; k += v) &#123;
                if (hh &lt;= tt &amp;&amp; q[hh] &lt; k - s * v) hh ++;  // 判断单调队列中的最大元素是否已经滑出窗口
                f[i][k] = f[i - 1][k];  // 不放物品i
                if (hh &lt;= tt) f[i][k] = max(f[i][k], f[i - 1][q[hh]] + (k - q[hh]) / v * w);  // 放物品i
                while (hh &lt;= tt &amp;&amp; f[i - 1][q[tt]] + (k - q[tt]) / v * w &lt;= f[i - 1][k]) tt --;  // 更新单调的队列
                q[++ tt] = k;  // 更新单调的队列 进队的是 j + x * v
            &#125;
        &#125;
    &#125;

    cout &lt;&lt; f[n][m] &lt;&lt; endl;

    return 0;
&#125;
</code></pre>
<p>优化为一维：</p>
<pre><code class="cpp">const int N = 1010, M = 20010;

int n, m;
int v[N], w[N], s[N];
int f[2][M];
int q[M];

int main()
&#123;
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 1; i &lt;= n; ++ i) cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];
    for (int i = 1; i &lt;= n; ++ i)
    &#123;
        for (int r = 0; r &lt; v[i]; ++ r)
        &#123;
            int hh = 0, tt = -1;
            for (int j = r; j &lt;= m; j += v[i])
            &#123;
                while (hh &lt;= tt &amp;&amp; j - q[hh] &gt; s[i] * v[i]) hh ++ ;
                while (hh &lt;= tt &amp;&amp; f[(i - 1) &amp; 1][q[tt]] + (j - q[tt]) / v[i] * w[i] &lt;= f[(i - 1) &amp; 1][j]) -- tt;
                q[ ++ tt] = j;
                f[i &amp; 1][j] = f[(i - 1) &amp; 1][q[hh]] + (j - q[hh]) / v[i] * w[i];
            &#125;
        &#125;
    &#125;
    cout &lt;&lt; f[n &amp; 1][m] &lt;&lt; endl;
    return 0;
&#125;
</code></pre>
<h4 id="砝码称重"><a href="#砝码称重" class="headerlink" title="砝码称重"></a>砝码称重</h4><blockquote>
<p><code>N</code> 个砝码，一个天平，一共能称出几个不同正整数？</p>
</blockquote>
<p>背包 dp 问题，<code>f[i][j]</code> 表示从前 <code>i</code> 个选，重量为 <code>j</code> 是否可行。状态计算：不选 <code>f[i-1][j]</code>，选放左边 <code>f[i-1][abs(j-w)]</code>，放右边 <code>f[i-1][j+w]</code>，三者取或。</p>
<pre><code class="cpp">f[0][0] = 1;
    for (int i = 1; i &lt;= n; i++)
        for (int j = 0; j &lt;= sum; j++)
        &#123;
            f[i][j] = f[i - 1][j];
            if (w[i] == j) f[i][j] = 1;
            if (f[i - 1][j + w[i]]) f[i][j] = 1;
            else if (f[i - 1][abs(j - w[i])]) f[i][j] = 1;
        &#125;
</code></pre>
<h4 id="转化为背包-分治"><a href="#转化为背包-分治" class="headerlink" title="转化为背包 + 分治"></a>转化为背包 + 分治</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/contest/tianchi2022/problems/tRZfIV/">意外惊喜</a><br>某电商平台举办了一个用户抽奖活动，奖池中共有若干个礼包，每个礼包中包含一些礼物。 <code>present[i][j]</code> 表示第 <code>i</code> 个礼包第 <code>j</code> 件礼（<strong>下标从 0 开始</strong>）物的价值。抽奖规则如下：</p>
<ul>
<li>每个礼包中的礼物摆放是有顺序的，你必须从第 <code>0</code> 件礼物开始打开；</li>
<li>对于同一个礼包中的礼物，必须在打开该礼包的第 <code>i</code> 个礼物之后，才能打开第 <code>i+1</code> 个礼物；</li>
<li>每个礼物包中的礼物价值 <strong>非严格递增</strong>。<br>参加活动的用户总共可以打开礼物 <code>limit</code> 次，请返回用户能够获得的 <strong>最大</strong> 礼物价值总和。</li>
</ul>
</blockquote>
<p>注意到有一个结论：不可能出现有两个数组都选了一部分的情况，一定是要么都选完，要么一个选完另外一个不选。<strong>枚举这个没有选完的数组，其余的转化为 0-1 背包</strong> 。<br>但这样做时间复杂度为$O(n\times limit \times n)$（0-1 背包 * 枚举每个物品），需要优化。（难点在于怎么优化掉重复计算的背包，因为取 max 值无法撤销，但是我们需要从把礼包当成整体 -&gt; 枚举前缀 -&gt; 恢复为整体，这里包含了撤销的思想）<br><strong>使用分治优化</strong> ，递归计算 0-1 背包。（如果只剩一个，就枚举前缀，然后当其它礼包都是已经计算好的 0-1 背包；否则，分成两半，先算左侧的背包，带着计算好的结果递归右侧；还原，计算右侧，再递归左侧）<br>时间复杂度分析，基于归并排序的基础上，多了一个$O(limit)$的循环，base case 复杂度单独算，总共为$O(limit\times log(n) + sum(len(a))\ for\ a\ in\ present)$</p>
<pre><code class="cpp">int f[12][1050]; // 用 id 记录递归树每一层的结果 最多不超过 log_2(2000)
int sz[2005], val[2005];

class Solution &#123;
public:
    int n;
    
    int find(vector&lt;vector&lt;int&gt;&gt;&amp; present, int limit, int id, int L, int R)
    &#123;
        int re = 0;
        if (L == R)
        &#123;
            int s = 0, v = 0;
            re = f[id][limit];
            for (auto&amp; x: present[L])
            &#123;
                // 背包
                s ++;
                v += x;
                if (s &gt; limit) break;
                re = max(re, f[id][limit - s] + v);
            &#125;
            return re;
        &#125;
        
        // 分治
        int mid = (L + R) / 2;
        
        for (int i = 0; i &lt;= limit; i++)
            f[id + 1][i] = f[id][i];
        
        for (int k = L; k &lt;= mid; k++)
            for (int i = limit; i &gt;= sz[k]; i--)
                f[id + 1][i] = max(f[id + 1][i], f[id + 1][i - sz[k]] + val[k]);
        re = max(re, find(present, limit, id + 1, mid + 1, R));
        
        for (int i = 0; i &lt;= limit; i++)
            f[id + 1][i] = f[id][i];
        
        for (int k = mid + 1; k &lt;= R; k++)
            for (int i = limit; i &gt;= sz[k]; i--)
                f[id + 1][i] = max(f[id + 1][i], f[id + 1][i - sz[k]] + val[k]);
        re = max(re, find(present, limit, id + 1, L, mid));
        
        return re;
    &#125;

    int brilliantSurprise(vector&lt;vector&lt;int&gt;&gt;&amp; present, int limit) &#123;
        for (int i = 0; i &lt;= limit; i++) f[0][i] = 0;
        n = present.size();
        
        for (int i = 0; i &lt; n; i++)
        &#123;
            val[i] = 0;
            sz[i] = present[i].size(); // 存 size
            for (int j = 0; j &lt; sz[i]; j++)
                val[i] += present[i][j]; // 存 sum
        &#125;
        
        return find(present, limit, 0, 0, n - 1);
    &#125;
&#125;;
</code></pre>
<h4 id="异或和也能转化为背包？！"><a href="#异或和也能转化为背包？！" class="headerlink" title="异或和也能转化为背包？！"></a>异或和也能转化为背包？！</h4><blockquote>
<p>给你一个长为 <code>n</code> 的数组 <code>a</code>，输出它的所有非空子序列的元素和的异或和</p>
</blockquote>
<p>这原来是个背包问题啊</p>
<ul>
<li><code>f[i][j]</code> 表示前 <code>i</code> 个数选出元素和为 <code>j</code> 的方案数的奇偶性</li>
<li><code>f[0][0]=1</code> <code>f[i+1][j]=f[i][j]^f[i][j-a[i]]</code></li>
<li>答案为 <code>f[n][j]=1</code> 的 <code>j</code> 的异或和</li>
</ul>
<pre><code class="cpp">int main()
&#123;
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;a[i]);
    f[0] = 1;
    for (int i = 0; i &lt; n; i++)
        for (int j = 1 &lt;&lt; 16; j &gt;= a[i]; j--)
            f[j] ^= f[j - a[i]];
    int res = 0;
    for (int i = 0; i &lt; 1 &lt;&lt; 16; i++)
        if (f[i] == 1) res ^= i;
    printf(&quot;%d\n&quot;, res);
    return 0;
&#125;
</code></pre>
<h4 id="背包问题的翻译"><a href="#背包问题的翻译" class="headerlink" title="背包问题的翻译"></a>背包问题的翻译</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/543/A">Problem - 543A - Codeforces</a><br>有 <code>n</code> 个程序员，每个程序员都可以写任意行代码，总共要编写 <code>m</code> 行代码，这 <code>m</code> 行代码可以由多个程序员来编写。但是第 <code>i</code> 个程序员在一行代码中会出现 <code>a[i]</code> 个 bug。现在希望知道有多少种方案能使得这 <code>m</code> 行代码中的 bug 的数量不超过 <code>b</code> 个。</p>
</blockquote>
<p>现在有一个体积为 <code>b</code> 的背包，有 <code>n</code> 个物品，第 <code>i</code> 个物品的体积为 <code>a[i]</code>，个数有无限个。要求在这 <code>n</code> 个物品中取恰好 <code>m</code> 个物品，且背包能装下的方案有多少种，答案模上 <code>p</code>。</p>
<p>二维费用背包 + 完全背包求方案数</p>
<pre><code class="cpp">f[0][0] = 1;
    for (int i = 1; i &lt;= n; i++)
        for (int j = 1; j &lt;= m; j++)
            for (int k = a[i]; k &lt;= b; k++)
                f[j][k] = (f[j][k] + f[j - 1][k - a[i]]) % p;
    int res = 0;
    for (int i = 0; i &lt;= b; i++) res = (res + f[m][i]) % p;
</code></pre>
<h4 id="01-背包变形题"><a href="#01-背包变形题" class="headerlink" title="01 背包变形题"></a>01 背包变形题</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2340">https://www.luogu.com.cn/problem/P2340</a><br>选 <code>n</code> 个人，使得情商和及智商和都是非负数，输出最大的二者总和</p>
</blockquote>
<p>自己想的时候没有想到转化为背包问题，怎么分析呢？关键在于每个人只有<strong>选或不选</strong>两种状态，据此考虑背包。首先背包容量肯定是 n，因为是 n 个人。其次，体积和价值怎么定？</p>
<p>把智商看成体积，情商看成价值。转化为 <code>f[i][j]</code> 表示前 i 个人，智商和为 j 时情商和的最大值</p>
<p>两个问题</p>
<ul>
<li>转移的时候，智商值可能为负数，会影响枚举顺序：故特判</li>
<li>下标为负，可能越界：加偏移量</li>
</ul>
<pre><code class="cpp">memset(dp, -0x3f, sizeof dp);
        dp[400000] = 0;
        for(int i = 1; i &lt;= n; i ++)
        &#123;
            if(a[i].iq &gt;= 0)
                for(int j = 800000; j &gt;= a[i].iq; j --)
                    dp[j] = max(dp[j], dp[j-a[i].iq] + a[i].eq);
            else
                for(int j = 0; j &lt;= 800000 + a[i].iq; j ++)
                    dp[j] = max(dp[j], dp[j-a[i].iq] + a[i].eq);
        &#125;
        for(int i = 400000; i &lt;= 800000; i ++)
            if(dp[i] &gt; 0)
                ans = max(ans, i + dp[i] - 400000);
</code></pre>
<h4 id="背包-容斥"><a href="#背包-容斥" class="headerlink" title="背包 + 容斥"></a>背包 + 容斥</h4><blockquote>
<p>洛谷 <strong>P1450 [HAOI2008] 硬币购物</strong><br>有 <code>4</code> 种硬币，给出 <code>n</code> 次购物，每次给 <code>d[i]</code> 个 <code>i</code> 种硬币，问凑 <code>s</code> 元方案数<br><code>s,c[i],d[i]</code> 都是 <code>1e5</code>，<code>n</code> 为 <code>1000</code></p>
</blockquote>
<p>这题不能每次询问都做一次完全背包，那怎么办呢？能不能先做一次不带限制的完全背包，然后…</p>
<p>假如只有一种硬币有限制，凑 <code>s</code> 元的方案就包含了 <code>d[i]+1, d[i]+2, ...</code> 种 <code>i</code> 硬币的，把它们减去就好了，这就是一个容斥原理！先选定 <code>(d+1)*v</code> 的体积，剩下 <code>s-(d+1)*v</code> 的背包没有任何限制，太妙了</p>
<pre><code class="cpp">while (T -- ) &#123;
        for (int i = 0; i &lt; 4; i++) &#123;
            cin &gt;&gt; d[i];
        &#125;
        cin &gt;&gt; s;
        LL res = f[s];
        for (int i = 1; i &lt; 1 &lt;&lt; 4; i++) &#123;
            LL t = s;
            for (int j = 0; j &lt; 4; j++) &#123;
                if (i &gt;&gt; j &amp; 1) &#123;
                    t -= c[j] * (d[j] + 1);
                &#125;
            &#125;
            if (t &lt; 0) &#123;
                continue;
            &#125;
            if (__builtin_popcount(i) % 2) &#123;
                res -= f[t];
            &#125; else &#123;
                res += f[t];
            &#125;
        &#125;
        cout &lt;&lt; res &lt;&lt; endl;
    &#125;
</code></pre>
<h4 id="石子合并也能是背包"><a href="#石子合并也能是背包" class="headerlink" title="石子合并也能是背包"></a>石子合并也能是背包</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/last-stone-weight-ii/">1049. 最后一块石头的重量 II</a><br>每次选两块石头 <code>x</code> 和 <code>y</code>，若 <code>x==y</code>，则粉碎，否则，剩下一个 <code>abs(x-y)</code> 的石头，问最后剩下的最小重量</p>
</blockquote>
<p>本质是给数组的数字添加正负号，求最后结果的最小值（可以手玩一下样例来观察出这个性质）。进而转化为求不超过 <code>sum/2</code> 的最大体积，就是经典背包问题</p>
<h3 id="数据结构优化-DP"><a href="#数据结构优化-DP" class="headerlink" title="数据结构优化 DP"></a>数据结构优化 DP</h3><h4 id="最大上升子序和"><a href="#最大上升子序和" class="headerlink" title="最大上升子序和"></a>最大上升子序和</h4><blockquote>
<p>选出数组的一个严格上升子序列，使得子序列和最大，问最大和是多少</p>
</blockquote>
<p>最长上升子序列问题，分析思路是基于 dp 的，思考状态定义：<code>f[i]</code> 表示所有由前 <code>i</code> 个数构成且最后一个元素是 <code>i</code> 的严格上升子序列的集合。怎么划分？可以以倒数第二个数是谁来分类（无，<code>a[1]</code>，…，<code>a[i-1]</code>），有些集合可能不存在。状态计算就是 <code>max(f[k])+a[i]</code>。<br>如何优化？在 <code>i</code> 前找到比它小的数且让 <code>f[k]</code> 最大，这种操作可以用数据结构优化，求前缀最大和用树状数组，求任意区间最大值用线段树。每个 <code>a[i]</code> 都在 <code>1e9</code> 的范围，我们要进行离散化，找出 <code>j &lt; i</code> 且 <code>a[j] &lt; a[i]</code> 中 <code>f[j]</code> 的最大值，相当于以 <code>a[i]</code> 这个数，映射到一个树状数组的下标，存的值就是对应的 <code>f[i]</code>。</p>
<pre><code class="cpp">// 离散化+前缀最大值的树状数组
    for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;w[i]);
    memcpy(q, w, sizeof w);
    sort(q, q + n);
    m = unique(q, q + n) - q;
    
    LL res = 0;
    for (int i = 0; i &lt; n; i++)
    &#123;
        int x = lower_bound(q, q + m, w[i]) - q + 1;
        LL sum = query(x - 1) + w[i];
        res = max(res, sum);
        add(x, sum);
    &#125;
</code></pre>
<h4 id="裁剪序列"><a href="#裁剪序列" class="headerlink" title="裁剪序列"></a>裁剪序列</h4><blockquote>
<p>给定一个长度为 <code>N</code> 的序列 <code>A</code>，要求把该序列分成若干段，在满足“每段中所有数的和”不超过 <code>M</code> 的前提下，让“每段中所有数的最大值”之和最小。<br>试计算这个最小值。</p>
</blockquote>
<p>把数组分成若干段，每段的和不超过$M$，并让每段中最大值之和最小。<br>考虑 dp 怎么来分析：状态定义很好确定，状态计算要划分集合，一般找最后一个不同点，我们可以看最后一段，按最后一段的长度来分类。<br>拿出一个子集，假如最后一段的长度为$k$，那么前$i-k$个数怎么划分是随意的，那么 <code>f[i]=f[i-k]+max</code>。<br>考虑优化：先求出$k$的最大值，即最后一段起点的最小值$j$，有如下结论：（1）对于 <code>[1...i]</code> 的划分方案，<code>[1...j]</code> 的划分方案，当 <code>i&lt;j</code>，有后者大于等于前者（前者的方案都能在后者中找到），即元素越多代价越大。（2）有可能作为答案的点一定是在 <code>[j...i]</code> 内，我们找到一个单调递减 <code>a[k]</code> 序列，这个序列中的每一个点（确定一个$a_{max}$后，我们一定要选最小起点）。<br>如何维护这个单调递减的序列？首先我们需要对每个下标$i$都维护一个最小的$j$，使得 <code>sum[j...i]&lt;=M</code>，这是一个双指针问题，但要先证明随着尾指针后移，头指针也一定后移（由每个数都非负得证）。接下来我们要在这个滑动窗口中维护一个单点递减的序列，这是经典单调队列维护问题。 然后再考虑我们区间右移的时候，要么从队头一个个删，要么从队尾一个个删，每个元素最多入队一次出队一次，因此我们需要维护一个集合，支持动态求最小值，删除一个数，插入一个数，可以用平衡树（<code>multiset</code>）实现。<br>代码实现上，可以先写好双指针逻辑，再插入单调队列的逻辑，最后写 multiset 的逻辑（由于$j$是最后一段的起点，因此 dp 公式是 <code>f[i] = f[j - 1] + w[q[hh]];</code>）：</p>
<pre><code class="cpp">multiset&lt;LL&gt; s; // 单调队列有 k 个数时 维护的是 k - 1 个区间 （如 f[k] + ak+1）
// ...
void remove(LL x)
&#123;
    auto it = s.find(x);
    s.erase(it); // 如果有多个取值 只删除一个
    // 直接调用 s.erase(x) 会把所有都删除
&#125;

for (int i = 1, j = 1; i &lt;= n; i++) // 双指针维护对确定的 i，j 的范围
&#123;
    sum += w[i];
    while (sum &gt; m) 
    &#123;
        sum -= w[j++];
        if (hh &lt;= tt &amp;&amp; q[hh] &lt; j) // 维护单调队列的左端
        &#123;
            if (hh &lt; tt) remove(f[q[hh]] + w[q[hh + 1]]); // 单调队列中大于一个元素时才删除
            hh++;
        &#125;
    &#125;

    while (hh &lt;= tt &amp;&amp; w[i] &gt;= w[q[tt]]) // 维护单调队列的右端
    &#123;
        if (hh &lt; tt) remove(f[q[tt - 1]] + w[q[tt]]);
        tt--;
    &#125;

    q[++tt] = i; // 入队
    if (hh &lt; tt) s.insert(f[q[tt - 1]] + w[q[tt]]); // 起码 2 个元素时 更新这一段区间的值
    f[i] = f[j - 1] + w[q[hh]]; // 由 dp 公式

    if (s.size()) f[i] = min(f[i], *s.begin());
&#125;
</code></pre>
<h4 id="前缀和或滑窗-优化多重背包"><a href="#前缀和或滑窗-优化多重背包" class="headerlink" title="前缀和或滑窗 优化多重背包"></a>前缀和或滑窗 优化多重背包</h4><blockquote>
<p>给你一个下标从 <strong>0</strong> 开始的非负整数数组 <code>nums</code> 和两个整数 <code>l</code> 和 <code>r</code> 。<br>请你返回 <code>nums</code> 中子多重集合的和在闭区间 <code>[l, r]</code> 之间的 <strong>子多重集合的数目</strong> 。<br>由于答案可能很大，请你将答案对 <code>10^(9)+7</code> 取余后返回。<br><strong>子多重集合</strong> 指的是从数组中选出一些元素构成的 <strong>无序</strong> 集合，每个元素 <code>x</code> 出现的次数可以是 <code>0, 1, ..., occ[x]</code> 次，其中 <code>occ[x]</code> 是元素 <code>x</code> 在数组中的出现次数。<br><strong>注意：</strong></p>
<ul>
<li>如果两个子多重集合中的元素排序后一模一样，那么它们两个是相同的 <strong>子多重集合</strong> 。</li>
<li><strong>空</strong> 集合的和是 <code>0</code> 。</li>
<li><code>nums</code> 的和不超过 <code>2 * 10^(4)</code> 。</li>
</ul>
</blockquote>
<p>题意即给定 <code>k</code> 种物品，个数有限，放进容积为 <code>r</code> 的背包的方案数。本题的 <code>k</code> 是$sqrt(sum)$级别，可以使用$O(kr)$的算法过</p>
<pre><code class="cpp">// 前缀和优化
class Solution &#123;
public:
    const int MOD = 1e9 + 7;
    int countSubMultisets(vector&lt;int&gt;&amp; nums, int l, int r) &#123;
        int n = nums.size();
        vector&lt;int&gt; f(r + 1);
        unordered_map&lt;int, int&gt; cnt;
        for (int x: nums) cnt[x] ++;
        f[0] = 1;
        for (auto &amp;[x, y]: cnt)
        &#123;
            if (x == 0) continue;
            for (int j = x; j &lt;= r; j++)
                f[j] = (f[j] + f[j - x]) % MOD;
            for (int j = r; j &gt;= (y + 1) * x; j--)
                f[j] = (f[j] - f[j - (y + 1) * x]) % MOD;
        &#125;

        int res = 0;
        for (int i = l; i &lt;= r; i++) res = (res + f[i]) % MOD;
        res = (res * (1LL * (cnt[0] + 1))) % MOD;
        return (res + MOD) % MOD;
    &#125;
&#125;;
</code></pre>
<p>核心：</p>
<ul>
<li>对 <code>0</code> 做特判，体现在最后</li>
<li><code>f[i][j]</code> 和 <code>f[i][j-v]</code> 的转移方程对比，少了一个 <code>f[i-1][j-v*(c+1)]</code> ，多了一个 <code>f[i-1][j]</code> ，这启示我们可以用滑窗或者前缀和来维护这一段区间和，就可以 <code>O(1)</code> 转移了</li>
</ul>
<pre><code class="cpp">// 滑窗版本，需要按取模的余数分类
class Solution &#123;
public:
    const int MOD = 1e9 + 7;
    int countSubMultisets(vector&lt;int&gt;&amp; nums, int l, int r) &#123;
        int n = nums.size();
        unordered_map&lt;int, int&gt; cnt;
        int mx = 0;
        for (int x: nums) cnt[x] ++, mx = max(mx, x);
        int f[(int)cnt.size() + 1][r + 1], g[mx + 1];
        memset(f, 0, sizeof f);
        memset(g, 0, sizeof g);
        f[0][0] = 1;
        int i = 0;
        for (auto &amp;[x, y]: cnt)
        &#123;
            if (x == 0) continue;
            i ++;
            for (int j = 0; j &lt;= mx; j++) g[j] = 0;
            for (int j = 0; j &lt;= r; j++)
            &#123;
                int md = j % x;
                g[md] = (g[md] + f[i - 1][j]) % MOD;
                int t = j - x * (y + 1);
                if (t &gt;= 0) g[md] = (g[md] - f[i - 1][t]) % MOD;
                f[i][j] = g[md];
            &#125;
        &#125;

        int res = 0;
        for (int j = l; j &lt;= r; j++) res = (res + f[i][j]) % MOD;
        res = (res * (1LL * (cnt[0] + 1))) % MOD;
        return (res + MOD) % MOD;
    &#125;
&#125;;
// 核心代码
// 当前需要使用哪个滑动窗口
int md = j % v[i];
// 滑动窗口滑动一步
g[md] += f[i - 1][j];
g[md] -= f[i - 1][j - v[i] * (a[i] + 1)];
// 把滑动窗口的值赋给 dp 数组
f[i][j] = g[md];
</code></pre>
<h3 id="树形-DP"><a href="#树形-DP" class="headerlink" title="树形 DP"></a>树形 DP</h3><h4 id="最小高度树"><a href="#最小高度树" class="headerlink" title="最小高度树"></a>最小高度树</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-height-trees/description/">题目链接</a></p>
<p>这道题首先求出以 <code>0</code> 为根时各子树的高度，记录在 <code>h[]</code> 数组中；dp 的时候是先求出 <code>u</code> 的子节点的最大高度和次大高度，然后记录 <code>f[u]</code>；之后换根时注意了，<strong>是先更新了 <code>h[u]</code> 再去 <code>dp(v)</code>！</strong>这样在 <code>dp(v)</code> 的时候，<code>h[]</code> 刚好就是以 <code>v</code> 为根时各子树的高度</p>
<p>为什么：换根时只会影响 <code>h[u]</code>，因此先更新 <code>h[u]</code> 才是正确的</p>
<h4 id="求树上长度恰好为-k-的路径个数"><a href="#求树上长度恰好为-k-的路径个数" class="headerlink" title="求树上长度恰好为 k 的路径个数"></a>求树上长度恰好为 k 的路径个数</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/161/D">Problem - 161D - Codeforces</a></p>
</blockquote>
<p>分类讨论</p>
<ul>
<li><p>一是节点 <code>u</code> 到子树内长为 <code>k</code> 的链 <code>f[u][k]</code></p>
</li>
<li><p>枚举 <code>u</code> 的每两个子节点，把链拼起来，巧妙做法是 <code>sum&#123;(f[u][k-i]-f[v][k-i-1]) * f[v][i-1]&#125;</code></p>
<ul>
<li>意思是在 <code>v</code> 子树中选长为 <code>i-1</code> 的链，然后和 <code>u</code> 子树中长为 <code>k-i</code> 的链匹配，但是要先减去 <code>v</code> 中的链，避免算重</li>
</ul>
</li>
</ul>
<pre><code class="cpp">void dfs(int u, int fa) &#123;
    f[u][0] = 1;
    for (int v: g[u])
        if (v != fa) &#123;
            dfs(v, u);
            for (int i = 0; i &lt; k; i++) 
                f[u][i + 1] += f[v][i];
        &#125;
    res += f[u][k];
    LL ans = 0;
    for (int v: g[u])
        if (v != fa)
            for (int i = 1; i &lt; k; i++)
                ans += f[v][i - 1] * (f[u][k - i] - f[v][k - i - 1]);
    res += ans / 2;
&#125;
</code></pre>
<h4 id="换根-DP-解决白色点-黑色点的最大值"><a href="#换根-DP-解决白色点-黑色点的最大值" class="headerlink" title="换根 DP 解决白色点-黑色点的最大值"></a>换根 DP 解决白色点-黑色点的最大值</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1324/F">https://codeforces.com/problemset/problem/1324/F</a><br>对于每个节点 <code>u</code>，选出一个<strong>包含</strong> <code>u</code> 的连通子图，设子图中白点个数为 <code>cnt1</code>，黑点个数为 <code>cnt2</code>，请最大化 <code>cnt1-cnt2</code>。并输出这个值。</p>
</blockquote>
<p>法一：</p>
<p>固定根时，定义 <code>f[v]</code> 表示以 <code>v</code> 为根子树的最大值，那么对于每个子树，<code>f[v] += max(f[to], 0)</code></p>
<p>换根，只会改变 <code>f[v]</code> 和 <code>f[to]</code> 的值，可以根据它的值是否为 <code>0</code> 来得知原来是怎么转移的，然后更新之后 dp 子树，最后回溯</p>
<pre><code class="cpp">void dfs(int u, int fa) &#123;
    f[u] = a[u];
    for (int v: g[u])
        if (v != fa) &#123;
            dfs(v, u);
            f[u] += max(f[v], 0);
        &#125;
&#125;

void dfs2(int u, int fa) &#123;
    res[u] = f[u];
    for (int v: g[u])
        if (v != fa) &#123;
            f[u] -= max(f[v], 0);
            f[v] += max(f[u], 0);
            dfs2(v, u);
            // rollback
            f[v] -= max(f[u], 0);
            f[u] += max(f[v], 0);
        &#125;
&#125;
</code></pre>
<p>法二：直接在 <code>a[i]</code> 上计算，换根时</p>
<ul>
<li>如果 <code>a[to] &gt; 0</code>，那么 <code>a[v]</code> 的答案包含 <code>a[to]</code>，取最大值 <code>max(a[to], a[v])</code></li>
<li>否则，<code>a[v]</code> 的答案不包含 <code>a[to]</code>，就可以选或不选 <code>max(a[to], a[v]+a[to])</code></li>
</ul>
<pre><code class="cpp">void dfs(int now, int pre) &#123;
    for (auto &amp;to:v[now]) &#123;
        if (to == pre)
            continue;
        dfs(to, now);
        if (a[to] &gt; 0)
            a[now] += a[to];
    &#125;
&#125;

void dfs2(int now, int pre) &#123;
    for (auto &amp;to:v[now]) &#123;
        if (to == pre)
            continue;
        if (a[to] &gt; 0)
            a[to] = max(a[to], a[now]);
        else
            a[to] = max(a[to], a[now] + a[to]);
        dfs2(to, now);
    &#125;
&#125;
</code></pre>
<h4 id="求-sigma-d-i-a-i-for-每个点为根"><a href="#求-sigma-d-i-a-i-for-每个点为根" class="headerlink" title="求 sigma(d[i]*a[i]) for 每个点为根"></a>求 sigma(d[i]*a[i]) for 每个点为根</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1092/F">Problem - 1092F - Codeforces</a></p>
</blockquote>
<p>当根从 <code>u</code> 换到 <code>v</code> 时，以 <code>v</code> 为根子树的贡献各减少 <code>1</code>，共减少 <code>s[v]</code>，其余部分贡献各增加 <code>1</code>，共增加 <code>sum-s[v]</code>，因此转移方程为 <code>f[v]=f[u]+sum-2*s[v]</code></p>
<ul>
<li>这题注意的点在于维护一个点权和用于转移，进阶版：求 <code>sigma(d[i]^2*a[i])</code></li>
</ul>
<pre><code class="cpp">void dfs(int u, int fa) &#123;
    s[u] = a[u], f[u] = 0;
    for (int v: g[u])
        if (v != fa) &#123;
            dfs(v, u);
            s[u] += s[v];
            f[u] += f[v] + s[v];
        &#125;
&#125;

void dfs2(int u, int fa) &#123;
    if (fa) f[u] = f[fa] + sum - 2 * s[u]; 
    for (int v: g[u])
        if (v != fa) dfs2(v, u);
&#125;
</code></pre>
<h4 id="二叉树灯饰——状态设计"><a href="#二叉树灯饰——状态设计" class="headerlink" title="二叉树灯饰——状态设计"></a>二叉树灯饰——状态设计</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/U7WvvU/description/">LCP 64. 二叉树灯饰 - 力扣（LeetCode）</a><br>二叉树：0 表示关灯，1 表示开灯</p>
<ul>
<li>操作 1：切换当前根节点状态</li>
<li>操作 2：切换当前子树所有节点状态</li>
<li>操作 3：切换根节点和左右子节点的状态<br>  问使得二叉树所有点状态都为 0，最小操作次数</li>
</ul>
</blockquote>
<p>本题核心在于观察操作 2 和 3，发现如果左右子节点在操作后状态不同，将没有操作使得它们相同（同亮同灭）</p>
<p>基于这个观察设计状态：<code>f(root, 0/1, 0/1)</code> 表示该子树的根是否亮，该子树除根外的所有节点是否亮</p>
<pre><code class="cpp">class Solution &#123;
public:
    const int INF = (int)1e9;
    vector&lt;int&gt; dp(TreeNode *root) &#123;
        if (root == nullptr) return &#123;0, 0, 0, 0&#125;;
        vector&lt;int&gt; L = dp(root-&gt;left), R = dp(root-&gt;right);
        vector&lt;int&gt; res = &#123;INF, INF, INF, INF&#125;;
        // 枚举以子节点为根的子树的状态，a 表示子节点的状态，b 表示除子节点外的其它节点的状态
        for (int a = 0; a &lt; 2; a++)
            for (int b = 0; b &lt; 2; b++) &#123;
                int from = b * 2 + a;
                int c = root-&gt;val;
                // 每种操作最多做一次，因此用二进制枚举做了哪些操作
                for (int i = 0; i &lt; 8; i++) &#123;
                    int x = i &amp; 1, y = i &gt;&gt; 1 &amp; 1, z = i &gt;&gt; 2 &amp; 1;
                    // 子节点只受操作 2 和 3 的影响
                    int aa = (y ^ z ? 1 - a : a);
                    // 除子节点外的其它节点只受操作 2 的影响
                    int bb = (y ? 1 - b : b);
                    // 当前节点受所有操作影响
                    int cc = (x ^ y ^ z ? 1 - c : c);
                    // 除根外的节点要保持一致，否则后续没有操作能让它们一致
                    if (aa != bb) continue;
                    res[aa * 2 + cc] = min(res[aa * 2 + cc], L[from] + R[from] + x + y + z);
                &#125;
            &#125;
        return res;
    &#125;
    int closeLampInTree(TreeNode* root) &#123;
        return dp(root)[0];
    &#125;
&#125;;
</code></pre>
<h3 id="优化-DP"><a href="#优化-DP" class="headerlink" title="优化 DP"></a>优化 DP</h3><h4 id="后缀和优化"><a href="#后缀和优化" class="headerlink" title="后缀和优化"></a>后缀和优化</h4><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-ways-of-cutting-a-pizza/">1444. 切披萨的方案数</a></li>
</ul>
<p>参考 $O(nmk)$ 的解法，用到了后缀和来优化</p>
<pre><code class="cpp">class Solution &#123;
public:
    int ways(vector&lt;string&gt;&amp; pizza, int k) &#123;
        int m = pizza.size(), n = pizza[0].size();
        LL f[m + 1][n + 1];
        memset(f, 0, sizeof f);        
        int s[m + 1][n + 1];
        memset(s, 0, sizeof s);
        for (int i = m - 1; i &gt;= 0; i--)
            for (int j = n - 1; j &gt;= 0; j--)
            &#123;
                s[i][j] = s[i][j + 1] + s[i + 1][j] - s[i + 1][j + 1] + (pizza[i][j] == &#39;A&#39;);
                if (s[i][j]) f[i][j] = 1;
            &#125;
        
        while (-- k )
        &#123;
            vector&lt;int&gt; cols(n); // colS[j] 表示 f 第 j 列的后缀和
            for (int i = m - 1; i &gt;= 0; i--)
            &#123;
                LL rows = 0; // f[i] 的后缀和
                for (int j = n - 1; j &gt;= 0; j--)
                &#123;
                    LL t = f[i][j];
                    if (s[i][j] == s[i][j + 1])
                        f[i][j] = f[i][j + 1];
                    else if (s[i][j] == s[i + 1][j]) 
                        f[i][j] = f[i + 1][j];
                    else f[i][j] = (rows + cols[j]) % MOD;
                    rows = (rows + t) % MOD;
                    cols[j] = (cols[j] + t) % MOD;
                &#125;
            &#125;
        &#125;
        return f[0][0];
    &#125;
&#125;;
</code></pre>
<h4 id="CF1913D-单调栈优化-DP"><a href="#CF1913D-单调栈优化-DP" class="headerlink" title="CF1913D 单调栈优化 DP"></a>CF1913D 单调栈优化 DP</h4><blockquote>
<p>元素值互不相同的数组，可以选择一个连续子数组，保留其中的最小值，其它删掉。可操作任意次，问能得到不同的数组的个数。</p>
</blockquote>
<p>思路：被删除的元素不一定是连续的 -&gt; 子序列问题</p>
<p>转换为统计剩余子序列的个数 -&gt; DP</p>
<p>经典套路：定义 <code>f[i]</code> 表示以 <code>p[i]</code> 结尾的子序列个数，然后考虑倒数第二个数可以是哪个</p>
<p>特点：要操作的子数组的第一个数或者最后一个数一定是最小的</p>
<p>因此转移来源有两部分</p>
<ul>
<li>最后一个数最小时，倒数第二个数可以是它左边比它大的数</li>
<li>第一个数最小时，需要用单调栈维护这些数（手玩样例可以发现）</li>
</ul>
<p>在当前数入栈前，需要把栈中比它大的数都出栈</p>
<p>特殊情况：若单调栈为空，表明当前这个数可以单独作为子数组，<code>f</code> 值 <code>+1</code></p>
<p>维护 <code>f</code>的前缀和，以及栈中元素对应的 <code>f</code> 值的和</p>
<p>能够作为结尾的数恰好是最后留在单调栈中的数字</p>
<p><img src="https://gcore.jsdelivr.net/gh/Ricky-Daxia/Hei_Xiu/202407141527894.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/Ricky-Daxia/Hei_Xiu/202407141527894.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<pre><code class="cpp">cin &gt;&gt; n;
        for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i];
        vector&lt;LL&gt; s(n + 1), f(n);
        stack&lt;int&gt; st;
        LL sum = 0; // 单调栈的元素的 f 值和
        for (int i = 0; i &lt; n; i++)
        &#123;
            while (st.size() &amp;&amp; a[st.top()] &gt; a[i])
            &#123;
                sum -= f[st.top()];
                st.pop();
            &#125;
            int j = st.empty() ? 0 : st.top() + 1;
            f[i] = (sum + s[i] - s[j] + st.empty()) % mod;
            s[i + 1] = (s[i] + f[i]) % mod;
            sum = (sum + f[i]) % mod;
            st.push(i);
        &#125;
        cout &lt;&lt; (sum + mod) % mod &lt;&lt; endl;
</code></pre>
<h4 id="求-min-max-最大子段和，-最小子段和"><a href="#求-min-max-最大子段和，-最小子段和" class="headerlink" title="求 min(max(最大子段和，| 最小子段和 |))"></a>求 min(max(最大子段和，| 最小子段和 |))</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3aqs1c/description/">LCP 65. 舒适的湿度 - 力扣（LeetCode）</a><br>题目意思是，可以把数组的一些数变成相反数，然后最小化数组的 <code>max(最大子段和，最小子段和的绝对值)</code><br>数据范围和值域都是 <code>1000</code></p>
</blockquote>
<p>这种问题的处理方法是数形结合，即用折线图的形式表示前缀和，然后可以发现要求的东西变成了折线图中最高点-最低点（<strong>重要技巧！</strong>）</p>
<p><img src="https://gcore.jsdelivr.net/gh/Ricky-Daxia/Hei_Xiu/202407141528155.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/Ricky-Daxia/Hei_Xiu/202407141528155.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<p>然后，子段和启发我们往 DP 上靠，本题最难的地方在于设计状态！从数据范围入手，值域 <code>1000</code>，再想想折线图的上界是多少？不就是数组的最大值吗？也就是说折线始终会在 <code>[-mx, mx]</code> 内</p>
<p>那么，状态定义就是 <code>f[i][j]</code> 表示考虑前 <code>i</code> 个数，其中某些数字取负，折线图右端点到折线图最低点的纵坐标距离为 <code>j</code> 时，折线图最大值与最小值之差的最小值（这个定义就把值域考虑进去了，最终是 $O(nU)$ 的做法）</p>
<p>状态转移：考虑每个数取正还是取负</p>
<ul>
<li><p>取正，折线图向上走，<code>f[i-1][j]-&gt;f[i][j+x]</code></p>
</li>
<li><p>取负，折线图向下走，要考虑会不会产生新的最低点</p>
<ul>
<li>不产生：<code>f[i-1][j]-&gt;f[i][j-x]</code></li>
<li>产生：根据定义，<code>f[i][0]&lt;-f[i-1][j]+x-j</code></li>
</ul>
</li>
</ul>
<p>初始值，<code>f[0][0]=0</code>，其余为无穷，答案为 <code>min(f[n-1])</code></p>
<pre><code class="cpp">class Solution &#123;
public:
    int unSuitability(vector&lt;int&gt;&amp; operate) &#123;
        int mx = ranges::max(operate) * 2 + 1;
        vector&lt;int&gt; pre(mx, 0x3f3f3f3f), f(mx);
        pre[0] = 0;
        for (int x: operate) &#123;
            fill(f.begin(), f.end(), 0x3f3f3f3f);
            for (int j = 0; j &lt; mx; j++) &#123;
                int dis = pre[j];
                if (dis == 0x3f3f3f3f) continue; // 无效的长度（无法组成）
                if (j + x &lt; mx) f[j + x] = min(f[j + x], max(dis, j + x)); 
                if (j &gt;= x) f[j - x] = min(f[j - x], dis);
                else f[0] = min(f[0], dis + x - j);
            &#125;
            swap(pre, f);
        &#125;
        return ranges::min(pre);
    &#125;
&#125;;
</code></pre>
<h4 id="前缀-max-优化-DP"><a href="#前缀-max-优化-DP" class="headerlink" title="前缀 max 优化 DP"></a>前缀 max 优化 DP</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ZbAuEH/description/">LCP 57. 打地鼠 - 力扣（LeetCode）</a><br><code>3×3</code> 网格上，每秒每个位置最多出现一只地鼠，地鼠出现的格式为 <code>(t,x,y)</code>，<code>t=0</code> 时锤子在 <code>(1,1)</code>，每移动一格需要 <code>1s</code>，问最多打到几只地鼠。<code>t</code> 的取值范围为 <code>1e9</code></p>
</blockquote>
<p>坑点在于，<code>t=0</code> 时其他位置的地鼠是打不到的</p>
<p>状态设计：<code>f[i]</code> 表示考虑前 <code>i</code> 只地鼠（按出现时间顺序排序），保证打第 <code>i</code> 只时，最多能打多少只</p>
<p>转移的话，考虑上一只打的地鼠是谁就可以了，只要相差时间不小于移动距离即可。但这样做是$O(n^2)$ 的，怎么优化？考虑到网格的最远距离只有 4，因此相差时间大于 4 的，就一定能转移，那么这一段就用前缀 max 优化。需要枚举的数量变成了 4×9&#x3D;36，总的复杂度就是$O(n)$</p>
<pre><code class="cpp">class Solution &#123;
public:
    int getMaximumNumber(vector&lt;vector&lt;int&gt;&gt;&amp; moles) &#123;
        // 把所有时间 0 出现的地鼠排除
        vector&lt;vector&lt;int&gt;&gt; A;
        bool flag = false;
        for (auto &amp;mole : moles) &#123;
            if (mole[0] == 0) &#123;
                // 看一下有没有时间 0 位于 (1, 1) 的地鼠，一开始就能打
                if (mole[1] == 1 &amp;&amp; mole[2] == 1) flag = true;
            &#125; else &#123;
                A.push_back(mole);
            &#125;
        &#125;
        // 初始位置位于 (1, 1)
        A.push_back(vector&lt;int&gt;&#123;0, 1, 1&#125;);

        int n = A.size();
        sort(A.begin(), A.end());
        vector&lt;int&gt; f(n), g(n);
        int ans = 0;
        for (int i = 1; i &lt; n; i++) &#123;
            f[i] = -1e8;
            for (int j = i - 1; j &gt;= 0; j--) &#123;
                int t = A[i][0] - A[j][0], d = abs(A[i][1] - A[j][1]) + abs(A[i][2] - A[j][2]);
                // 能从任何位置移过来，用前缀 max 更新答案
                if (t &gt; 4) &#123; f[i] = max(f[i], g[j] + 1); break; &#125;
                // 虽然有时间限制，但移过来能来得及，更新答案
                else if (d &lt;= t) f[i] = max(f[i], f[j] + 1);
            &#125;
            ans = max(ans, f[i]);
            g[i] = max(g[i - 1], f[i]);
        &#125;
        return ans + (flag ? 1 : 0);
    &#125;
&#125;;
</code></pre>
<h4 id="划分数字的方案数"><a href="#划分数字的方案数" class="headerlink" title="划分数字的方案数"></a>划分数字的方案数</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-ways-to-separate-numbers/">1977. 划分数字的方案数</a><br>给一个字符串 <code>num</code>，一个正整数数组，非递减，每个数拼起来得到 <code>num</code>，问有多少种构造数组的方案，要求$n^2$ 做法</p>
</blockquote>
<p>定义 <code>f[i][j]</code> 表示考虑了 <code>[0,j]</code> 这一段，最后一段数是 <code>[i,j]</code>，转移的话就考虑前一段，就是 <code>sigma(f[k][i-1])</code>，由于数位越多，数字越大，得到 <code>i-1-k&lt;=j-i</code>，然后要分情况了，<code>k=2*i-j-1</code> 时，前一段和这一段数位相同，需要比较数字本身，<code>k&gt;=2*i-j</code> 时，连续的一段可以用前缀和累加</p>
<p>好了，怎么比较数字本身呢？这里用到了 <strong>lcp</strong>（<code>lcp[i][j]</code> 表示从 <code>i</code> 开始的后缀和从 <code>j</code> 开始的后缀的最长公共前缀长度），我们看 <code>lcp[2*i-j-1][i]</code> 的大小，如果等于这一段的长度，说明数字相等，如果小于，那就看第一个不同的位置的大小，这个是好理解的</p>
<p>前缀和这里怎么办呢？观察 <code>f[i][j]</code> 和 <code>f[i][j+1]</code> 的求和式，发现只相差 <code>f[2*i-j-i][i-1]</code> 这一项，于是可以用一个变量来累加就可以了</p>
<pre><code class="cpp">int numberOfCombinations(string num) &#123;
        if (num[0] == &#39;0&#39;) &#123;
            return 0;
        &#125;
        int n = num.size();
        int lcp[n][n];
        memset(lcp, 0, sizeof(lcp));
        for (int i = n - 1; i &gt;= 0; i--) &#123;
            lcp[i][n - 1] = num[i] == num[n - 1];
            for (int j = i + 1; j &lt; n - 1; j++) &#123;
                lcp[i][j] = (num[i] == num[j] ? lcp[i + 1][j + 1] + 1 : 0);
            &#125;
        &#125;
        int f[n][n];
        memset(f, 0, sizeof(f));
        for (int i = 0; i &lt; n; i++) &#123;
            f[0][i] = 1;
        &#125;
        for (int i = 1; i &lt; n; i++) &#123;
            if (num[i] == &#39;0&#39;) &#123;
                continue;
            &#125;
            int pre = 0;
            for (int j = i; j &lt; n; j++) &#123;
                int len = j - i + 1;
                f[i][j] = pre;
                if (i - len &gt;= 0) &#123;
                    if (lcp[i - len][i] &gt;= len || num[i - len + lcp[i - len][i]] &lt; num[i + lcp[i - len][i]]) &#123;
                        f[i][j] = (f[i][j] + f[i - len][i - 1]) % MOD;
                    &#125;
                    pre = (pre + f[i - len][i - 1]) % MOD;
                &#125;
            &#125;
        &#125;
        int res = 0;
        for (int i = 0; i &lt; n; i++) &#123;
            res = (res + f[i][n - 1]) % MOD;
        &#125;
        return res;
    &#125;
</code></pre>
<h4 id="逆序对相关的-DP"><a href="#逆序对相关的-DP" class="headerlink" title="逆序对相关的 DP"></a>逆序对相关的 DP</h4><blockquote>
<p>问 <code>1-n</code> 的排列数，满足有 <code>k</code> 个逆序对</p>
</blockquote>
<p>定义 <code>f[i][j]</code> 表示用数值 <code>[1,i]</code>，凑出 <code>j</code> 个逆序对的方案数。考虑第 <code>i</code> 个数放的位置，从下标 <code>0</code> 到 <code>i-1</code>，可以发现状态转移上，取的是连续的一段，可以用前缀和优化</p>
<p><strong>此处转移方程为 <code>f[i][j] = sigma(k from 0 to i-1)f[i-1][j-k]</code></strong></p>
<pre><code class="go">func kInversePairs(n int, k int) int &#123;
    const MOD int = 1e9 + 7
    f := make([][]int, 2)
    for i := range f &#123;
        f[i] = make([]int, k + 1)
    &#125;
    f[0][0] = 1
    for i := 1; i &lt;= n; i++ &#123;
        cur, pre := i &amp; 1, i &amp; 1 ^ 1
        sum := 0
        for j := 0; j &lt;= k; j++ &#123;
            sum = (sum + f[pre][j]) % MOD
            f[cur][j] = sum
            if j &gt;= i - 1 &#123;
                sum = (sum - f[pre][j - i + 1] + MOD) % MOD
            &#125;
        &#125;
    &#125;
    return f[n &amp; 1][k]
&#125;
</code></pre>
<blockquote>
<p>给出若干限制 <code>[end, cnt]</code>，表示 <code>[0,end]</code> 内刚好有 <code>cnt</code> 个逆序对，问方案数（保证有 <code>end==n-1</code>）</p>
</blockquote>
<p>定义 <code>f[i][j]</code> 表示从下标 <code>[0,i]</code> 的排列中，恰有 <code>j</code> 个逆序对的方案数。同样考虑下标为 <code>i</code> 的数 <code>a[i]</code>，和前面 <code>i</code> 个数的大小，假设比 <code>d</code> 个数小，那么 <code>f[i][j]&lt;-f[i-1][j-d]</code>。当遇到限制时，只计算 <code>f[end][j=cnt]</code> 的值，其它的 <code>f[end][*]=0</code>，这里同样可以用前缀和优化</p>
<pre><code class="go">func numberOfPermutations(n int, requirements [][]int) int &#123;
    const MOD int = 1e9 + 7
    req := make([]int, n)
    for i := 0; i &lt; n; i++ &#123;
        req[i] = -1
    &#125;
    for _, r := range requirements &#123;
        req[r[0]] = r[1]
    &#125;
    if req[0] &gt; 0 &#123;
        return 0
    &#125;

    mx := slices.Max(req)
    f := make([][]int, 2)
    for i := range f &#123;
        f[i] = make([]int, mx + 1)
    &#125;
    f[0][0] = 1
    for i := 1; i &lt;= n; i++ &#123;
        pre, cur := i &amp; 1 ^ 1, i &amp; 1
        sum := 0
        for j := 0; j &lt;= mx; j++ &#123;
            sum = (sum + f[pre][j]) % MOD
            if req[i - 1] == -1 || req[i - 1] == j &#123;
                f[cur][j] = sum
            &#125; else &#123;
                f[cur][j] = 0
            &#125;
            if j &gt;= i - 1 &#123;
                sum = (sum - f[pre][j - i + 1] + MOD) % MOD
            &#125;
        &#125;
    &#125;
    return f[n &amp; 1][req[n - 1]]
&#125;
</code></pre>
<h3 id="典题"><a href="#典题" class="headerlink" title="典题"></a>典题</h3><h4 id="最长公共上升子序列长度"><a href="#最长公共上升子序列长度" class="headerlink" title="最长公共上升子序列长度"></a>最长公共上升子序列长度</h4><p>最长上升子序列问题，定义 <code>f[i][j]</code> 表示所有在 <code>A[1...i]</code> 中和 <code>B[1...i]</code> 中都出现过的且以 <code>B[j]</code> 结尾的公共上升子序列集合。<br>状态计算：集合划分？分成 <code>A[i]</code> 不包含在公共子序列中的集合（左边）和包含 <code>A[i]</code> 的公共子序列（右边）。左边对应的是所有在 <code>A[1...i-1]</code> 和 <code>B[1...i]</code> 中出现的公共子序列，恰好就是 <code>f[i-1][j]</code>。右边直接求不好求，需要继续划分。按倒数第二个数划分（不存在，<code>B[1]</code>，<code>B[2]</code>…<code>B[j-1]</code>），不存在意味着长度为 1，值也是 1。对于第$k$类，值为 <code>f[i-1][k]+1</code>。为什么？首先由公共的定义，<code>A[i]==B[j]</code>，因此去掉不管，只考虑前面的部分，就能得出这个答案了。<br>朴素做法需要三重循环，考虑优化掉一重循环：我们发现每次循环求得的 <code>maxv</code> 是满足 <code>a[i] &gt; b[k]</code> 的 <code>f[i - 1][k] + 1</code> 的前缀最大值。因此我们可以记录下前面求得的最大值，进而优化掉一重循环。</p>
<pre><code class="cpp">for (int i = 1; i &lt;= n; i++)
    &#123;
        int maxv = 1;
        for (int j = 1; j &lt;= n; j++)
        &#123;
            f[i][j] = f[i - 1][j];
            if (a[i] == b[j]) f[i][j] = max(f[i][j], maxv);
            if (b[j] &lt; a[i]) maxv = max(maxv, f[i - 1][j] + 1);
        &#125;
    &#125;
</code></pre>
<h4 id="不同的子序列：随机化"><a href="#不同的子序列：随机化" class="headerlink" title="不同的子序列：随机化"></a>不同的子序列：随机化</h4><blockquote>
<p>给定一个字符串 $S$ 和一个字符串 $T$，请问共有多少个 $S$ 的不同的子序列等于 $T$。<br>第一行包含整数 $Q$，表示共有 $Q$ 组测试数据。<br>每组数据第一行包含字符串 $S$，第二行包含字符串 $T$。<br>每组数据输出一行，一个结果，由于结果可能很大，因此输出其对 $1000000007$ 取模后的值。<br>$1 \le Q \le 50$ , $1 \le |S|,|T| \le 10^4$<br><strong>保证 <strong>$T$</strong> 中的每个字符都是随机生成的。</strong><br>字符串中只包含小写字母。</p>
</blockquote>
<p>分析：经典 DP，优化掉一维，否则超内存；但是 TLE，原因在于复杂度为$O(Qmn)&#x3D;5 \times 10^9$，注意加粗的条件，随机生成意味着$a[i] &#x3D; b[j]$的概率为$1&#x2F;26$，能不能只枚举$a[i]$出现的位置呢，时间复杂度降为$O(\dfrac{Qmn}{26})$，可以过。</p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

using namespace std;

const int N = 10010, MOD = 1e9 + 7;

int f[N];
char a[N], b[N];

int main()
&#123;
    int Q;
    scanf(&quot;%d&quot;, &amp;Q);
    
    while (Q -- )
    &#123;
        scanf(&quot;%s%s&quot;, a + 1, b + 1);
        int n = strlen(a + 1), m = strlen(b + 1);
        
        vector&lt;int&gt; p[26];
        for (int i = m; i; i -- ) p[b[i] - &#39;a&#39;].push_back(i);
        
        memset(f, 0, sizeof f);
        f[0] = 1;
        
        for (int i = 1; i &lt;= n; i ++ )
            for (int j: p[a[i] - &#39;a&#39;])
                f[j] = (f[j] + f[j - 1]) % MOD;
        
        printf(&quot;%d\n&quot;, f[m]);
    &#125;
    
    return 0;
&#125;
</code></pre>
<h4 id="最大子段和"><a href="#最大子段和" class="headerlink" title="最大子段和"></a>最大子段和</h4><blockquote>
<p>给序列，<code>k</code>，<code>x</code><br>你需要执行一次操作，选择恰好 <code>k</code> 个不同位置，元素 <code>+x</code>，其余元素 <code>-x</code>，求出操作后的最大连续子数组和，考虑空数组，和为 <code>0</code></p>
</blockquote>
<p>用 0 1 2 三种状态记录当前在答案字段前，中，后</p>
<pre><code class="cpp">cin &gt;&gt; n &gt;&gt; k &gt;&gt; x;
        for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i];
        for (int i = 0; i &lt;= n; i++)
            for (int j = 0; j &lt;= k; j++)
                for (int t = 0; t &lt; 3; t++)
                    f[i][j][t] = -1e18;
        f[0][0][0] = 0;
        for (int i = 0; i &lt; n; i++)
            for (int j = 0; j &lt;= k; j++)
                for (int t = 0; t &lt; 3; t++)
                &#123;
                    if (f[i][j][t] == -1e18) continue;
                    for (int jj = j; jj &lt;= min(k, j + 1); jj++)
                    &#123;
                        LL add = a[i] + (j == jj ? -x : x);
                        for (int tt = t; tt &lt; 3; tt++)
                            f[i + 1][jj][tt] = max(f[i + 1][jj][tt], f[i][j][t] + (tt == 1 ? add : 0));
                    &#125;
                &#125;
        cout &lt;&lt; max(f[n][k][1], f[n][k][2]) &lt;&lt; endl;
</code></pre>
<h4 id="任意修改序列的一个数，问之后的-LIS-长度"><a href="#任意修改序列的一个数，问之后的-LIS-长度" class="headerlink" title="任意修改序列的一个数，问之后的 LIS 长度"></a>任意修改序列的一个数，问之后的 LIS 长度</h4><p>思路是维护 <code>f[i]</code>，表示以 <code>a[i]</code> 结尾的 LIS；维护 <code>g[i]</code>，表示以 <code>a[i]</code> 开头的 LIS</p>
<p>然后枚举位置</p>
<ul>
<li>若不是最后一个位置，可以改后面那个数，即 <code>res=max(res, f[i]+1)</code></li>
<li>若不是最开始的位置，且当前 <code>a[i]</code> 不是 <code>0</code>，就可以改前面那个数，即 <code>res=max(res, g[i]+1)</code></li>
<li>假设有两段，枚举后一段开始的位置，要满足 <code>a[j]-a[i]&gt;1</code>，就可以改中间的数，即 <code>res=max(res, f[i]+g[j]+1)</code></li>
</ul>
<p>代码细节较多</p>
<pre><code class="cpp">for (int i = 1; i &lt;= n; i++)
        for (int j = 1; j &lt; i; j++)
            if (a[j] &lt; a[i]) f[i] = max(f[i], f[j] + 1);
    for (int i = n; i &gt;= 1; i--)
        for (int j = n; j &gt; i; j--)
            if (a[j] &gt; a[i]) g[i] = max(g[i], g[j] + 1);
    int res = 0;
    for (int i = 1; i &lt;= n; i++)
    &#123;
        if (i &lt; n) res = max(res, f[i] + 1);
        else res = max(res, f[i]);
        
        if (i &gt; 1 &amp;&amp; a[i] != 0) res = max(res, g[i] + 1);
        else res = max(res, g[i]);
        
        for (int j = i + 2; j &lt;= n; j++)
            if (a[j] - a[i] &gt; 1) res = max(res, f[i] + g[j] + 1);
    &#125;
</code></pre>
<h4 id="把数组划成-k-个区间，给定每个区间的权值，问-sigma-区间和-权值-最大值"><a href="#把数组划成-k-个区间，给定每个区间的权值，问-sigma-区间和-权值-最大值" class="headerlink" title="把数组划成 k 个区间，给定每个区间的权值，问 sigma(区间和*权值)最大值"></a>把数组划成 k 个区间，给定每个区间的权值，问 sigma(区间和*权值)最大值</h4><p>显然 DP，核心是看最后一个数属于当前段还是新开一个段</p>
<p><code>f[i][j] = max(f[i - 1][j], f[i - 1][j - 1]) + a[i]*p[j]</code></p>
<h4 id="摘樱桃"><a href="#摘樱桃" class="headerlink" title="摘樱桃"></a>摘樱桃</h4><blockquote>
<p>给 <code>n × n</code> 网格，<code>1</code> 代表樱桃，<code>0</code> 代表空地，<code>-1</code> 代表不能走，从左上到右下再回到左上，问最多经过几个有 <code>1</code> 的格子？</p>
</blockquote>
<p>题意转换：看成是从左上到右下走两次，途径格子只能得分一次，等价于两个人同时从左上走，到右下角的最大得分</p>
<p>定义 <code>f[k][i][j]</code> 表示走了 <code>k</code> 步，第一个人在第 <code>i</code> 行，第二个人在第 <code>j</code> 行的最大得分。转移前驱有四个：分别是走行、走列。若当前位置不重叠，同时累加，否则累加一次。初始化为负无穷</p>
<pre><code class="cpp">f[2][1][1] = grid[0][0];
for (int k = 3; k &lt;= 2 * n; k++)
    for (int i1 = 1; i1 &lt;= n; i1++)
        for (int i2 = 1; i2 &lt;= n; i2++) &#123;
            int j1 = k - i1, j2 = k - i2;
            if (j1 &lt;= 0 || j1 &gt; n || j2 &lt;= 0 || j2 &gt; n) continue;
            int A = grid[i1 - 1][j1 - 1], B = grid[i2 - 1][j2 - 1];
            if (A == -1 || B == -1) continue;
            int a = f[k - 1][i1 - 1][i2], b = f[k - 1][i1 - 1][i2 - 1];
            int c = f[k - 1][i1][i2 - 1], d = f[k - 1][i1][i2];
            int t = max(max(a, b), max(c, d)) + A;
            if (i1 != i2) t += B;
            f[k][i1][i2] = t;
        &#125;
</code></pre>
<h4 id="第一类斯特林数"><a href="#第一类斯特林数" class="headerlink" title="第一类斯特林数"></a>第一类斯特林数</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-ways-to-rearrange-sticks-with-k-sticks-visible/">1866. 恰有 K 根木棍可以看到的排列数目</a><br>有 <code>n</code> 根长度互不相同的木棍，长度为从 <code>1</code> 到 <code>n</code> 的整数。请你将这些木棍排成一排，并满足从左侧 <strong>可以看到</strong> <strong>恰好</strong> <code>k</code> 根木棍。从左侧 <strong>可以看到</strong> 木棍的前提是这个木棍的 <strong>左侧</strong> 不存在比它 <strong>更长的</strong> 木棍。</p>
<ul>
<li>例如，如果木棍排列为 <code>[</code> <strong>1</strong> <code>,</code> <strong>3</strong> <code>,2,</code> <strong>5</strong> <code>,4]</code> ，那么从左侧可以看到的就是长度分别为 <code>1</code>、<code>3</code> 、<code>5</code> 的木棍。</li>
<li>给你 <code>n</code> 和 <code>k</code> ，返回符合题目要求的排列 <strong>数目</strong> 。由于答案可能很大，请返回对 <code>10^(9)7</code> <strong>取余</strong>的结果。<br>数据范围是 <code>1000</code></li>
</ul>
</blockquote>
<p>先看 DP 怎么做，定义 <code>f[i][j]</code> 表示考虑前 <code>i</code> 个数，有 <code>j</code> 个数被看到的方案数。转移时考虑<strong>最后一个数能否被看到</strong>：</p>
<ul>
<li>能，那么最后一个数一定为 <code>i</code>，对应前 <code>i-1</code> 个数被看到 <code>j-1</code> 个数的方案数</li>
<li>不能，那么这个数可以是 <code>x</code> ∈ <code>[1...i-1]</code>，然后我们排其它 <code>i-1</code> 个数，可以把 <code>[1...i]/x</code> 按相对大小映射到 <code>[1...i-1]</code> ，也就相当于 <code>f[i-1][j]</code>，最后一共有 <code>i-1</code> 个数可作为最后一个</li>
</ul>
<p>初始化 <code>f[0][0]=1</code>，其余都是 <code>0</code></p>
<pre><code class="cpp">class Solution &#123;
private:
    static constexpr int mod = 1000000007;
    
public:
    int rearrangeSticks(int n, int k) &#123;
        vector&lt;int&gt; f(k + 1);
        f[0] = 1;
        for (int i = 1; i &lt;= n; ++i) &#123;
            vector&lt;int&gt; g(k + 1);
            for (int j = 1; j &lt;= k; ++j) &#123;
                g[j] = ((long long)f[j] * (i - 1) % mod + f[j - 1]) % mod;
            &#125;
            f = move(g);
        &#125;
        return f[k];
    &#125;
&#125;;
</code></pre>
<p>转换为斯特林数：<code>n</code> 个数划分为 <code>k</code> 部分，每部分固定第一个数是被看到的，剩下的任意排列。假设长为 <code>m</code>，最大的数固定，一共 $(m-1)!$ 种，联系上圆排列了，那么答案就是 <code>n</code> 的排列划分成 <code>k</code> 个非空圆排列的方案数（代码同上面的）</p>
<h4 id="第二类斯特林数"><a href="#第二类斯特林数" class="headerlink" title="第二类斯特林数"></a>第二类斯特林数</h4><p>代码</p>
<pre><code class="cpp">int S[N][N];
int cal(int N, int K) &#123;
    S[0][0] = 1;
    for(int n = 1; n &lt;= N; n ++)
        for(int k = 1; k &lt;= K; k++)
        S[n][k] = (S[n - 1][k - 1] + (LL)k * S[n - 1][k] % md) % md;
     return S[N][K];
 &#125;
</code></pre>
<h4 id="262144"><a href="#262144" class="headerlink" title="262144"></a>262144</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3147">https://www.luogu.com.cn/problem/P3147</a><br>给 <code>n</code> 个数<code>（2&lt;=n&lt;=262144）</code>，范围 <code>1-40</code>，可以把两个相邻的相同数 <code>x</code> 合并成 <code>x+1</code>，问最终得到的数最大是多少</p>
</blockquote>
<p>区间 DP？但这个范围不行啊，而且这个范围也太奇怪了</p>
<p>秘密在于 <code>262144=2^18</code>，因此就算两两合并，最大能得到的数也只有 <code>58</code></p>
<p>根据 <code>58</code>，考虑一下作为 DP 的维度</p>
<p>定义 <strong><code>f[i][j]</code> 表示左端点是 <code>j</code>，能合并出 <code>i</code> 的右端点位置</strong>（注意是开区间，即 <code>[j,f[i][j])</code> 合并出 <code>i</code>）</p>
<p>为什么这么定义？转移时就知道了，要想合成 <code>i+1</code>，先合成 <code>i</code>，那么此时 <code>f[i][j]</code> 就可以作为左端点了，<code>f[i+1][j]=f[i][f[i][j]]</code>！其实就是一个倍增的思想，但这个状态设计很特别</p>
<pre><code class="cpp">for (int i = 1; i &lt;= n; i++) &#123;
        cin &gt;&gt; x;
        f[x][i] = i + 1;
    &#125;
    int res = 0;
    for (int i = 2; i &lt;= 58; i++) &#123;
        for (int j = 1; j &lt;= n; j++) &#123;
            if (!f[i][j]) &#123;
                f[i][j] = f[i - 1][f[i - 1][j]];
            &#125; 
            if (f[i][j]) &#123;
                res = i;
            &#125;
        &#125;
    &#125;
</code></pre>
<h3 id="计数-DP"><a href="#计数-DP" class="headerlink" title="计数 DP"></a>计数 DP</h3><h4 id="括号序列"><a href="#括号序列" class="headerlink" title="括号序列"></a>括号序列</h4><blockquote>
<p>给定括号字符串，添加最少括号使其变得合法，问方案数<br>两个结果是本质不同的是指存在某个位置一个结果是左括号，而另一个是右括号</p>
</blockquote>
<p>合法序列对应性质：（1）左右括号数量相等；（2）任意前缀左括号数不小于右括号数。<br>此题的重要性质：左右括号都是添加到原括号序列的空隙中的，假如左括号和右括号加入的空隙不同，互不影响；假如相同，则一定先放完右括号再放左括号（否则形成一对新的匹配括号，可以删去），方式唯一确定。<br>怎么做题？现在原来的基础上算出只加左括号的方案数，然后将原序列逆序，并左右互变，再求一遍只加左括号的方案数（相当于原来序列只加右括号）。<strong>这个思路很难想出来</strong>，正确性看题解或举例说明。<br><code>f[i][j]</code> 表示前 <code>i</code> 个字符中，左括号比右括号多 <code>j</code> 个的集合（<code>j&gt;=0</code>），属性存方案数。<br>转移：规定遇到右括号才能加（避免重复）。遇到左括号：<code>f[i][j]=f[i-1][j-1]</code>；遇到右括号：<code>f[i][j] = f[i-1][0] + f[i-1][1] + … + f[i-1][j] + f[i-1][j+1]</code>。<br>优化：利用类似多重背包的优化方法。<br>为什么答案是枚举 <code>i</code>？可以想成第一次算满足 <code>左&gt;=右</code>，第二次算满足 <code>右&gt;=左</code>，从小到大枚举到第一个非空集合就是取等的时候。<br>对为什么以右括号为分割点可以避免重复的解释：</p>
<blockquote>
<p>单独考虑添加左括号，若以右括号为分割点， 将整个序列进行分割，因为分割后的子串中均为左括号， 添加任意数目的左括号方案数均为一种，那么此时，我们仅需考虑添加不同数量的左括号的方案数即可。</p>
</blockquote>
<pre><code class="cpp">LL dp()
&#123;
    memset(f, 0, sizeof f);
    f[0][0] = 1;
    for (int i = 1; i &lt;= n; i++)
        if (str[i] == &#39;(&#39;) 
            for (int j = 1; j &lt;= n; j++)
                f[i][j] = f[i - 1][j - 1];
        else
        &#123;
            f[i][0] = ((LL)f[i - 1][0] + f[i - 1][1]) % MOD;
            for (int j = 1; j &lt;= n; j++) 
                f[i][j] = ((LL)f[i][j - 1] + f[i - 1][j + 1]) % MOD;
        &#125;
    
    for (int i = 0; i &lt;= n; i++) 
        if (f[n][i]) return f[n][i];
    return -1;
&#125;

    LL l = dp();
    reverse(str + 1, str + n + 1);
    for (int i = 1; i &lt;= n; i++)
        if (str[i] == &#39;(&#39;) str[i] = &#39;)&#39;;
        else str[i] = &#39;(&#39;;
    LL r = dp();
    printf(&quot;%d\n&quot;, l * r % MOD);
</code></pre>
<h4 id="活字印刷"><a href="#活字印刷" class="headerlink" title="活字印刷"></a>活字印刷</h4><blockquote>
<p>你有一套活字字模 <code>tiles</code>，其中每个字模上都刻有一个字母 <code>tiles[i]</code>。返回你可以印出的非空字母序列的数目。<br><strong>注意：</strong>本题中，每个活字字模只能使用一次。</p>
</blockquote>
<p>定义 <code>f[i][j]</code> 表示用前 <code>i</code> 种字符构造长为 <code>j</code> 的序列的方案数。集合划分：考虑第 <code>i</code> 种字符有 <code>cnt</code> 个</p>
<ul>
<li>不选：<code>f[i][j] = f[i-1][j]</code></li>
<li>枚举选 <code>k</code> 个，从 <code>j</code> 个位置中选 <code>k</code> 个出来，其余位置为用 <code>i-1</code> 种字符构造 <code>j-k</code> 的方案数</li>
</ul>
<pre><code class="cpp">const int N = 8;
int c[N][N];
class Solution &#123;
public:
    int numTilePossibilities(string tiles) &#123;
        for (int i = 0; i &lt; N; i++)
            for (int j = 0; j &lt;= i; j++)
                if (j == 0) c[i][j] = 1;
                else c[i][j] = c[i - 1][j] + c[i - 1][j - 1];

        unordered_map&lt;char, int&gt; cnt;
        for (char c: tiles) cnt[c] ++;
        int n = tiles.size(), m = cnt.size();
        int f[m + 1][n + 1];
        memset(f, 0, sizeof f);

        f[0][0] = 1;
        int i = 1;
        for (auto &amp;[_, t]: cnt) // 枚举第 i 个字符
        &#123;
            for (int j = 0; j &lt;= n; j++) // 枚举序列长度
                for (int k = 0; k &lt;= j &amp;&amp; k &lt;= t; k++) // 枚举选了几个
                    f[i][j] += f[i - 1][j - k] * c[j][k]; 
            i ++;
        &#125;
        return accumulate(f[m] + 1, f[m] + n + 1, 0);
    &#125;
&#125;;
</code></pre>
<h4 id="网格图上放积木"><a href="#网格图上放积木" class="headerlink" title="网格图上放积木"></a>网格图上放积木</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/991/problem/D">https://codeforces.com/contest/991/problem/D</a><br>输入一个 2 行 n(≤100) 列的棋盘。<br>用数字 0 表示空格子，大写字母 X 表示一开始就被占据的格子。<br>你有无数个 L 形状的积木，可以旋转，也就是如下 4 种形状：<br>XX   XX   0X   X0<br>X0   0X   XX   XX<br>积木只能放在空格子上（占据 3 个空格子），不能放在被占据的格子上。积木之间不能重叠。<br>问：最多可以往棋盘上放多少个积木？</p>
</blockquote>
<p>枚举到第 <code>i</code> 列时，看 <code>i-1</code> 列的情况进行转移，学习如何对摆放方式进行编码</p>
<pre><code class="cpp">int res = 0, pre = 0;
    for (int i = 0; i &lt; n; i++)
    &#123;
        int cur = (s1[i] == &#39;0&#39;) + (s2[i] == &#39;0&#39;);
        if (cur == 0) pre = 0;
        if (cur == 1) pre == 2 ? (res ++, pre = 0) : pre = 1;
        if (cur == 2) pre &gt; 0 ? (res ++, pre = (pre == 2 ? 1 : 0)) : pre = 2;
    &#125;
</code></pre>
<h3 id="状压-DP"><a href="#状压-DP" class="headerlink" title="状压 DP"></a>状压 DP</h3><h4 id="典中典：LCP-69-Hello-LeetCode"><a href="#典中典：LCP-69-Hello-LeetCode" class="headerlink" title="典中典：LCP 69. Hello LeetCode!"></a>典中典：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rMeRt2/">LCP 69. Hello LeetCode!</a></h4><h4 id="飞机降落"><a href="#飞机降落" class="headerlink" title="飞机降落"></a>飞机降落</h4><blockquote>
<p>有 <code>N</code> 架飞机准备降落到某个只有一条跑道的机场。<br>其中第 <code>i</code> 架飞机在 <code>Ti</code> 时刻到达机场上空，到达时它的剩余油料还可以继续盘旋 <code>Di</code> 个单位时间，即它最早可以于 <code>Ti</code> 时刻开始降落，最晚可以于 <code>Ti+Di</code> 时刻开始降落。<br>降落过程需要 <code>Li</code> 个单位时间。<br>一架飞机降落完毕时，另一架飞机可以立即在同一时刻开始降落，但是不能在前一架飞机完成降落前开始降落。<br>请你判断 <code>N</code> 架飞机是否可以全部安全降落。</p>
</blockquote>
<p>注意到我们摆好一个集合后，我们不关心集合内部怎么摆的，只关心终点的最小值是多少。基于这个可以用状压 dp。状态计算对应一个集合的划分，我们可以把“<code>f[i]</code> 根据第 <code>j</code> 个为 1 的二进制位放在最右边”作为一个划分条件，就可以不重不漏划分了。<br>把 <code>j</code> 拿出来分析发现，只要除了它剩下的集合结束时间最靠前，那它也可以最靠前。依据此就可以写代码了。</p>
<pre><code class="cpp">memset(f, 0x3f, sizeof f); // 初始化
f[0] = 0;
for (int i = 1; i &lt; 1 &lt;&lt; n; i++)
    for (int j = 0; j &lt; n; j++)
    &#123;
        int t = p[j].t, d = p[j].d, l = p[j].l;
        if (i &gt;&gt; j &amp; 1)
        &#123;
            int last = f[i - (1 &lt;&lt; j)];
            if (t + d &gt;= last)
                f[i] = min(f[i], max(last, t) + l);
        &#125;
    &#125;
</code></pre>
<h4 id="二进制表示子集"><a href="#二进制表示子集" class="headerlink" title="二进制表示子集"></a>二进制表示子集</h4><blockquote>
<p>[门店商品调配][<a target="_blank" rel="noopener" href="https://leetcode.cn/contest/zj-future2022/problems/NBCXIp/">https://leetcode.cn/contest/zj-future2022/problems/NBCXIp/</a>]<br>某连锁店开设了若干门店，门店间允许进行商品借调以应对暂时性的短缺。本月商品借调的情况记于数组 <code>distributions</code>，其中 <code>distributions[i] = [from,to,num]</code>，表示从 <code>from</code> 门店调配了 <code>num</code> 件商品给 <code>to</code> 门店。<br>若要使得每一个门店最终借出和借入的商品数量相同，请问至少还需要进行多少次商品调配。<br><strong>注意：</strong>一次商品调配以三元组 <code>[from, to, num]</code> 表示，并有 <code>from ≠ to</code> 且 <code>num &gt; 0</code>。</p>
</blockquote>
<p>假设拿一个二维坐标系，纵轴表示 <code>cnt[i]</code> ，借出表示正，借入表示负，就可以表示为一系列有正有负的矩形。<br>注意到借入借出平衡等价于$\sum cnt[i]&#x3D;0$。然后如果某些矩形的$\sum cnt&#x3D;0$，就成为了一个子问题，这就启发我们递归解决子问题。<br>定义 <code>dp[i]</code> 表示集合 <code>i</code> 通过调配后所有元素值均为 0 的方案，属性存储最少调配次数。由于数据范围很小，就可以考虑二进制表示子集。假设 <code>i</code> 的子集为 <code>j</code> ，那么补集就是 <code>i^j</code> ，如果 <code>sum[j]=0</code> ，就可以转移。<br><code>dp[i]</code> 的最大值是多少？极端情况下从一个大的值分给其它所有小的值，那么 <code>dp[i]</code> 就是集合 <code>i</code> 的大小减 1。<br>转移方程就是 <code>dp[i]=min(dp[i], dp[j] + dp[i^j])</code> 。<br>如果 <code>sum[i] != 0</code> ，不合法，令 <code>dp[i] = INF</code> 。<br>时间复杂度为$O(n^3)$，分析这个复杂度需要数学技巧，具体看 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1sT411g7Fq/?spm_id_from=333.788&vd_source=903a79110472f9690e357084331a688c">视频</a>。</p>
<pre><code class="cpp">const int N = 12, M = 1 &lt;&lt; 12;
class Solution &#123;
public:
    int minTransfers(vector&lt;vector&lt;int&gt;&gt;&amp; distributions) &#123;
        int cnt[N] = &#123;&#125;;
        for (auto&amp; d: distributions)
        &#123;
            cnt[d[0]] -= d[2];
            cnt[d[1]] += d[2];
        &#125;
        
        int f[M] = &#123;&#125;;
        for (int i = 1; i &lt; M; i++)
        &#123;
            int sum = 0;
            for (int j = 0; j &lt; N; j++)
                if (i &gt;&gt; j &amp; 1) sum += cnt[j];
            if (sum) 
                f[i] = INT_MAX / 2; // 元素和不为 0 非法
            else
            &#123;
                f[i] = __builtin_popcount(i) - 1; // 最大值
                for (int j = (i - 1) &amp; i; j; j = (j - 1) &amp; i) // 枚举非空真子集
                    f[i] = min(f[i], f[j] + f[i ^ j]); 
                      // 没有考虑 f[j] + f[i ^ j] 是否合法 因为不合法置成 INT_MAX / 2 
                      // 既不会溢出 取 min 的时候也不会取到
            &#125;
        &#125;
        return f[M - 1];
    &#125;
&#125;;
</code></pre>
<p>暴搜代码</p>
<pre><code class="cpp">class Solution &#123;
public:
    int minTransfers(vector&lt;vector&lt;int&gt;&gt;&amp; distributions) &#123;
        int cnt[12] = &#123;&#125;;
        for (auto&amp; d: distributions)
        &#123;
            cnt[d[0]] -= d[2];
            cnt[d[1]] += d[2];
        &#125;
        vector&lt;int&gt; a, b;
        for (int x: cnt)
            if (x &gt; 0) a.push_back(x);
            else if (x &lt; 0) b.push_back(-x);
        
        int res = 1e9;
        function&lt;void(int)&gt; dfs = [&amp;](int op)
        &#123;
            if (op &gt; res) return; // 剪枝
            bool f = true;
            for (int x: a) if (x) f = false;
            if (f)
            &#123;
                res = min(res, op);
                return;
            &#125;
            // 每次找出最小值 把它填补到另一个数组中
            int mn = 1e9, t = 0, idx = 0;
            for (int i = 0; i &lt; a.size(); i++)
                if (a[i] &gt; 0 &amp;&amp; a[i] &lt; mn) mn = a[i], t = 0, idx = i;
            for (int i = 0; i &lt; b.size(); i++) 
                if (b[i] &gt; 0 &amp;&amp; b[i] &lt; mn) mn = b[i], t = 1, idx = i;
            
            if (t == 0)
            &#123;
                a[idx] -= mn;
                for (int i = 0; i &lt; b.size(); i++)
                    if (b[i] &gt; 0)
                    &#123;
                        b[i] -= mn;
                        dfs(op + 1);
                        b[i] += mn;
                    &#125;
                a[idx] += mn;
            &#125;
            else
            &#123;
                b[idx] -= mn;
                for (int i = 0; i &lt; a.size(); i++)
                    if (a[i] &gt; 0)
                    &#123;
                        a[i] -= mn;
                        dfs(op + 1);
                        a[i] += mn;
                    &#125;
                b[idx] += mn;
            &#125;
        &#125;;
        
        dfs(0);
        return res;
    &#125;
&#125;;
</code></pre>
<h4 id="最小必要团队"><a href="#最小必要团队" class="headerlink" title="最小必要团队"></a>最小必要团队</h4><blockquote>
<p>作为项目经理，你规划了一份需求的技能清单 <code>req_skills</code>，并打算从备选人员名单 <code>people</code> 中选出些人组成一个「必要团队」（ 编号为 <code>i</code> 的备选人员 <code>people[i]</code> 含有一份该备选人员掌握的技能列表）。<br>所谓「必要团队」，就是在这个团队中，对于所需求的技能列表 <code>req_skills</code> 中列出的每项技能，团队中至少有一名成员已经掌握。可以用每个人的编号来表示团队中的成员：</p>
<ul>
<li>例如，团队 <code>team = [0, 1, 3]</code> 表示掌握技能分别为 <code>people[0]</code>，<code>people[1]</code>，和 <code>people[3]</code> 的备选人员。<br>  请你返回 <strong>任一</strong> 规模最小的必要团队，团队成员用人员编号表示。你可以按 <strong>任意顺序</strong> 返回答案，题目数据保证答案存在。</li>
</ul>
</blockquote>
<p>两种角度：</p>
<p>用人去更新状态：</p>
<pre><code class="cpp">class Solution &#123;
public:
    vector&lt;int&gt; smallestSufficientTeam(vector&lt;string&gt;&amp; req_skills, vector&lt;vector&lt;string&gt;&gt;&amp; people) &#123;
        int n = req_skills.size(), m = people.size();
        unordered_map&lt;string, int&gt; idx;
        for (int i = 0; i &lt; n; i++) idx[req_skills[i]] = i;

        vector&lt;vector&lt;int&gt;&gt; f(1 &lt;&lt; n);
        for (int i = 0; i &lt; m; i++)
        &#123;
            int cur = 0;
            for (string&amp; s: people[i]) cur |= (1 &lt;&lt; idx[s]);

            for (int pre = 0; pre &lt; (1 &lt;&lt; n); pre++)
            &#123;
                if (pre &gt; 0 &amp;&amp; f[pre].empty()) continue;

                int comb = pre | cur;
                if (comb == pre) continue;

                if (f[comb].empty() || f[pre].size() + 1 &lt; f[comb].size())
                &#123;
                    f[comb] = f[pre];
                    f[comb].push_back(i);
                &#125;
            &#125;
        &#125;
        return f[(1 &lt;&lt; n) - 1];
    &#125;
&#125;;
</code></pre>
<p>用状态去更新状态</p>
<pre><code class="cpp">class Solution &#123;
public:
    typedef long long LL;
    vector&lt;int&gt; smallestSufficientTeam(vector&lt;string&gt;&amp; req_skills, vector&lt;vector&lt;string&gt;&gt;&amp; people) &#123;
        int m = req_skills.size();
        unordered_map&lt;string, int&gt; idx;
        for (int i = 0; i &lt; m; i++) idx[req_skills[i]] = i;

        int n = people.size(), mask[n];
        memset(mask, 0, sizeof mask);
        for (int i = 0; i &lt; n; i++)
            for (auto&amp; s: people[i])
                mask[i] |= (1 &lt;&lt; idx[s]);
            
        int u = 1 &lt;&lt; m;
        LL all = (1LL &lt;&lt; n) - 1, f[u];
        for (int i = 0; i &lt; u; i++) f[i] = all;
        f[0] = 0;
        for (int j = 0; j &lt; u - 1; j++) // f[u - 1] 无需计算
            if (f[j] &lt; all) // f[j] == all 说明这个状态还是初始值 即它还没被更新过
                for (int i = 0; i &lt; n; i++)
                    if (__builtin_popcountll(f[j]) + 1 &lt; __builtin_popcountll(f[j | mask[i]]))
                    f[j | mask[i]] = f[j] | (1LL &lt;&lt; i);
        
        LL ans = f[u - 1];
        vector&lt;int&gt; res;
        for (int i = 0; i &lt; n; i++)
            if ((ans &gt;&gt; i) &amp; 1) res.push_back(i);
        return res;
    &#125;
&#125;;
</code></pre>
<h4 id="排列型状压-DP"><a href="#排列型状压-DP" class="headerlink" title="排列型状压 DP"></a>排列型状压 DP</h4><blockquote>
<p>给数组 <code>a</code> 和 <code>b</code>，固定 <code>a</code>，<code>b</code> 可以任意排列，求 <code>a</code> 和 <code>b</code> 对应项异或值之和的最小值</p>
</blockquote>
<p>通过状压 DP 把枚举全排列的复杂度降至 $n*2^n$</p>
<p>设 <code>mask</code> 表示选了 <code>b</code> 中哪些数，假设 <code>mask</code> 中有 <code>s</code> 个 <code>1</code>，然后枚举 <code>mask</code> 中哪个数与 <code>a[s-1]</code> 进行匹配</p>
<pre><code class="cpp">for (int i = 1; i &lt; 1 &lt;&lt; n; i++)
        &#123;
            int s = __builtin_popcount(i);
            for (int j = 0; j &lt; n; j++)
                if (i &gt;&gt; j &amp; 1)
                    f[i] = min(f[i], f[i - (1 &lt;&lt; j)] + (nums1[s - 1] ^ nums2[j]));
        &#125;
</code></pre>
<h4 id="P1357-花园（环形、矩阵）"><a href="#P1357-花园（环形、矩阵）" class="headerlink" title="P1357 花园（环形、矩阵）"></a><strong>P1357 花园（环形、矩阵）</strong></h4><blockquote>
<p>环形的数组，元素要么是 <code>C</code> 要么是 <code>P</code>，要求相邻 <code>m</code> 个元素中，<code>C</code> 不超过 <code>k</code> 个<br><code>n</code> 为 <code>1e15</code>，<code>m,k&lt;5</code></p>
</blockquote>
<ul>
<li><p>用状压表示相邻 <code>m</code> 个的状态，有 <code>1&lt;&lt;m</code> 个</p>
</li>
<li><p>转移方程，当前为 <code>i</code></p>
<ul>
<li>滑出窗口的是 0，那么上个状态就是 <code>i&gt;&gt;1</code></li>
<li>滑出窗口的是 1，上个状态就是 <code>(i&gt;&gt;1)|(1&lt;&lt;(m-1))</code>，当然，需要判断这个状态是否合法</li>
</ul>
</li>
<li><p><strong>（重点）</strong>环的处理：由于花园是环形的，所以 <code>1~m</code> 号花圃会对 <code>n-m+2~n</code> 号花圃产生影响。为了确定产生的到底是什么样的影响，我们就需要枚举 <code>1~m</code> 号花圃的状态，对每种状态进行一次递推。设 <code>1~m</code> 号花圃的状态为 <code>s</code>，则最终答案就是 <code>f(n+m,s)</code></p>
</li>
<li><p>转移矩阵怎么构造：根据转移方程来，<strong>如果 <code>i-&gt;j</code>，那么 <code>a[i][j]=1</code>，这个很实用！</strong></p>
</li>
<li><p>细节：原来是要枚举初始状态嘛，现在用矩阵，就令 <code>f[0][0]=f[1][1]=...=1</code>，这个就是个单位矩阵，<code>f*a</code> 还是等于 <code>a</code>，那么最后只需要累加 <code>a[i][i]</code> 就是答案了</p>
</li>
</ul>
<pre><code class="cpp">int res = 0;
    // n 在 1e5 时的做法
    // for (int st = 0; st &lt; 1 &lt;&lt; m; st++) &#123;
    //     if (__builtin_popcount(st) &gt; k) &#123;
    //         continue;
    //     &#125;
    //     memset(f, 0, sizeof(f));
    //     f[0][st] = 1;
    //     for (int i = 1; i &lt;= n; i++) &#123;
    //         for (int j = 0; j &lt; 1 &lt;&lt; m; j++) &#123;
    //             f[i][j] = f[i - 1][j &gt;&gt; 1];
    //             int last = (j &gt;&gt; 1) | (1 &lt;&lt; (m - 1));
    //             if (__builtin_popcount(last) &lt;= k) &#123;
    //                 f[i][j] = (f[i][j] + f[i - 1][last]) % MOD;
    //             &#125;
    //         &#125;
    //     &#125;
    //     res = (res + f[n][st]) % MOD;
    // &#125;
    // cout &lt;&lt; res &lt;&lt; endl;
    vector&lt;vector&lt;int&gt;&gt; a(1 &lt;&lt; m, vector&lt;int&gt;(1 &lt;&lt; m));
    for (int i = 0; i &lt; 1 &lt;&lt; m; i++) &#123;
        if (__builtin_popcount(i) &gt; k) &#123;
            continue;
        &#125;
        int j = i &gt;&gt; 1;
        a[j][i] = 1; // j -&gt; i
        j = (i &gt;&gt; 1) | (1 &lt;&lt; (m - 1));
        if (__builtin_popcount(j) &lt;= k) &#123;
            a[j][i] = 1; // j -&gt; i
        &#125;
    &#125;
    auto ans = qmi(a, n);
    for (int i = 0; i &lt; 1 &lt;&lt; m; i++) &#123;
        res = (res + ans[i][i]) % MOD;
    &#125;
    cout &lt;&lt; res &lt;&lt; endl;
</code></pre>
<h4 id="统计无向图中的简单环"><a href="#统计无向图中的简单环" class="headerlink" title="统计无向图中的简单环"></a>统计无向图中的简单环</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/11/D">https://codeforces.com/problemset/problem/11/D</a><br>求无向图中的简单环个数，保证不存在重边和自环。<br>简单环：除起点外，其余的点都只出现一次的回路。<br>点数最多是 <code>19</code></p>
</blockquote>
<p>数据范围小-&gt; 没有多项式时间解法</p>
<p>设计 <code>f[k][i]</code> 表示当前考虑的点集为 <code>k</code>，当前点为 <code>i</code> 时，起点到 <code>i</code> 的简单路径数。<strong>为了不重复统计，人为规定起点是 <code>k</code> 中编号最小的点</strong>。枚举 <code>i</code> 的邻居 <code>j</code></p>
<ul>
<li>如果是起点，构成环</li>
<li>如果编号小于起点，不合法</li>
<li>否则，路径数从 <code>i</code> 转移到 <code>j</code></li>
</ul>
<p>细节：这种算法重复统计了</p>
<ul>
<li>所有的 <code>a-b</code> 边都被算成环，想想点集只有两个元素时的情况</li>
<li>所有简单环都被统计了两次，想想固定 <code>k</code> 时，从 <code>s-i-j</code> 的路径被记录，但是从 <code>j-i-s</code> 的路径也会被记录</li>
</ul>
<pre><code class="cpp">for (int i = 0; i &lt; n; i++) &#123;
        f[1 &lt;&lt; i][i] = 1;
    &#125;
    for (int k = 1; k &lt; 1 &lt;&lt; n; k++) &#123;
        for (int i = 0; i &lt; n; i++) &#123;
            if (f[k][i] == 0) &#123;
                continue;
            &#125;
            for (int j = 0; j &lt; n; j++) &#123;
                if (!g[i][j] || (k &amp; -k) &gt; (1 &lt;&lt; j)) &#123;
                    continue; // 不连通或者小于起点
                &#125;
                if (k &amp; 1 &lt;&lt; j) &#123; // 这个点在点集内
                    if ((k &amp; -k) == (1 &lt;&lt; j)) &#123; // 如果是起点
                        res += f[k][i];
                    &#125;
                &#125; else &#123;
                    f[k | (1 &lt;&lt; j)][j] += f[k][i]; // 路径数转移
                &#125;
            &#125;
        &#125;
    &#125;
    cout &lt;&lt; (res - m) / 2 &lt;&lt; endl;
</code></pre>
<h4 id="偶像出列！"><a href="#偶像出列！" class="headerlink" title="偶像出列！"></a>偶像出列！</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3694">https://www.luogu.com.cn/problem/P3694</a><br>有 <code>n</code> 个偶像来自 <code>m</code> 个乐队，要求重新排列，使得同一乐队的站到一起。方式是，让一部分人出列，然后任意插回到空位中，问最少出列几人<br><code>n</code> 的范围是 <code>1e5</code>，<code>m</code> 的范围是 <code>20</code></p>
</blockquote>
<p>不难，积累下思路</p>
<p><img src="https://gcore.jsdelivr.net/gh/Ricky-Daxia/Hei_Xiu/202407141603639.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/Ricky-Daxia/Hei_Xiu/202407141603639.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<h3 id="DP-构造"><a href="#DP-构造" class="headerlink" title="DP + 构造"></a>DP + 构造</h3><h4 id="最短公共超序列"><a href="#最短公共超序列" class="headerlink" title="最短公共超序列"></a>最短公共超序列</h4><blockquote>
<p>给你两个字符串 <code>str1</code> 和 <code>str2</code>，返回同时以 <code>str1</code> 和 <code>str2</code> 作为 <strong>子序列</strong> 的最短字符串。如果答案不止一个，则可以返回满足条件的 <strong>任意一个</strong> 答案。<br>如果从字符串 <code>t</code> 中删除一些字符（也可能不删除），可以得到字符串 <code>s</code> ，那么 <code>s</code> 就是 <code>t</code> 的一个子序列。</p>
</blockquote>
<p>预处理出 LCS 数组后，用双指针来构造</p>
<ul>
<li>如果 <code>i</code> <code>j</code> 其一走完，那么剩余字符加到答案中</li>
<li><code>f[i][j] = f[i-1][j-1]</code> 且 <code>s[i]=t[j]</code> 时，<code>i</code> <code>j</code> 同时后移</li>
<li>否则就看移 <code>i</code> 还是 <code>j</code>，或者任取其一</li>
</ul>
<pre><code class="cpp">class Solution &#123;
public:
    string shortestCommonSupersequence(string s, string t) &#123;
        int n = s.size(), m = t.size(), f[n + 1][m + 1];
        memset(f, 0, sizeof f);
        for (int i = 1; i &lt;= n; i++)
            for (int j = 1; j &lt;= m; j++)
                if (s[i - 1] == t[j - 1]) f[i][j] = f[i - 1][j - 1] + 1;
                else f[i][j] = max(f[i - 1][j], f[i][j - 1]);
        
        string res;
        int i = n, j = m;
        s = &quot; &quot; + s, t = &quot; &quot; + t;
        while (i &gt; 0 || j &gt; 0)
        &#123;
            if (i == 0) res += t[j --];
            else if (j == 0) res += s[i --];
            else
            &#123;
                if (s[i] == t[j])
                &#123;
                    res += s[i];
                    i --, j --;
                &#125;
                else if (f[i][j] == f[i - 1][j]) // 思考下为什么
                    res += s[i --];
                else res += t[j --];
            &#125;
        &#125;
        reverse(res.begin(), res.end());
        return res;
    &#125;
&#125;;
</code></pre>
<h3 id="状态机-DP"><a href="#状态机-DP" class="headerlink" title="状态机 DP"></a>状态机 DP</h3><h4 id="问长为-n-的串，含有-l-e-e-t，问方案数"><a href="#问长为-n-的串，含有-l-e-e-t，问方案数" class="headerlink" title="问长为 n 的串，含有 l e e t，问方案数"></a>问长为 n 的串，含有 <code>l</code> <code>e</code> <code>e</code> <code>t</code>，问方案数</h4><p>维护 <code>f(i,l,e,t)</code> 表示长为 <code>i</code>，至少含 <code>i</code> 个 <code>i</code>，<code>e</code> 个 <code>e</code>，<code>t</code> 个 <code>t</code> 的方案数，转移方程为</p>
<pre><code class="cpp">// 下一个字符填写除了 l, e, t 以外的 23 个字母
f(i + 1, l, e, t) += f(i, l, e, t) * 23;
// 下一个字符填写 l
// 这里用 min 限制 l 的范围是因为只要有至少一个 l 就是好字符串，我们不关心具体有几个 l
f(i + 1, min(1, l + 1), e, t) += f(i, l, e, t);
// 下一个字符填写 e
f(i + 1, l, min(2, e + 1), t) += f(i, l, e, t);
// 下一个字符填写 t
f(i + 1, l, e, min(1, t + 1)) += f(i, l, e, t);
</code></pre>
<p>答案为</p>
<pre><code class="cpp">class Solution &#123;
public:
    int stringCount(int n) &#123;
        LL f[n + 1][2][3][2];
        memset(f, 0, sizeof f);
        f[0][0][0][0] = 1;
        for (int i = 0; i &lt; n; i++)
            for (int j = 0; j &lt; 2; j++)
                for (int k = 0; k &lt; 3; k++)
                    for (int l = 0; l &lt; 2; l++)
                    &#123;
                        f[i + 1][j][k][l] = (f[i + 1][j][k][l] + f[i][j][k][l] * 23) % MOD;
                        f[i + 1][min(j + 1, 1)][k][l] = (f[i + 1][min(j + 1, 1)][k][l] + f[i][j][k][l]) % MOD;
                        f[i + 1][j][min(k + 1, 2)][l] = (f[i + 1][j][min(k + 1, 2)][l] + f[i][j][k][l]) % MOD;
                        f[i + 1][j][k][min(l + 1, 1)] = (f[i + 1][j][k][min(l + 1, 1)] + f[i][j][k][l]) % MOD;
                    &#125;
        return f[n][1][2][1];
    &#125;
&#125;;
</code></pre>
<h4 id="基于状态机的-7-进制状压——魔法棋盘"><a href="#基于状态机的-7-进制状压——魔法棋盘" class="headerlink" title="基于状态机的 7 进制状压——魔法棋盘"></a>基于状态机的 7 进制状压——魔法棋盘</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/1ybDKD/description/">LCP 76. 魔法棋盘 - 力扣（LeetCode）</a><br>棋盘上有空格、黑棋、红棋和问号四种，问号可以填入前三种，不产生冲突的填法有多少种（<code>n*m&lt;=30</code>）<br>产生冲突的定义：两颗不同颜色的棋子，在同一行或同一列；且之间恰好有一颗棋子（可以有空位）</p>
</blockquote>
<p>从简单的情况入手，只有一行，且没有空格子，怎么填？关键的观察：当前能不能放取决于最后两个棋子的状态，因此可以归纳出 7 种状态：</p>
<blockquote>
<ul>
<li>X，表示空，可放 R 或 B</li>
<li>R，只有一个 R，此时可放 R 或 B，形成 RR 或 RB</li>
<li>B，同理形成 BB 或 BR</li>
<li>RR，只能放 R</li>
<li>BB，只能放 B</li>
<li>RB，只能放 R</li>
<li>BR，只能放 B</li>
</ul>
</blockquote>
<p>状态迁移就可以用状态机来表示，接下来考虑怎么 DP</p>
<p>用 <code>f[i][j][col_states][row_state]</code> 表示<strong>当前正在</strong>考虑第 <code>i</code> 行第 <code>j</code> 列，所有列的状态表示为 <code>col_states</code>，是 <code>7</code> 进制数，当前行的状态为 <code>row_state</code></p>
<p>每次更新时基于当前状态和状态机去更新</p>
<p>具体来说，分析得到 <code>min(n,m)&lt;=5</code>，如果 <code>n&lt;m</code>，就把 <code>n</code> 和 <code>m</code> 互换。然后枚举每一个位置，对每一个位置，都枚举 <code>col_states</code> 和 <code>row_state</code>，把 <code>col_states</code> 中当前列的信息取出来，枚举这一个格子填什么，并判断是否可以填这个，如果可以，计算新的行列状态，然后更新 <code>f[ni][nj]</code>。这里如果 <code>nj</code> 超过边界，就跳到下一行的第 <code>0</code> 个位置，这样最后计算答案时就考虑 <code>f[n][0]</code> 即可</p>
<pre><code class="cpp">class Solution &#123;
public:
    long long getSchemeCount(int n, int m, vector&lt;string&gt;&amp; a) &#123;
        if (n &lt; m) &#123;
            vector&lt;string&gt; b(m);
            for (int i = 0; i &lt; n; i++)
                for (int j = 0; j &lt; m; j++) b[j].push_back(a[i][j]);
            a = std::move(b);
            swap(n, m);
        &#125;
        int X = 0, R = 1, B = 2, R2 = 3, B2 = 4, RB = 5, BR = 6;
        int g[7][7];
        memset(g, -1, sizeof g);
        for (int i = 0; i &lt; 7; i++) g[i][0] = i; // 放空格
        g[X][R] = R;
        g[X][B] = B;
        g[R][R] = R2;
        g[B][B] = B2;
        g[R][B] = RB;
        g[B][R] = BR;
        g[R2][R] = R2;
        g[B2][B] = B2;
        g[RB][R] = BR;
        g[BR][B] = RB;
        
        int tot = 1;
        for (int i = 0; i &lt; m; i++) tot *= 7;
        LL f[n + 1][m + 1][tot][7];
        memset(f, 0, sizeof f);
        f[0][0][0][0] = 1;
        
        for (int i = 0; i &lt; n; i++)
            for (int j = 0; j &lt; m; j++) &#123;
                int cur = -1;
                if (a[i][j] == &#39;R&#39;) cur = R;
                if (a[i][j] == &#39;B&#39;) cur = B;
                if (a[i][j] == &#39;.&#39;) cur = X;
                // 当前状态更新往右一格（如果达到边界就进入下一行）
                int ni = i, nj = j + 1; 
                if (nj == m) ni ++, nj = 0;
                
                int base = 1;
                for (int k = 0; k &lt; j; k++) base *= 7;
                for (int col_sts = 0; col_sts &lt; tot; col_sts++) &#123;
                    int col_st = col_sts / base % 7;
                    for (int row_st = 0; row_st &lt; 7; row_st++) &#123;
                        for (int nxt = 0; nxt &lt; 3; nxt++) 
                            if (cur == -1 || cur == nxt)
                                if (g[col_st][nxt] != -1 &amp;&amp; g[row_st][nxt] != -1) &#123;
                                    int new_col_st = col_sts + (g[col_st][nxt] - col_st) * base;
                                    int new_row_st = g[row_st][nxt];
                                    if (ni != i) new_row_st = 0;
                                    f[ni][nj][new_col_st][new_row_st] += f[i][j][col_st][row_st];
                                &#125;
                    &#125;
                &#125;
            &#125;
            
        LL res = 0;
        for (int col_st = 0; col_st &lt; tot; col_st++)
            res += f[n][0][col_st][0];
        return res;
    &#125;
&#125;;
</code></pre>
<h3 id="SOS-DP"><a href="#SOS-DP" class="headerlink" title="SOS-DP"></a>SOS-DP</h3><h4 id="求-a-i-a-j-a-i-a-j-的数对数"><a href="#求-a-i-a-j-a-i-a-j-的数对数" class="headerlink" title="求 a[i]+a[j]&#x3D;a[i]^a[j] 的数对数"></a>求 a[i]+a[j]&#x3D;a[i]^a[j] 的数对数</h4><p>可以想到，当前位为 <code>0</code> 的话，对应位置可以是 <code>0</code> 或 <code>1</code>；当前位为 <code>1</code> 的话，对应位置只能是 <code>0</code></p>
<p>反转一下，把这一位为 <code>0</code> 的加到为 <code>1</code> 的统计值中，最后求 <code>a[i]</code> 对应的数对时，把 <code>a[i]</code> 异或 <code>mask</code> 反转一下</p>
<p>这个做法实际上叫做 <strong>高维前缀和（SOSDP）</strong>，一般用于子集求和类问题，当然它不止可以求前缀和，前缀积，前缀 <code>max</code>，前缀 <code>min</code> 都可以。这篇博客介绍得很清楚：<a target="_blank" rel="noopener" href="https://codeforces.com/blog/entry/45223">https://codeforces.com/blog/entry/45223</a></p>
<pre><code class="cpp">// S(mask,i) 表示 mask 子集中只有最右边 i 位与其不同的状态
// 从博客的树状图可以很容易理解这个 dp 的过程
for(int i=0;i&lt;w;++i)//依次枚举每个维度（从右边数起第几位）
&#123;
    for(int j=0;j&lt;(1&lt;&lt;w);++j)//求每个维度的前缀和
    &#123;
        if(j&amp;(1&lt;&lt;i))s[j]+=s[j^(1&lt;&lt;i)]; 
    &#125;
&#125;
</code></pre>
<pre><code class="cpp">for (int i = 0; i &lt; 20; i++)
        for (int j = 0; j &lt; 1 &lt;&lt; 20; j++)
            if (j &gt;&gt; i &amp; 1) sum[j] += sum[j ^ (1 &lt;&lt; i)];
    int msk = (1 &lt;&lt; 20) - 1;
    LL res = 0;
    for (int i = 1; i &lt;= n; i++) res += sum[a[i] ^ msk];
</code></pre>
<hr>
<h4 id="两道-SOS-DP-的经典题"><a href="#两道-SOS-DP-的经典题" class="headerlink" title="两道 SOS-DP 的经典题"></a>两道 SOS-DP 的经典题</h4><ol>
<li><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/arc100/tasks/arc100_c">https://atcoder.jp/contests/arc100/tasks/arc100_c</a></li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/Ricky-Daxia/Hei_Xiu/202407141607278.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/Ricky-Daxia/Hei_Xiu/202407141607278.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<pre><code class="cpp">PII merge(PII s, PII t)
&#123;
    if (s.x &lt; t.x) swap(s, t);
    PII res = s;
    if (t.x &gt; res.y) res.y = t.x;
    return res;
&#125;

    cin &gt;&gt; n;
    for (int i = 0; i &lt; 1 &lt;&lt; n; i++)
    &#123;
        cin &gt;&gt; x;
        a[i] = &#123;x, -INF&#125;;
    &#125;
    for (int j = 0; j &lt; n; j++)
        for (int i = 0; i &lt; 1 &lt;&lt; n; i++)
            if (i &gt;&gt; j &amp; 1) a[i] = merge(a[i], a[i ^ (1 &lt;&lt; j)]);
    int res = 0;
    for (int i = 1; i &lt; 1 &lt;&lt; n; i++)
    &#123;
        res = max(res, a[i].x + a[i].y);
        cout &lt;&lt; res &lt;&lt; endl;
    &#125;
</code></pre>
<ol>
<li><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1208/problem/F">https://codeforces.com/contest/1208/problem/F</a></li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/Ricky-Daxia/Hei_Xiu/202407141608005.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/Ricky-Daxia/Hei_Xiu/202407141608005.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<pre><code class="cpp">void add(int v, int id)
&#123;
    if (f[v].x == id || f[v].y == id) return;
    if (f[v].x == -1) f[v].x = id;
    else if (f[v].y == -1)
    &#123;
        f[v].y = id;
        if (f[v].x &lt; f[v].y) swap(f[v].x, f[v].y);
    &#125;
    else if (f[v].x &lt; id)
    &#123;
        f[v].y = f[v].x;
        f[v].x = id;
    &#125; 
    else if (f[v].y &lt; id) f[v].y = id;
&#125;

void merge(int A, int B)
&#123;
    add(A, f[B].x);
    add(A, f[B].y);
&#125;

    memset(f, -1, sizeof f);
    cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; i++)
    &#123;
        cin &gt;&gt; a[i];
        add(a[i], i);
    &#125;
    for (int i = 0; i &lt; 21; i++)
        for (int j = 0; j &lt; N; j++)
            if (j &gt;&gt; i &amp; 1) merge(j ^ (1 &lt;&lt; i), j); // 超集的做法和子集反过来
    int res = 0;
    for (int i = 1; i &lt;= n - 2; i++)
    &#123;
        int msk = (1 &lt;&lt; 21) - 1;
        int cur = a[i] ^ msk, mx = 0;
        for (int j = 20; j &gt;= 0; j--)
            if (cur &gt;&gt; j &amp; 1 &amp;&amp; f[mx ^ (1 &lt;&lt; j)].y &gt; i) 
                // 看是否存在两个大于 i 的位置 它们 &amp; 的结果为当前答案的超集
                mx |= 1 &lt;&lt; j;
        res = max(res, mx | a[i]);
    &#125;
    cout &lt;&lt; res &lt;&lt; endl;
</code></pre>
<h3 id="茶中-DP"><a href="#茶中-DP" class="headerlink" title="茶中 DP"></a>茶中 DP</h3><h4 id="数组划分为-k-段的最大的分"><a href="#数组划分为-k-段的最大的分" class="headerlink" title="数组划分为 k 段的最大的分"></a>数组划分为 k 段的最大的分</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/833/B">https://codeforces.com/problemset/problem/833/B</a><br>输入 n(1≤n≤35000) k(1≤k≤min(50,n)) 和长为 n 的数组 a(1≤a[i]≤n)。<br>你需要把 a 划分成 k 个非空连续段。<br>每段的得分 &#x3D; 这一段的不同元素个数。<br>输出这 k 段的得分之和的最大值。</p>
</blockquote>
<p><strong>提示 1</strong></p>
<p>先把这题做了 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/total-appeal-of-a-string/description/">字符串的总引力</a></p>
<p><strong>提示 2</strong></p>
<p>本题是划分型 DP，定义 f[k][i] 表示把前 i 个数分成 k 段的最大得分。</p>
<p>枚举第 k 段的开始位置 j，那么 f[k][i] &#x3D; max{f[k-1][j-1] + 从 j 到 i 的不同元素个数}</p>
<p><strong>提示 3</strong></p>
<p>在枚举 i 的同时，用 lazy 线段树维护如下序列的区间最大值（维护转移来源的最大值）：</p>
<p>序列的位置 L 维护着从 L 到 i 的不同元素个数，再加上 f[k-1][L-1]。这里的【加上 f[k-1][L-1]】在初始化线段树的时候完成。</p>
<p>遍历到 a[i] 时，把序列的下标 [pre+1,i] 内的数都 +1，这里 pre 是 a[i] 上一次出现的下标。</p>
<p>这样 f[k][i] 就等于线段树的 query(1,i) 了。</p>
<p><strong>答疑</strong>：题目要求子数组不能为空，为什么可以直接 query(1,i)？不应该给前面的子段留下一些位置吗？</p>
<p><strong>解答</strong>：没关系，分出来的子段越多，f 必然越大，query(1,i) 一定会取到分出 k 段的答案。</p>
<p>代码实现时，f 的第一个维度可以去掉，只需要一棵线段树。</p>
<p><strong>启发：希望在 logn 的时间内可以求出 [i,j] 的不同颜色个数，考虑它上一次出现的位置 pre[i]，就要给 [pre[i]+1,i] 都加上 1，这个区间加的操作就可以用线段树完成。难点在于需要建树 k 次，每次记录上次的 f 值</strong></p>
<pre><code class="cpp">cin &gt;&gt; n &gt;&gt; k;
    for (int i = 1; i &lt;= n; i++)
    &#123;
        cin &gt;&gt; v;
        pre[i] = p[v];
        p[v] = i;
    &#125;
    while (k -- )
    &#123;
        build(1, 1, n);
        for (int i = 1; i &lt;= n; i++)
        &#123;
            update(1, pre[i] + 1, i, 1);
            f[i] = query(1, 1, i);
        &#125;
    &#125;
    cout &lt;&lt; f[n] &lt;&lt; endl;
</code></pre>
<h4 id="图上-DP-新奇的维度设计"><a href="#图上-DP-新奇的维度设计" class="headerlink" title="图上 DP 新奇的维度设计"></a>图上 DP 新奇的维度设计</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/721/problem/C">https://codeforces.com/contest/721/problem/C</a><br>输入 n(2≤n≤5000) m(1≤m≤5000) maxT(1≤maxT≤1e9)。<br>然后输入 m 条边，每条边输入 v w t(1≤wt≤1e9)，表示有一条边权为 t 的有向边连接 v 和 w。节点编号从 1 开始。<br>保证输入的是一个有向无环图，并且没有重边。<br>求出从 1 到 n 的一条路径，要求路径长度（边权之和）不超过 maxT，在满足该条件的前提下，路径上的节点数最多。<br>输出两行，第一行是路径上的节点个数，第二行按顺序输出路径上的节点编号（第一个数必须是 1，最后一个数必须是 n）。<br>保证至少有一条满足要求的路径。</p>
</blockquote>
<p><strong>无需建图的 DP</strong></p>
<p>提示 1：把「经过了多少个点」作为额外的 DP 维度，把「最短长度」作为 DP 值。</p>
<p>提示 2：定义 f[i][w] 表示从 1 到 w，经过了 i+1 个点的最短长度。i 最大为 n-1。</p>
<p>初始值：f[0][1] &#x3D; 0，其余为无穷大。</p>
<p>状态转移方程：f[i][w] &#x3D; min(f[i-1][v]+t)，其中有向边 v-&gt;w 的边权为 t。</p>
<p>答案：最大的满足 f[i][n] &lt;&#x3D; maxT 的 i，再加一（注意 i 是从 0 开始的）。</p>
<p>提示 3：从转移方程可以看出，其实不需要建图，只需要循环 n-1 次，每次遍历这 m 条边，在遍历时计算状态转移。</p>
<p>这是因为 f[i][] 只依赖于 f[i-1][]，在把 f[i-1][] 算出来后，无论按照什么顺序遍历这 m 条边都是可以的。</p>
<p>提示 4：计算状态转移的时候，额外记录转移来源 from[i][w] &#x3D; v。</p>
<p>从 n 出发，顺着 from 数组回到 1，就得到了具体方案。具体请看代码。</p>
<pre><code class="cpp">cin &gt;&gt; n &gt;&gt; m &gt;&gt; T;
    for (int i = 0; i &lt; m; i++)
        cin &gt;&gt; es[i][0] &gt;&gt; es[i][1] &gt;&gt; es[i][2];
    for (int i = 0; i &lt; n; i++)
        for (int j = 1; j &lt;= n; j++) 
            f[i][j] = T + 1;
    f[0][1] = 0;
    int res = 0;
    for (int i = 1; i &lt; n; i++)
    &#123;
        for (int j = 0; j &lt; m; j++)
        &#123;
            int v = es[j][0], w = es[j][1], t = es[j][2];
            if (f[i - 1][v] + t &lt; f[i][w])
            &#123;
                f[i][w] = f[i - 1][v] + t;
                from[i][w] = v;
            &#125;
        &#125;
        if (f[i][n] &lt;= T) res = i;
    &#125;
    cout &lt;&lt; res + 1 &lt;&lt; endl;
    int v = n;
    for (int i = res; i &gt;= 0; i--)
    &#123;
        path[i] = v;
        v = from[i][v];
    &#125;
    for (int i = 0; i &lt;= res; i++) 
        cout &lt;&lt; path[i] &lt;&lt; &#39; &#39;;
</code></pre>
<h4 id="线性-DP-求方案数"><a href="#线性-DP-求方案数" class="headerlink" title="线性 DP 求方案数"></a>线性 DP 求方案数</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/404/problem/D">https://codeforces.com/contest/404/problem/D</a><br>输入一个长度在 [1,1e6] 内的字符串，由五种字符 *?012 组成，表示一个「一维扫雷游戏」的局面。<br>其中 * 表示雷，数字表示左右相邻位置有多少个雷。<br>把 ? 替换成 *012 中的一个，可以得到多少个合法的局面？模 1e9+7。</p>
</blockquote>
<p>状态比较多的线性 DP，自己做出来了，用了一个小时</p>
<p>初版是设置了 6 个状态，而后发现 1 和 3 可以合为一种情况，即“11”可以归到“01”这种情况中，不影响后面的计算（用有雷、没雷去思考似乎更好，就不用从字符是什么来思考）</p>
<p>当然，可以采用滚动数组优化</p>
<p>题解的代码太简洁了，有点难看懂，而且自己很难想出来，就不看了</p>
<pre><code class="cpp">/* origin
0:  0
1: 01
2: *1
3: 11
4:  2
5:  *
*/

/* new 
0:  0
1: 01
2: *1
3:  2
4:  *
*/
 
int main()
&#123;
    cin &gt;&gt; s;
    int n = s.size();
    switch (s[0]) &#123;
        case &#39;0&#39;: f[0][0] = 1; break;
        case &#39;1&#39;: f[0][1] = 1; break; // 不能写成 f[0][1] = f[0][3] = 1
        case &#39;2&#39;: break;
        case &#39;?&#39;: f[0][0] = f[0][1] = f[0][5] = 1; break;
        case &#39;*&#39;: f[0][5] = 1; break;
    &#125;
    for (int i = 1; i &lt; n; i++)
    &#123;
        char c = s[i];
        if (c == &#39;0&#39; || c == &#39;?&#39;) f[i][0] = (f[i - 1][0] + f[i - 1][2]) % MOD;
        if (c == &#39;1&#39; || c == &#39;?&#39;)
        &#123;
            f[i][1] = f[i - 1][0]; 
            f[i][2] = f[i - 1][5];
            f[i][3] = f[i - 1][2];
        &#125;
        if (c == &#39;2&#39; || c == &#39;?&#39;) f[i][4] = f[i - 1][5];
        if (c == &#39;*&#39; || c == &#39;?&#39;) f[i][5] = (f[i - 1][1] + f[i - 1][3] + f[i - 1][4] + f[i - 1][5]) % MOD;
    &#125;
    LL res = (f[n - 1][0] + f[n - 1][2] + f[n - 1][5]) % MOD;
    printf(&quot;%lld\n&quot;, res);
    return 0;
&#125;
// new
int main()
&#123;
    cin &gt;&gt; s;
    int n = s.size();
    switch (s[0]) &#123;
        case &#39;0&#39;: f[0][0] = 1; break;
        case &#39;1&#39;: f[0][1] = 1; break;
        case &#39;2&#39;: break;
        case &#39;?&#39;: f[0][0] = f[0][1] = f[0][4] = 1; break;
        case &#39;*&#39;: f[0][4] = 1; break;
    &#125;
    for (int i = 1; i &lt; n; i++)
    &#123;
        char c = s[i];
        if (c == &#39;0&#39; || c == &#39;?&#39;) f[i][0] = (f[i - 1][0] + f[i - 1][2]) % MOD;
        if (c == &#39;1&#39; || c == &#39;?&#39;)
        &#123;
            f[i][1] = (f[i - 1][0] + f[i - 1][2]) % MOD;
            f[i][2] = f[i - 1][4];
        &#125;
        if (c == &#39;2&#39; || c == &#39;?&#39;) f[i][3] = f[i - 1][4];
        if (c == &#39;*&#39; || c == &#39;?&#39;) f[i][4] = (f[i - 1][1] + f[i - 1][3] + f[i - 1][4]) % MOD;
    &#125;
    LL res = (f[n - 1][0] + f[n - 1][2] + f[n - 1][4]) % MOD;
    printf(&quot;%lld\n&quot;, res);
    return 0;
&#125;
</code></pre>
<h4 id="单调队列优化-DP"><a href="#单调队列优化-DP" class="headerlink" title="单调队列优化 DP"></a>单调队列优化 DP</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/487/B">https://codeforces.com/problemset/problem/487/B</a><br>输入 n(1≤n≤1e5) s(0≤n≤1e9) L(1≤n≤1e5) 和长为 n 的数组 a(-1e9≤a[i]≤1e9)。<br>你需要把 a 分割成若干段（连续子数组），满足：</p>
<ol>
<li>每段长度至少为 L。</li>
<li>每段的最大值减最小值 &lt;&#x3D; s。<br> 输出至少要把 a 分成多少段。<br> 如果无法做到，输出 -1。</li>
</ol>
</blockquote>
<p>考虑 DP，当子数组右端点固定时，左端点的最小值也是固定的。假如 [j,i] 的极差超过了 s，那么 [j-1,i] 的极差一定也超过 s，只需要维护一个决策点 c，如果 c 越大，f_c 不会变小，因此找到最小的合法 c 即可</p>
<p>如何优化求极差：i 和 c 都单增，考虑用单调队列来优化，当发现 最大值-最小值 &gt;s 时就移动窗口</p>
<pre><code class="cpp">int n, s, l, c; // 决策点 c
int f[N], a[N];
deque&lt;int&gt; mn, mx;

int query()
&#123;
    while (mn.size() &amp;&amp; mn.front() &lt;= c) mn.pop_front();
    while (mx.size() &amp;&amp; mx.front() &lt;= c) mx.pop_front();
    return a[mx.front()] - a[mn.front()];
&#125;

int main()
&#123;
    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;s, &amp;l);
    for (int i = 1; i &lt;= n; i++) 
    &#123;
        scanf(&quot;%d&quot;, &amp;a[i]);
        f[i] = INF;
    &#125;
    for (int i = 1; i &lt;= n; i++)
    &#123;
        while (mn.size() &amp;&amp; a[i] &lt; a[mn.back()]) mn.pop_back();
        mn.push_back(i);
        while (mx.size() &amp;&amp; a[i] &gt; a[mx.back()]) mx.pop_back();
        mx.push_back(i);
        if (i &gt;= l) 
        &#123;
            // 合法的 c 所以还要判断 f[c] == INF
            while (i - c &gt;= l &amp;&amp; (query() &gt; s || f[c] == INF)) c ++;
            if (i - c &gt;= l) f[i] = f[c] + 1;
        &#125;
    &#125;
    printf(&quot;%d\n&quot;, f[n] &gt;= INF ? -1 : f[n]);
    return 0;
&#125;
</code></pre>
<h4 id="DP-构造-1"><a href="#DP-构造-1" class="headerlink" title="DP + 构造"></a>DP + 构造</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/abc222/tasks/abc222_d">https://atcoder.jp/contests/abc222/tasks/abc222_d</a><br>输入 n(1≤n≤3000) 和两个长为 n 的数组 a b，元素范围在 [0,3000]，且均为递增数组（允许有相同元素）。<br>构造递增数组 c（允许有相同元素），满足 a[i]&lt;&#x3D;c[i]&lt;&#x3D;b[i]。<br>输出你能构造多少个不同的 c，模 998244353。</p>
</blockquote>
<p>有两种定义 DP 的方式。</p>
<p>定义 f[i][j] 表示考虑前 i 个数，其中第 i 个数填 j 的方案数</p>
<p>那么有 f[i][j] &#x3D; f[i-1][0] + f[i-1][1] + … + f[i-1][min(j, b[i-1])]</p>
<p>这可以用前缀和优化。</p>
<p>这启发我们，也可以直接定义 f[i][j] 表示考虑前 i 个数，其中第 i 个数填的数 &lt;&#x3D;j 的方案数。</p>
<p>考虑第 i 个数是否要填 j：</p>
<ul>
<li>不填，那就是第 i 个数填的数 &lt;&#x3D;j-1 的方案数，即 f[i][j] &#x3D; f[i][j-1]。</li>
<li>填，那么第 i-1 个数至多为 j，即 f[i][j] &#x3D; f[i-1][min(j, b[i-1])]。</li>
</ul>
<p>则有 f[i][j] &#x3D; f[i][j-1] + f[i-1][min(j, b[i-1])]。</p>
<p>初始值 f[0][j] &#x3D; j-a[0]+1，其中 a[0]&lt;&#x3D;j&lt;&#x3D;b[0]。</p>
<p>答案为 f[n-1][b[n-1]]。</p>
<pre><code class="cpp">int main()
&#123;
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;a[i]);
    for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;b[i]);
    for (int j = a[0]; j &lt;= b[0]; j++)
        f[0][j] = j - a[0] + 1;
    for (int i = 1; i &lt; n; i++)
        for (int j = a[i]; j &lt;= b[i]; j++)
            // 注意不要越界
            f[i][j] = (f[i][max(j - 1, 0)] + f[i - 1][min(j, b[i - 1])]) % mod;
    printf(&quot;%lld\n&quot;, f[n - 1][b[n - 1]]);
    return 0;
&#125;
</code></pre>
<h4 id="延迟-DP"><a href="#延迟-DP" class="headerlink" title="延迟 DP"></a>延迟 DP</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/diverta2019/tasks/diverta2019_e">https://atcoder.jp/contests/diverta2019/tasks/diverta2019_e</a><br>输入 n(1≤n≤5e5) 和长为 n 的数组 a(0≤a[i]&lt;2^20)。<br>把数组 a 划分成若干段<strong>连续子数组</strong>，一共有 2^(n-1) 种划分方案。<br>问：其中有多少种划分方案，可以让每段子数组的异或和都一样？<br>答案模 1e9+7。</p>
</blockquote>
<p>一眼 DP ，思考方向是计算前缀异或和数组，然后假设选定一些划分位置，异或和相同等价于 <code>s[0]^s[i0]=s[i0]^s[i1]=...=s[im]^s[n]</code> ，接着观察出 <code>s[0]=s[i1]=...</code> 以及 <code>s[i0]=s[i2]=...</code> 这个性质，那么转换为在前缀和数组中选择一个<strong>交替子序列</strong>，第一个数和最后一个数必选。</p>
<p>难点在于讨论 <code>s[n]</code> 的情况，对应如何转移，以及 <strong>延迟 DP</strong> ，代码上学习 <code>struct f[]</code> 的作用：统一两种情况的计算</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/endlesscheng/solution-at-diverta2019-e">https://www.luogu.com.cn/blog/endlesscheng/solution-at-diverta2019-e</a></p>
<pre><code class="cpp">struct &#123;
    int s0 = 1;
    int s1, pre0;
&#125; f[1 &lt;&lt; 20];
int n, v, sum;

int qmi(int a, int k)
&#123;
    int res = 1;
    while (k)
    &#123;
        if (k &amp; 1) res = (LL)res * a % MOD;
        a = (LL)a * a % MOD;
        k &gt;&gt;= 1;
    &#125;
    return res;
&#125;

int main()
&#123;
    int cnt0 = 1;
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 0; i &lt; n; i++)
    &#123;
        scanf(&quot;%d&quot;, &amp;v);
        sum ^= v;
        if (sum == 0) cnt0 ++;
        else
        &#123;
            auto &amp;t = f[sum];
            // 延迟计算两个 非零数 之间 0 的个数对应的转移
            t.s0 = (t.s0 + (LL)t.s1 * (cnt0 - t.pre0) % MOD) % MOD;
            t.s1 = (t.s0 + t.s1) % MOD;
            t.pre0 = cnt0;
        &#125;
    &#125;
    if (sum &gt; 0) printf(&quot;%d\n&quot;, f[sum].s0);
    else 
    &#123;
        int res = qmi(2, cnt0 - 2);
        for (int i = 0; i &lt; 1 &lt;&lt; 20; i++)
            // res = f[n][0] + sum(f[j][1])
            res = (res + f[i].s1) % MOD;
        printf(&quot;%d\n&quot;, res);
    &#125;
    return 0;
&#125;
</code></pre>
<h4 id="十进制-SOS-DP"><a href="#十进制-SOS-DP" class="headerlink" title="十进制 SOS DP"></a>十进制 SOS DP</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/arc136/tasks/arc136_d">https://atcoder.jp/contests/arc136/tasks/arc136_d</a><br>输入 n(2≤n≤1e6) 和长为 n 的数组 a(0≤a[i]&lt;1e6)。<br>输出满足【十进制加法 a[i]+a[j] 的每个数位都没有产生进位】的下标对 (i,j) 个数，其中 i&lt;j。</p>
</blockquote>
<p>举例，如果一个数和 666 相加不进位，那么与 665 相加也不会进位。</p>
<p>定义 y 是 x 的「十进制子集」，当且仅当 y 的所有数位都小于等于 x 对应的数位。例如 666,566,656,665,123,66 都是 666 的十进制子集。</p>
<p>定义 f[i] 表示 i 的十进制子集的个数。</p>
<p>为什么要这样定义？对于 a[i] 来说，999999-a[i] 的任意十进制子集与 a[i] 相加都不会进位，所以 f[999999-a[i]] 就是与 a[i] 相加不进位的数字个数。</p>
<p>枚举 i 的第 j 个数位，如果这个数位大于 0，那么</p>
<p>f[i] +&#x3D; f[i-pow(10,j)]</p>
<p>初始值：f[x] &#x3D; x 在数组 a 中的出现次数。</p>
<p>然后遍历 a[i]，把 f[999999-a[i]] 加到答案中。</p>
<p>如果 a[i]+a[i] 没有进位，那么我们多统计了一个答案，ans–。</p>
<p>最后把答案除以 2，因为 (a[i],a[j]) 和 (a[j],a[i]) 我们都统计了一次。</p>
<p>注：如果你之前学过二进制的 SOS DP，对于想出本题做法有帮助。</p>
<p>本题相当于是十进制的 SOS DP。</p>
<p>代码中先枚举数位再枚举每个数的目的是</p>
<blockquote>
<p>保证任意两个数之间只有一条路径，避免重复计算<br>例如：111 -&gt; 112 -&gt; 122 -&gt; 222 低位累加在高位累加之前<br>而不会通过 111 -&gt; 121 -&gt; 221 -&gt; 222 高低位混合累加 路径不唯一</p>
</blockquote>
<p>也可以理解成从固定左边，最右边第一位可变化；最右边两位可变化 …</p>
<pre><code class="cpp">int main()
&#123;
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 0; i &lt; n; i++)
    &#123;
        scanf(&quot;%d&quot;, &amp;a[i]);
        f[a[i]] ++;
    &#125;
    for (int i = 1; i &lt; 1e6; i *= 10)
        for (int j = 0; j &lt; 1e6; j++)
            if (j / i % 10 &gt; 0)
                f[j] += f[j - i];
    LL res = 0;
    for (int i = 0; i &lt; n; i++)
    &#123;
        res += f[999999 - a[i]];
        bool t = true;
        for (int j = 1; j &lt; 1e6; j *= 10)
            if (a[i] / j % 10 &gt;= 5) t = false;
        if (t) res --;
    &#125;
    printf(&quot;%lld\n&quot;, res / 2);
    return 0;
&#125;
</code></pre>
<h4 id="基础-DP-但要优化空间"><a href="#基础-DP-但要优化空间" class="headerlink" title="基础 DP 但要优化空间"></a>基础 DP 但要优化空间</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/abc248/tasks/abc248_c">https://atcoder.jp/contests/abc248/tasks/abc248_c</a><br>输入 n m(1≤n,m≤50) k(n≤k≤n*m)。<br>输出有多少个长为 n 的数组 a 满足 1≤a[i]≤m 且 sum(a)≤k。<br>模 998244353。</p>
</blockquote>
<p>f[i][j] 表示前 i 个数的元素和为 j 的方案数。i 从 1 开始。</p>
<p>f[i][j] &#x3D; f[i-1][j-1] + f[i-1][j-2] + … + f[i-1][max(j-m,0)]</p>
<p>初始值 f[0][0] &#x3D; 1。</p>
<p>答案为 sum(f[n])。</p>
<p>这种 DP 的空间优化版本不太会写</p>
<pre><code class="cpp">int main()
&#123;
    int n, m, k;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
    int f[k + 1];
    memset(f, 0, sizeof f);
    f[0] = 1;
    for (int i = n; i; i--)
        for (int j = k; j &gt;= 0; j--)
        &#123;
            f[j] = 0;
            for (int v = 1; v &lt;= m &amp;&amp; v &lt;= j; v++)
                f[j] = (f[j] + f[j - v]) % mod;
        &#125;
    LL res = 0;
    for (int i = 0; i &lt;= k; i++) res = (res + f[i]) % mod;
    cout &lt;&lt; res &lt;&lt; endl;
&#125;
</code></pre>
<h4 id="TSP-问题"><a href="#TSP-问题" class="headerlink" title="TSP 问题"></a>TSP 问题</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/abc301/tasks/abc301_e">https://atcoder.jp/contests/abc301/tasks/abc301_e</a><br>输入 n m(1≤n,m≤300) t(1≤t≤2e6) 和一个 n 行 m 列的网格图。<br>S 为起点（恰好一个）。<br>G 为终点（恰好一个）。<br>. 为空地。</p>
<p><code>#</code> 为墙壁。</p>
<p>o 为糖果（至多 18 个）。<br>你需要从起点走到终点。每一步可以上下左右四个方向走到相邻的非墙壁格子上，不能出界。<br><strong>你可以重复访问同一个格子。</strong><br>注：如果走到终点，可以继续走，只要最后在终点就行。<br>至多走 t 步。<br>输出你至多能收集多少个糖果（走到 o 即可收集，同一个格子只能收集一次）。<br>如果无法在 t 步内到达终点，输出 -1。<br><strong>相似题目：</strong><br>LCP 13. 寻宝</p>
</blockquote>
<p>计算每对 o 之间的最短距离，用 dis 数组记录。这一步可以用 BFS 解决。</p>
<p><strong>由于 o 至多有 18 个</strong>，可以转换成一个<strong>旅行商问题</strong>（请自行搜索），用状压 DP 解决。</p>
<p>定义 f[s][i] 表示已收集的 o 的下标集合为 s，且当前在第 i 个 o 时的最小移动步数。</p>
<p>枚举 s 的补集中的下标 j，用 f[s][i] + dis[i][j] 去更新 f[s|1&lt;&lt;j][j] 的最小值。</p>
<p>时间复杂度 O(knm+k^2*2^k)。</p>
<p>本题学习如何记录最短距离，如何用状压 DP 解 TSP 问题</p>
<pre><code class="cpp">int n, m, t, sx, sy, tx, ty;
vector&lt;PII&gt; ps;
char c[310][310];
int d[20][310][310];

int main()
&#123;
    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;t);
    for (int i = 0; i &lt; n; i++)
    &#123;
        scanf(&quot;%s&quot;, c[i]);
        for (int j = 0; j &lt; m; j++)
            if (c[i][j] == &#39;S&#39;) sx = i, sy = j;
            else if (c[i][j] == &#39;G&#39;) tx = i, ty = j;
            else if (c[i][j] == &#39;o&#39;) ps.push_back(&#123;i, j&#125;);
    &#125;
    ps.push_back(&#123;sx, sy&#125;);
    int cnt = ps.size();
    for (int i = 0; i &lt; cnt; i++)
    &#123;
        memset(d[i], 0x3f, sizeof d[i]);
        int si = ps[i].x, sj = ps[i].y;
        queue&lt;PII&gt; q;
        d[i][si][sj] = 0;
        q.push(&#123;si, sj&#125;);
        while (q.size())
        &#123;
            int x = q.front().x, y = q.front().y;
            q.pop();
            for (int k = 0; k &lt; 4; k++)
            &#123;
                int a = x + dx[k], b = y + dy[k];
                if (a &lt; 0 || a &gt;= n || b &lt; 0 || b &gt;= m || c[a][b] == &#39;#&#39;) continue;
                if (d[i][a][b] &gt; d[i][x][y] + 1)
                &#123;
                    d[i][a][b] = d[i][x][y] + 1;
                    q.push(&#123;a, b&#125;);
                &#125;
            &#125;
        &#125;
    &#125;
    cnt --;
    
    int f[1 &lt;&lt; cnt][cnt];
    memset(f, 0x3f, sizeof f);
    for (int i = 0; i &lt; cnt; i++) f[1 &lt;&lt; i][i] = d[i][sx][sy];
    for (int s = 1; s &lt; 1 &lt;&lt; cnt; s++)
    &#123;
        for (int last = 0; last &lt; cnt; last++)
        &#123;
            if (f[s][last] == inf) continue;
            for (int nx = 0; nx &lt; cnt; nx++)
                if ((s &gt;&gt; nx &amp; 1) == 0)
                    if (f[s | (1 &lt;&lt; nx)][nx] &gt; f[s][last] + d[last][ps[nx].x][ps[nx].y])
                        f[s | (1 &lt;&lt; nx)][nx] = f[s][last] + d[last][ps[nx].x][ps[nx].y];
        &#125;
    &#125;
    
    int res = -1;
    if (d[cnt][tx][ty] &lt;= t) res = 0;
    for (int s = 1; s &lt; 1 &lt;&lt; cnt; s++)
        for (int last = 0; last &lt; cnt; last++)
            if (f[s][last] + d[last][tx][ty] &lt;= t)
            &#123;
                int ans = 0;
                for (int i = 0; i &lt; cnt; i++) 
                    if (s &gt;&gt; i &amp; 1) ans ++;
                res = max(res, ans);
            &#125;
    
    printf(&quot;%d\n&quot;, res);
    return 0;
&#125;
</code></pre>
<p>另附 LCP.13 的代码，非常相像</p>
<pre><code class="cpp">class Solution &#123;
public:
    int n, m;
    bool valid(int x, int y)&#123;
        return x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m;
    &#125;
    vector&lt;vector&lt;int&gt;&gt; bfs(int x, int y, vector&lt;string&gt;&amp; maze)&#123;
        // 板
        vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(m, -1));
        res[x][y] = 0;
        queue&lt;PII&gt; q;
        q.push(&#123;x, y&#125;);
        while (q.size())
        &#123;
            auto p = q.front();
            q.pop();
            for (int i = 0; i &lt; 4; i++)
            &#123;
                int a = p.x + dx[i], b = p.y + dy[i];
                if (valid(a, b) &amp;&amp; maze[a][b] != &#39;#&#39; &amp;&amp; res[a][b] == -1)
                &#123;
                    res[a][b] = res[p.x][p.y] + 1;
                    q.push(&#123;a, b&#125;);
                &#125;
            &#125;
        &#125;
        return res;
    &#125;
    int minimalSteps(vector&lt;string&gt;&amp; maze) &#123;
        n = maze.size(), m = maze[0].size();
        vector&lt;PII&gt; buttons, stones;
        int sx, sy, tx, ty;
        for (int i = 0; i &lt; n; i++)
            for (int j = 0; j &lt; m; j++)
                if (maze[i][j] == &#39;M&#39;) buttons.push_back(&#123;i, j&#125;);
                else if (maze[i][j] == &#39;O&#39;) stones.push_back(&#123;i, j&#125;);
                else if (maze[i][j] == &#39;S&#39;) sx = i, sy = j;
                else if (maze[i][j] == &#39;T&#39;) tx = i, ty = j;
        // 初始化
        int nb = buttons.size(), ns = stones.size();
        vector&lt;vector&lt;int&gt;&gt; start_d = bfs(sx, sy, maze);
        
        // 没有机关
        if (nb == 0) return start_d[tx][ty];
        // 从某个机关到其他机关 / 起点与终点的最短距离
        vector&lt;vector&lt;int&gt;&gt; d(nb, vector&lt;int&gt;(nb + 2, -1));
        vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; tmp(nb);
        for (int i = 0; i &lt; nb; i++)
        &#123;
            tmp[i] = bfs(buttons[i].x, buttons[i].y, maze);
            // 从某个点到终点不需要拿石头
            d[i][nb + 1] = tmp[i][tx][ty];
        &#125;
        
        for (int i = 0; i &lt; nb; i++)
        &#123;
            int t = -1;
            // 找 起点 - 石头 - 机关 的最短距离
            for (int k = 0; k &lt; ns; k++)
            &#123;
                int mid_x = stones[k].x, mid_y = stones[k].y;
                if (tmp[i][mid_x][mid_y] != -1 &amp;&amp; start_d[mid_x][mid_y] != -1)
                    if (t == -1 || t &gt; tmp[i][mid_x][mid_y] + start_d[mid_x][mid_y])
                        t = tmp[i][mid_x][mid_y] + start_d[mid_x][mid_y];
            &#125;
            d[i][nb] = t;
            // 找 机关 - 石头 - 机关 的最短距离
            for (int j = i + 1; j &lt; nb; j++)
            &#123;
                int mn = -1;
                for (int k = 0; k &lt; ns; k++)
                &#123;
                    int mid_x = stones[k].x, mid_y = stones[k].y;
                    if (tmp[i][mid_x][mid_y] != -1 &amp;&amp; tmp[j][mid_x][mid_y] != -1)
                        if (mn == -1 || mn &gt; tmp[i][mid_x][mid_y] + tmp[j][mid_x][mid_y])
                            mn = tmp[i][mid_x][mid_y] + tmp[j][mid_x][mid_y];
                &#125;
                d[i][j] = mn;
                d[j][i] = mn;
            &#125;
        &#125;
        
        // 无解情况
        for (int i = 0; i &lt; nb; i++)
            if (d[i][nb] == -1 || d[i][nb + 1] == -1) return -1;
        
        int f[1 &lt;&lt; nb][nb];
        memset(f, -1, sizeof f);
        for (int i = 0; i &lt; nb; i++)
            f[1 &lt;&lt; i][i] = d[i][nb];
            
        // 由于更新的状态都比未更新的大，所以直接从小到大遍历即可
        // 板
        for (int msk = 1; msk &lt; 1 &lt;&lt; nb; msk++)
            for (int i = 0; i &lt; nb; i++)
                if (msk &gt;&gt; i &amp; 1)
                    for (int j = 0; j &lt; nb; j++)
                        if ((msk &gt;&gt; j &amp; 1) == 0)
                            if (f[msk | (1 &lt;&lt; j)][j] == -1 || f[msk | (1 &lt;&lt; j)][j] &gt; f[msk][i] + d[i][j])
                                f[msk | (1 &lt;&lt; j)][j] = f[msk][i] + d[i][j];
        
        int res = -1;
        for (int i = 0; i &lt; nb; i++)
            if (res == -1 || res &gt; f[(1 &lt;&lt; nb) - 1][i] + d[i][nb + 1])
                res = f[(1 &lt;&lt; nb) - 1][i] + d[i][nb + 1];
        return res;
    &#125;
&#125;;
</code></pre>
<h4 id="前缀和优化-DP"><a href="#前缀和优化-DP" class="headerlink" title="前缀和优化 DP"></a>前缀和优化 DP</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/abc253/tasks/abc253_e">https://atcoder.jp/contests/abc253/tasks/abc253_e</a><br>输入 n(2≤n≤1000) m k(0≤k&lt;m≤5000)。<br>输出有多少个长为 n 的数组，满足元素范围为 [1,m] 且 abs(a[i]-a[i+1]) &gt;&#x3D; k。<br>模 998244353。</p>
</blockquote>
<p>前缀和优化 DP。</p>
<p>定义 f[i][j] 表示考虑前 i 个数，其中 a[i]&#x3D;j 的方案数。</p>
<p>根据要求，从所有 abs(j-j’) &gt;&#x3D; k 的 f[i-1][j’] 转移过来，这个和式可以用前缀和优化成 O(1)。</p>
<p>初始值 f[1][j] &#x3D; 1。</p>
<p>答案为 sum(f[n-1])。</p>
<p>代码细节较多，注意循环 i 从 2 开始，j 从 0 开始</p>
<p>本来应是加法，但由于是两头的前缀和，因此可优化成总的减去中间段</p>
<pre><code class="cpp">LL s[N], pre[N];
int n, m, k;

int main()
&#123;
    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k);
    for (int i = 1; i &lt;= m; i++) pre[i] = i;
    for (int i = 2; i &lt;= n; i++)
    &#123;
        for (int j = 0; j &lt; m; j++)
        &#123;
            LL f = pre[m];
            if (k &gt; 0) f -= pre[min(j + k, m)] - pre[max(j - k + 1, 0)];
            s[j + 1] = (s[j] + f) % mod;
        &#125;
        for (int i = 0; i &lt;= m; i++) pre[i] = s[i];
    &#125;
    printf(&quot;%lld\n&quot;, (s[m] + mod) % mod);
    return 0;
&#125;
</code></pre>
<h4 id="余数背包-DP"><a href="#余数背包-DP" class="headerlink" title="余数背包 DP"></a>余数背包 DP</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/abc262/tasks/abc262_d">https://atcoder.jp/contests/abc262/tasks/abc262_d</a><br>输入 n(1≤n≤100) 和长为 n 的数组 a(1≤a[i]≤1e9)。<br>如果一个非空子序列的平均值是整数，那么称其为漂亮的。<br>输出 a 的漂亮子序列的个数，模 998244353。<br>注：子序列不一定连续。</p>
</blockquote>
<p>枚举子序列的长度。</p>
<p>考虑子序列长度固定为 m 时，有多少个平均值为整数的子序列。</p>
<p>相当于子序列的元素和模 m 为 0。</p>
<p>用<strong>选或不选</strong>来思考。</p>
<p>定义 f[i][j][k] 表示从前 i 个数中选 j 个数，元素和模 m 为 k 的方案数。</p>
<p>为方便计算取模，用刷表法（用查表法的话，需要算 (k-a[i])%m，可能会算出负数）：</p>
<p>f[i][j][(k+a[i])%m] &#x3D; f[i-1][j][(k+a[i])%m] + f[i-1][j-1][k]</p>
<p>答案为 f[n][m][0]。</p>
<p>代码实现时，第一个维度可以去掉，然后像 0-1 背包那样倒序循环 j。初始值 f[0][0] &#x3D; 1。</p>
<p>余数背包 DP ，复杂度是 O(n4) ?</p>
<pre><code class="cpp">int a[110], f[110][110][110];
int n;
int res;

int main()
&#123;
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]);
    
    for (int m = 1; m &lt;= n; m++)
    &#123;
        memset(f, 0, sizeof f);
        f[0][0][0] = 1;
        for (int i = 1; i &lt;= n; i++)
            for (int j = 0; j &lt;= m; j++)
                for (int k = 0; k &lt; m; k++)
                &#123;
                    f[i][j][k] = (f[i][j][k] + f[i - 1][j][k]) % mod;
                    if (j) f[i][j][(k + a[i]) % m] = (f[i][j][(k + a[i]) % m] + f[i - 1][j - 1][k]) % mod;
                &#125;
        res = (res + f[n][m][0]) % mod;
    &#125;
    printf(&quot;%d\n&quot;, res);
    return 0;
&#125;
</code></pre>
<h4 id="期望-DP-入门"><a href="#期望-DP-入门" class="headerlink" title="期望 DP 入门"></a>期望 DP 入门</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/abc280/tasks/abc280_e">https://atcoder.jp/contests/abc280/tasks/abc280_e</a><br>输入 n(1≤n≤2e5) p(0≤p≤100)<br>怪物的血量为 n。<br>每次攻击，有 p&#x2F;100 的概率会对怪物造成 2 点伤害，有 1-p&#x2F;100 的概率会造成 1 点伤害。<br>让怪物血量 &lt;&#x3D; 0，攻击次数的期望是多少？<br>假设期望等于分数 a&#x2F;b，你需要输出 a * pow(b, mod-2) % mod，其中 mod&#x3D;998244353。</p>
</blockquote>
<p>期望 DP 入门题。</p>
<p>用 f[i] 表示血量为 i 时的攻击次数的期望。</p>
<p>那么 f[i] &#x3D; p&#x2F;100 * (f[i-2]+1) + (1-p&#x2F;100) * (f[i-1]+1)</p>
<p>初始值 f[0]&#x3D;0, f[1]&#x3D;1。</p>
<p>答案为 f[n]。</p>
<p>实现上考虑预处理出来逆元</p>
<pre><code class="cpp">int n, p;
LL f[N];

int qmi(int a, int k, int p)  // 求a^k mod p
&#123;
    int res = 1 % p;
    while (k)
    &#123;
        if (k &amp; 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k &gt;&gt;= 1;
    &#125;
    return res;
&#125;


int main()
&#123;
    scanf(&quot;%d%d&quot;, &amp;n, &amp;p);
    f[1] = 1;
    int inv = qmi(100, mod - 2, mod);
    for (int i = 2; i &lt;= n; i++)
        f[i] = (f[i - 2] * p + f[i - 1] * (100 - p) + 100) % mod * inv % mod;
    printf(&quot;%lld\n&quot;, f[n]);
    return 0;
&#125;
</code></pre>
<h4 id="分割数组求每段乘积和"><a href="#分割数组求每段乘积和" class="headerlink" title="分割数组求每段乘积和"></a>分割数组求每段乘积和</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/abc288/tasks/abc288_f">https://atcoder.jp/contests/abc288/tasks/abc288_f</a><br>输入 n(2≤n≤2e5) 和长为 n 的数字 s，保证 s 不含 0。<br>把 s 分割成若干段，得分为每一段的乘积。特别地，如果不分割，则得分为 s。<br>输出所有分割方案的得分之和，模 998244353。<br>注：一共有 2^(n-1) 种分割方案。</p>
</blockquote>
<p>提示 1：从划分型 DP 入手，你能否找到一个规模更小的子问题？</p>
<p>例如 s&#x3D;1234，如果最后一段为 34，那么得分为 12<em>34+1</em>2<em>34 &#x3D; (12+1</em>2)*34。</p>
<p>注意 12+1*2 是 12 的所有划分的得分之和。</p>
<p>由此可见，枚举出最后一段后，我们可以把问题变成一个规模更小的子问题。</p>
<p>提示 2：定义 f[i] 表示分割前 i 个数字的得分之和（i 从 1 开始）</p>
<p>f[0] &#x3D; 0</p>
<p>f[i] &#x3D; val(1,i) + f[1]*val(2,i) + f[2]*val(3,i) + … + f[i-1]*val(i,i)</p>
<p>其中 val(j,i) 表示 s[j] 到 s[i] 这一段对应的数字。</p>
<p>但这样写是 O(n^2) 的。</p>
<p>提示 3：观察 f[i-1] 的转移方程与 f[i] 的转移方程的差异。</p>
<p>提示 4：val(j,i) &#x3D; val(j,i-1) * 10 + (s[i] - ‘0’)</p>
<p>根据这一式子可以得到</p>
<p>f[i] &#x3D; f[i-1] * 10 + (1+f[1]+f[2]+…+f[i-1]) * (s[i] - ‘0’)</p>
<p>所以再用一个变量 sumF 表示 1+f[1]+f[2]+…+f[i-1]，就可以 O(1) 地从 f[i-1] 算出 f[i] 了。</p>
<pre><code class="cpp">LL f[N];
char a[N];

int main()
&#123;
    int n;
    scanf(&quot;%d%s&quot;, &amp;n, a + 1);
    f[0] = 0;
    LL s = 1;
    for (int i = 1; i &lt;= n; i++)
    &#123;
        f[i] = (s * (a[i] - &#39;0&#39;) % mod + 10 * f[i - 1] % mod) % mod;
        s += f[i];
    &#125;
    printf(&quot;%lld\n&quot;, f[n]);
    return 0;
&#125;
</code></pre>
<h4 id="模数分类-DP"><a href="#模数分类-DP" class="headerlink" title="模数分类 DP"></a>模数分类 DP</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1105/C">https://codeforces.com/problemset/problem/1105/C</a><br>输入正整数 n(&lt;&#x3D;2e5)，l 和 r(1&lt;&#x3D;l&lt;&#x3D;r&lt;&#x3D;1e9)。<br>求有多少个不同的长为 n 的数组，数组元素值的范围为 [l,r]，且数组元素之和为 3 的倍数。<br>答案对 1e9+7 取模。</p>
</blockquote>
<p><strong>按模数分类的 DP</strong></p>
<p>定义 f[i][0&#x2F;1&#x2F;2] 表示长为 i，元素和为 0&#x2F;1&#x2F;2 的数组个数。</p>
<p>枚举第 i 个数所填的数字模 3 的结果，那么 f[i][0] &#x3D; f[i-1][0]*c[0] + f[i-1][1]*c[2] + f[i-1][2]*c[1]，其余同理。</p>
<p>其中 c[0&#x2F;1&#x2F;2] 为 [l,r] 内模 3 余 0&#x2F;1&#x2F;2 的数字个数，计算这个可以考虑用 [0,r] 范围内的减去 [0,l-1] 范围内的。<strong>计算这个的方法看代码</strong>（怎么理解好呢）</p>
<pre><code class="cpp">cin &gt;&gt; n &gt;&gt; l &gt;&gt; r;
    int c[3] = &#123;&#125;;
    l --;
    c[0] = r / 3 - l / 3; //r / 3 - (l + 2) / 3 + 1;
    c[1] = (r + 2) / 3 - (l + 2) / 3; //(r - 1) / 3 - (l - 1 + 2) / 3 + 1;
    c[2] = (r + 1) / 3 - (l + 1) / 3; //(r - 2) / 3 - (l - 2 + 2) / 3 + 1;
    LL f[3] = &#123;1&#125;, g[3] = &#123;&#125;;
    for (int i = 0; i &lt; n; i++)
    &#123;
        g[0] = (f[0] * c[0] + f[1] * c[2] + f[2] * c[1]) % MOD;
        g[1] = (f[0] * c[1] + f[1] * c[0] + f[2] * c[2]) % MOD;
        g[2] = (f[0] * c[2] + f[1] * c[1] + f[2] * c[0]) % MOD;
        for (int j = 0; j &lt; 3; j++) f[j] = g[j];
    &#125;
    cout &lt;&lt; f[0] &lt;&lt; endl;
</code></pre>
<h4 id="新奇-DP-一次考虑连续三个点"><a href="#新奇-DP-一次考虑连续三个点" class="headerlink" title="新奇 DP 一次考虑连续三个点"></a>新奇 DP 一次考虑连续三个点</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/358/problem/D">https://codeforces.com/contest/358/problem/D</a><br>给你 3 个长度均为 n(&lt;&#x3D;3000) 的数组 a b c，元素范围 [0,1e5]，具体含义见下文。<br>有 n 个物品排成一排，你可以按照任意顺序拿物品，并获得相应的分数：</p>
</blockquote>
<ol>
<li>如果拿走某个物品时，相邻两个物品都没有被拿过，那么得到的分数为 a[i]</li>
<li>如果相邻的两个物品恰好有一个被拿过，那么得到的分数为 b[i]</li>
<li>如果相邻的两个物品都被拿走了，那么得到的分数为 c[i]<br> 问拿走所有物品后，能够获得的最高分数为多少？</li>
</ol>
<p><strong>很新奇的 DP 题</strong>。难点在于，每个点的决策会影响前后两个点，前后两个点的决策也会影响到当前点</p>
<p>怎么思考？考虑到第 i 个数时，把 i-2, i-1, i 这三个点合在一起思考，想想看这三个点的先后顺序怎么影响第 i-1 个数对答案的贡献</p>
<p>定义 f[i][1] 表示先拿 i-1，再拿 i 的方案集合，属性是前 i-1 个数的最大分数</p>
<p>同理 f[i][0] 表示先拿 i，再拿 i-1 的方案集合</p>
<ul>
<li><p>要先拿 i-1，再拿 i，考虑一下 i-1 和 i-2 的先后顺序</p>
<ul>
<li>如果先拿 i-2，那么拿 i-1 时，贡献就取 b[i-1]</li>
<li>否则，拿 i-1 时左右都还没被拿走，贡献取 a[i-1]</li>
</ul>
</li>
<li><p>对另一种情况的分析同理</p>
</li>
</ul>
<p>边界怎么考虑？</p>
<ul>
<li>由于是取 max，因此所有状态初始化为负无穷</li>
<li>对于第一个数，只能是先取这个点，即 f[1][0] &#x3D; 0</li>
<li>对于最后一个数，只能是先取这个点，故 f[n+1][1] 就是答案</li>
</ul>
<pre><code class="cpp">memset(f, -0x3f, sizeof f);
    f[1][0] = 0;
    for (int i = 2; i &lt;= n + 1; i++)
    &#123;
        f[i][1] = max(f[i - 1][1] + b[i - 1], f[i - 1][0] + a[i - 1]);
        f[i][0] = max(f[i - 1][1] + c[i - 1], f[i - 1][0] + b[i - 1]);
    &#125;
    cout &lt;&lt; f[n + 1][1] &lt;&lt; endl;
</code></pre>
<h4 id="简单子序列-DP"><a href="#简单子序列-DP" class="headerlink" title="简单子序列 DP"></a>简单子序列 DP</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/209/A">https://codeforces.com/problemset/problem/209/A</a><br>求一个长为 n(&lt;&#x3D;1e6) 的 01 交替串中有多少个 01 交替子序列。对结果模 1e9+7。<br>注意子序列不要求连续。</p>
</blockquote>
<p>典中典 DP，代码说话</p>
<pre><code class="cpp">int endsWith1 = 0, endsWith0 = 0, nothing = 1;
    for (int i = 0; i &lt; n; i++)
        if (i % 2) endsWith1 = (0LL + endsWith1 + endsWith0 + nothing) % MOD;
        else endsWith0 = (0LL + endsWith1 + endsWith0 + nothing) % MOD;
    cout &lt;&lt; (0LL + endsWith0 + endsWith1) % MOD &lt;&lt; endl;
</code></pre>
<h4 id="子序列不含-hard-的方案数"><a href="#子序列不含-hard-的方案数" class="headerlink" title="子序列不含 hard 的方案数"></a>子序列不含 hard 的方案数</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1096/D">https://codeforces.com/problemset/problem/1096/D</a><br>给你一个 n(&lt;&#x3D;1e5)，一个长为 n 的字符串 s 和一个长为 n 的数组 a(1&lt;&#x3D;a[i]&lt;&#x3D;998244353)。<br>表示每个 s[i] 都有一个对应的删除代价 a[i]。<br>请你删除 s 中的某些字符，使得 s 不包含 “hard” 子序列。<br>输出被删除字母的代价之和的最小值。<br>子序列不要求连续。s 仅包含小写字母。</p>
</blockquote>
<p><strong>DP 典题</strong></p>
<p>看到子序列就要往 DP 上想。</p>
<p>先来讨论不包含 hard 子序列需要怎么删。</p>
<p>对于第 i 个字符：</p>
<p>不删：那么前 i-1 个字符不能包含 har 子序列（否则就构成 hard 子序列了）。</p>
<p>删：那么前 i-1 个字符可以包含 har 子序列，但不能包含 hard 子序列。</p>
<p>这样思考一番后，定义 dp[i][j&#x3D;1&#x2F;2&#x2F;3&#x2F;4] 表示删除 s 的前 i 个字符中的某些字符，使得结果不包含 “hard”[:j] 子序列的最小代价（”hard”[:j] 表示 “hard” 的长为 j 的前缀）。</p>
<p>如果 s[i] 是 “hard” 的第 j 个字符，那么有</p>
<p>dp[i][j] &#x3D; min(dp[i-1][j-1], dp[i-1][j]+a[i])</p>
<p>表示不删 or 删，取二者最小值。</p>
<p>注意对于 dp[i][1] 来说，在遇到 “h” 时必须删除，因此可以把 dp[i][0] 初始化成 inf 从而简化逻辑。</p>
<p>如果 s[i] 不在 “hard” 中，转移就是 dp[i] &#x3D; dp[i-1]</p>
<p>答案为 dp[n][4]。</p>
<p>实现时可以用滚动数组优化掉第一维。</p>
<p>dp[i][1&#x2F;2&#x2F;3&#x2F;4] 分别表示</p>
<p>不能有 h</p>
<p>不能有 ha（可以有 h）</p>
<p>不能有 har（可以有 ha）</p>
<p>不能有 hard（可以有 har）</p>
<pre><code class="cpp">LL f[4] = &#123;0&#125;;
    for (char c: s)
    &#123;
        cin &gt;&gt; v;
        switch (c) &#123;
            case &#39;h&#39;: f[0] += v; break;
            case &#39;a&#39;: f[1] = min(f[0], f[1] + v); break;
            case &#39;r&#39;: f[2] = min(f[1], f[2] + v); break;
            case &#39;d&#39;: f[3] = min(f[2], f[3] + v); break;
        &#125;
    &#125;
    cout &lt;&lt; f[3] &lt;&lt; endl;
</code></pre>
<h4 id="全新形式的-DP"><a href="#全新形式的-DP" class="headerlink" title="全新形式的 DP"></a>全新形式的 DP</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/933/A">https://codeforces.com/problemset/problem/933/A</a><br>输入 n (≤2000) 和一个长为 n 的数组 a，元素值只有 1 和 2。<br>你可以翻转 a 的一个区间（该操作执行至多一次）。<br>输出你能得到的最长非降子序列的长度。<br>子序列不要求连续。</p>
</blockquote>
<p>答案的组成一定是 [1,1,…][2,2,…][1,1,…][2,2,…] 这样四段子序列（每一段都允许为空），然后翻转二三段的到答案，那么用 f[i][0&#x2F;1&#x2F;2&#x2F;3] 维护前 i 个数中前 j 段的最大长度即可</p>
<pre><code class="cpp">for (int i = 0; i &lt; n; i++)
    &#123;
        cin &gt;&gt; x;
        f[0] += x == 1;
        f[1] = max(f[0], f[1] + (x == 2));
        f[2] = max(f[1], f[2] + (x == 1));
        f[3] = max(f[2], f[3] + (x == 2));
    &#125;
    cout &lt;&lt; f[3] &lt;&lt; endl;
</code></pre>
<h4 id="理解了很久的单调栈-DP"><a href="#理解了很久的单调栈-DP" class="headerlink" title="理解了很久的单调栈 DP"></a>理解了很久的单调栈 DP</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1407/D">https://codeforces.com/problemset/problem/1407/D</a><br>输入 n(≤3e5) 和一个长为 n 的数组 h (1≤h[i]≤1e9)。<br>满足如下三个条件<strong>之一</strong>，就可以从 i 跳到 j (i&lt;j)：</p>
<ol>
<li>i+1&#x3D;j</li>
<li>max(h[i+1],…,h[j-1]) &lt; min(h[i],h[j])</li>
<li>min(h[i+1],…,h[j-1]) &gt; max(h[i],h[j])<br> 输出从 1 跳到 n 最少需要多少步。</li>
</ol>
</blockquote>
<p>以条件二为例，自己做的时候先画个图分析一下，会发现 i 往左扫到第一个大于等于 h[j] 的位置时，i 的左边就不可能作为转移来源了，那么首先要找到左边第一个不大于 h[j] 的位置，这启发我们用单调栈解决。继续观察发现，如果用严格单调递减的栈来维护，那么在 i 和 j 之间，且可以作为转移来源的位置，恰好就在栈中，而且会在寻找 i 的时候顺便出栈，那么就可以边出栈边更新 f[j] 了</p>
<p>下面难以理解的地方在于代码中，为什么先 pop 一次，还要比较是否相等才更新呢？我的理解是，在循环到 i-1 时，栈中已经构建出了以 a[i-1] 为最小值的单调递减格局，在循环到 i 时，i-1 肯定在栈中，但是不需要理会，因为 i-1 在条件一时就处理了，相当于从单调栈的倒数第二个位置开始比对。还有一个点，虽然是在寻找“大于等于”的位置，但是结合题意得知，当遇到了 a[i]&#x3D;&#x3D;a[j] 时，i 左侧的位置是不能作为转移来源的，因此要设置一个 flag 位，遇到 a[s.top()] &#x3D;&#x3D; a[j] 时置 1，之后正常弹栈但是不更新 f[j]。把以上两点综合起来，并且免去设置 flag 的写法，就是下面的代码，仔细体会（每次 pop 一个数，实际上在关心栈中的下一个数）</p>
<pre><code class="cpp">memset(f, 0x3f, sizeof f);
    f[0] = -1;
    for (int i = 1; i &lt;= n; i++)
    &#123;
        f[i] = f[i - 1] + 1;
        while (desc.size() &amp;&amp; a[i] &gt;= a[desc.top()])
        &#123;
            int x = desc.top();
            desc.pop();
            if (desc.size() &amp;&amp; a[x] != a[i]) f[i] = min(f[i], f[desc.top()] + 1);
        &#125;
/*
        等价写法
        bool flag = 1;
        while (desc.size() &amp;&amp; a[i] &gt;= a[desc.top()])
        &#123;
            int x = desc.top();
            desc.pop();
            f[i] = min(f[i], f[x] + 1);
            if (a[x] == a[i]) flag = 0;
        &#125;
        if (flag &amp;&amp; desc.size()) f[i] = min(f[i], f[desc.top()] + 1);
*/
        while (asc.size() &amp;&amp; a[i] &lt;= a[asc.top()])
        &#123;
            int x = asc.top();
            asc.pop();
            if (asc.size() &amp;&amp; a[x] != a[i]) f[i] = min(f[i], f[asc.top()] + 1);
        &#125;
        desc.push(i), asc.push(i);
    &#125;
    cout &lt;&lt; f[n] &lt;&lt; endl;
</code></pre>
<h4 id="二分答案，用树形-DP-来-check"><a href="#二分答案，用树形-DP-来-check" class="headerlink" title="二分答案，用树形 DP 来 check"></a>二分答案，用树形 DP 来 check</h4><blockquote>
<p><a target="_blank" rel="noopener" href="http://codeforces.com/problemset/problem/1739/D">http://codeforces.com/problemset/problem/1739/D</a><br>输入 t(≤1e4) 表示 t 组数据，每组数据输入 n k(0≤k&lt;n≤2e5)，有一颗 n 个节点的树，输入 n-1 个数 p[2],p[3],…,p[n]，p[i] 表示点 i 的父节点为 p[i]。<br>所有数据的 n 之和不超过 2e5。<br>你可以做如下操作至多 k 次：<br>断开 p[i] 和 i 之间的边，然后在 1 和 i 之间连边。<br>输出操作后，这颗树的最小高度。<br>高度的定义为 1 到最远叶子节点的路径的边数。</p>
</blockquote>
<p>提示 1：由于最终的树越高，操作次数越少，最终的树越矮，操作次数越多，满足单调性，因此可以二分答案。</p>
<p>提示 2：check 需要写一个树形 DP，自底向上计算最长路径长度，达到 mid-1 的时候，切断当前节点和父节点的边，计数器 cnt++，如果最后 cnt≤k 则说明答案不超过 mid。</p>
<p>写 check 的时候逻辑错了很多次，需要梳理清楚当前考虑的深度要不要 +1</p>
<pre><code class="cpp">int dfs(int u, int fa)
&#123;
    int d = 0;
    // 错误写法一
    // for (int v: g[u])
    //     if (v != fa)
    //         d = max(d, dfs(v, u) + 1);
    // if (d == m - 1 &amp;&amp; fa != 1) cnt ++, d = 0;
    // return d;
    // 错误写法二
    // for (int v: g[u])
    //     if (v != fa)
    //     &#123;
    //         int t = dfs(v, u);
    //         if (t == m - 1 &amp;&amp; u != 1) cnt ++, t = 0;
    //         d = max(d, t + 1);
    //     &#125;
    // return d;
    for (int v: g[u])
        if (v != fa)
        &#123;
            int t = dfs(v, u);
            if (t == m - 1 &amp;&amp; u != 1) cnt ++;
            else d = max(d, t + 1);
        &#125;
    return d;
&#125;
</code></pre>
<h4 id="树中上下走的换根-DP"><a href="#树中上下走的换根-DP" class="headerlink" title="树中上下走的换根 DP"></a>树中上下走的换根 DP</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/abc222/tasks/abc222_f">https://atcoder.jp/contests/abc222/tasks/abc222_f</a><br>输入 n(2≤n≤2e5) 和一棵树的 n-1 条边（节点编号从 1 开始），每条边输入两个端点和边权。<br>然后输入 n 个数 d，d[i] 表示点 i 的点权。<br>定义 f(x,y) &#x3D; 从 x 到 y 的简单路径的边权之和，再加上 d[y]。<br>定义 g(x) &#x3D; max{f(x,i)}，这里 i 取遍 1~n 的所有不为 x 的点。<br>输出 g(1),g(2),…,g(n)。</p>
</blockquote>
<p>思路是从 1 开始 dfs，记录从每棵子树的根往下走能得到的最大值 fi 和次大值 se，以及哪个子树可以得到最大值。</p>
<p>然后换根，从 v 到 w，把根从 v 换成 w：如果 w 是 v 的最大值对应的子树，那么对于 w 来说，它往上走能得到的最大值可以是 v 的 se，否则往上走能得到的最大值可以是 v 的 fi。</p>
<p>由于 g(x,y) 和 d[y] 有关，所以对于 w 来说，往上走的最大值还需要与 d[v]+(v-&gt;w 的边权) 求最大值。具体见代码。</p>
<pre><code class="cpp">struct &#123;
    LL fi, se;
    int i;
&#125; ans[N];
LL res[N];

void dfs(int u, int fa)
&#123;
    for (auto &amp;[v, w]: g[u])
        if (v != fa)
        &#123;
            dfs(v, u);
            LL r = max(ans[v].fi, (LL)d[v]) + w;
            if (r &gt; ans[u].fi) ans[u] = &#123;r, ans[u].fi, v&#125;;
            else if (r &gt; ans[u].se) ans[u].se = r;
        &#125;
&#125;

void dp(int u, int fa, LL up)
&#123;
    res[u] = max(ans[u].fi, up);
    up = max(up, (LL)d[u]);
    for (auto &amp;[v, w]: g[u])
        if (v != fa)
        &#123;
            LL down = ans[u].fi;
            if (v == ans[u].i) down = ans[u].se;
            dp(v, u, max(up, down) + w);
        &#125;
&#125;
</code></pre>
<h4 id="由-1-和-1-构成的矩阵，问是否存在和为-0-的路径"><a href="#由-1-和-1-构成的矩阵，问是否存在和为-0-的路径" class="headerlink" title="由 1 和-1 构成的矩阵，问是否存在和为 0 的路径"></a>由 1 和-1 构成的矩阵，问是否存在和为 0 的路径</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1695/C">https://codeforces.com/problemset/problem/1695/C</a><br>输入 t(≤1e4) 表示 t 组数据，每组数据输入 n(≤1e3) m(≤1e3) 和一个 n 行 m 列的矩阵，元素值只有 -1 和 1。所有数据的 n*m 之和不超过 1e6。<br>你从矩阵左上出发，走到右下，每步只能向下或者向右。<br>路径上的元素和能否为 0？输出 YES 或 NO。</p>
</blockquote>
<p>提示 1：交换路径中的相邻两步，比如向右向下变成向下向右，路径和会发生什么变化？</p>
<p>路径和会 +0&#x2F;+2&#x2F;-2。</p>
<p>因此，如果 n+m 是偶数，路径和必然为奇数，无法变成 0。此时可以直接输出 NO。</p>
<p>如果 n+m 是奇数，路径和必然为偶数，然后要怎么判断？</p>
<p>提示 2：求出最小路径和以及最大路径和，如果一个 &lt;&#x3D;0，一个 &gt;&#x3D;0，根据提示 1，可以通过交换，变成 0。<strong>（不必思考具体怎么走，而是转化为一个取值范围问题，具体方案的证明看 tutorial）</strong></p>
<p>怎么求？这是个经典 DP，见 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-path-sum/">https://leetcode.cn/problems/minimum-path-sum/</a></p>
<pre><code class="cpp">mn[0][0] = mx[0][0] = g[0][0];
        for (int i = 1; i &lt; n; i++) 
            mx[i][0] = mn[i][0] = mx[i - 1][0] + g[i][0];
        for (int i = 1; i &lt; m; i++)
            mx[0][i] = mn[0][i] = mx[0][i - 1] + g[0][i];
        
        for (int i = 1; i &lt; n; i++)
            for (int j = 1; j &lt; m; j++)
            &#123;
                mx[i][j] = max(mx[i - 1][j], mx[i][j - 1]) + g[i][j];
                mn[i][j] = min(mn[i - 1][j], mn[i][j - 1]) + g[i][j];
            &#125;
        
        if ((m + n) % 2 == 0 || mn[n - 1][m - 1] &gt; 0 || mx[n - 1][m - 1] &lt; 0) cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;
        else cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;
</code></pre>
<h4 id="树中与距离最远的点有关的换根-DP"><a href="#树中与距离最远的点有关的换根-DP" class="headerlink" title="树中与距离最远的点有关的换根 DP"></a>树中与距离最远的点有关的换根 DP</h4><blockquote>
<p>codeforces.com&#x2F;problemset&#x2F;problem&#x2F;337&#x2F;D<br>输入 n m(1≤m≤n≤1e5) d(0≤d≤n-1) 表示一棵 n 个节点的树，其中 m 个节点有怪物，这些怪物是由一个传送门生成的，传送门与任意怪物的距离不超过 d。<br>然后输入 m 个互不相同的数，表示怪物所在节点编号（从 1 开始）。<br>然后输入 n-1 行，每行两个节点编号，表示树的边。<br>输出可能存在传送门的节点的个数。注意传送门只有一个。</p>
</blockquote>
<p>第一思路：以 r 为根时，距离最远的怪物点要么在 r 为根的子树中，要么在子树外，因此需要知道 distDown[] 和 distUp[]，如果 max &lt;&#x3D; d，那么 r 是可以作为传送门节点的</p>
<p>第一次 DFS 以 1 为根，对每个点记录往下走的最远怪物距离和次远怪物距离，以及最远怪物在哪棵子树中。</p>
<p>第二次 DFS，从 v 到 w 时：</p>
<p>如果 w 是 v 的最远怪物所在子树，那么 w 往上的最远怪物距离就是 max(v 往上最远怪物距离, v 往下次远怪物距离)+1；</p>
<p>如果 w 不是 v 的最远怪物所在子树，那么 w 往上的最远怪物距离就是 max(v 往上最远怪物距离, v 往下最远怪物距离)+1。</p>
<p>对于一个点 v，如果 v 往上往下的最远怪物距离都不超过 d，那么 v 就可能是传送门所在位置。</p>
<pre><code class="cpp">struct &#123;
    int fi, se, fv;
&#125; ans[N];

int dfs(int u, int fa)
&#123;
    ans[u].fi = ans[u].se = -1e9;
    for (int v: g[u])
        if (v != fa)
        &#123;
            int dis = dfs(v, u) + 1;
            if (dis &gt; ans[u].fi)
                ans[u].se = ans[u].fi, ans[u].fi = dis, ans[u].fv = v;
            else if (dis &gt; ans[u].se) ans[u].se = dis;
        &#125;
        if (ans[u].fi &lt; 0 &amp;&amp; st[u]) return 0;
        return ans[u].fi;
&#125;

void dp(int u, int fa, int dFa) // dp(1, 0, -1e9)
&#123;
    if (dFa &gt; d) return;
    if (ans[u].fi &lt;= d) res ++; // up &lt;= d &amp;&amp; down &lt;= d
    if (st[u] &amp;&amp; dFa &lt; 0) dFa = 0;
    for (int v: g[u])
        if (v != fa)
        &#123;
            if (v == ans[u].fv) dp(v, u, max(dFa, ans[u].se) + 1);
            else dp(v, u, max(dFa, ans[u].fi) + 1);
        &#125;
&#125;
</code></pre>
<h4 id="字符串划分方案-DP"><a href="#字符串划分方案-DP" class="headerlink" title="字符串划分方案 DP"></a>字符串划分方案 DP</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1624/E">https://codeforces.com/problemset/problem/1624/E</a><br>输入 t(≤1e4) 表示 t 组数据。所有数据的 n*m 之和 ≤1e6。<br>每组数据输入 n(≤1e3) m(≤1e3) 和长为 n 的字符串数组 a。<br>然后再输入一个字符串 s。<br>所有字符串长度均为 m，仅包含 ‘0’~’9’。<br>你需要将 s 划分成若干个长度至少为 2 的子串，且每个子串都是某个 a[i] 的子串（不同子串对应的 a[i] 可以不同）。<br>如果无法划分，输出 -1；否则输出划分出的子串个数 k，然后输出 k 行，每行三个数字 l r i，表示这个子串等于 a[i] 的子串 [l,r]。注意 l r i 的下标均从 1 开始。注意输出的 k 行要与划分的顺序相同。<br>如果有多种划分方案，输出任意一种。</p>
</blockquote>
<p>本题知识点：<strong>任意 &gt;&#x3D;4 的数字都可以拆分为若干 2 和 3 的和</strong>。</p>
<p>提示 1：预处理所有长为 2 和 3 的子串及其位置。</p>
<p>提示 2：线性 DP，定义 f[i] 表示能否拆分 s[:i]，那么 f[i] 从 f[i-2] 或 f[i-3] 转移，需要看末尾能拆出 2 个字符还是 3 个字符。</p>
<p>f[0]&#x3D;true，答案为 f[n]。</p>
<pre><code class="cpp">for (int i = 1; i &lt;= n; i++)
        &#123;
            cin &gt;&gt; s;
            for (int r = 2; r &lt;= m; r++)
            &#123;
                mp[s.substr(r - 2, 2)] = &#123;r - 1, r, i&#125;;
                if (r &gt; 2) mp[s.substr(r - 3, 3)] = &#123;r - 2, r, i&#125;;
            &#125;
        &#125;
        cin &gt;&gt; s;
        vector&lt;bool&gt; f(m + 1);
        f[0] = 1;
        for (int i = 2; i &lt;= m; i++)
            f[i] = (f[i - 2] &amp;&amp; mp[s.substr(i - 2, 2)].l &gt; 0) || 
            (i &gt; 2 &amp;&amp; f[i - 3] &amp;&amp; mp[s.substr(i - 3, 3)].l &gt; 0);
            
        vector&lt;tup&gt; res;
        for (int i = m; i; )
            if (f[i - 2] &amp;&amp; mp[s.substr(i - 2, 2)].l &gt; 0)
            &#123;
                res.push_back(mp[s.substr(i - 2, 2)]);
                i -= 2;
            &#125;
            else 
            &#123;
                res.push_back(mp[s.substr(i - 3, 3)]);
                i -= 3;
            &#125;
</code></pre>
<h4 id="用记忆化搜索实现区间-DP"><a href="#用记忆化搜索实现区间-DP" class="headerlink" title="用记忆化搜索实现区间 DP"></a>用记忆化搜索实现区间 DP</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/149/D">https://codeforces.com/problemset/problem/149/D</a><br>输入一个合法括号字符串，仅包含 ‘(‘ 和 ‘)’，长度范围 [2,700]。<br>对括号染色，必须满足如下所有条件：</p>
<ol>
<li>一个括号可以染成红色、蓝色或者不染色。</li>
<li>对于一对匹配的括号，恰好其中一个被染色。</li>
<li>两个相邻的染了色的括号，颜色不能相同。<br> 求染色方案数，模 1e9+7。</li>
</ol>
</blockquote>
<p>首先预处理每个左括号对应的右括号的位置，用栈来处理。</p>
<p>由于是从外到内递归，从内到外转移，所以是区间 DP</p>
<p>DP 除了记录区间左右端点 l r 外，为了判断条件 3，还需要记录 l-1 和 r+1 的颜色。</p>
<p>然后就是分类讨论了</p>
<pre><code class="cpp">// int f[n][n][3][3];
    memset(f, -1, sizeof f);
    function&lt;int(int, int, int, int)&gt; dfs = [&amp;](int l, int r, int lc, int rc)
    &#123;
        if (l &gt; r) return 1;
        int &amp;p = f[l][r][lc][rc];
        if (p != -1) return p;
        int mid = right[l];
        LL res = 0;
        if (mid &lt; r)
        &#123;
            res += 1LL * dfs(l + 1, mid - 1, 0, 1) * dfs(mid + 1, r, 1, rc);
            res += 1LL * dfs(l + 1, mid - 1, 0, 2) * dfs(mid + 1, r, 2, rc);
            if (lc != 1) res += 1LL * dfs(l + 1, mid - 1, 1, 0) * dfs(mid + 1, r, 0, rc);
            if (lc != 2) res += 1LL * dfs(l + 1, mid - 1, 2, 0) * dfs(mid + 1, r, 0, rc);
        &#125;
        else 
        &#123;
            if (lc != 1) res += dfs(l + 1, r - 1, 1, 0);
            if (lc != 2) res += dfs(l + 1, r - 1, 2, 0);
            if (rc != 1) res += dfs(l + 1, r - 1, 0, 1);
            if (rc != 2) res += dfs(l + 1, r - 1, 0, 2);
        &#125;
        p = res % MOD;
        return p;
    &#125;;
    cout &lt;&lt; dfs(0, n - 1, 0, 0) &lt;&lt; endl;
</code></pre>
<h4 id="前缀和优化-DP（数轴上移动的方案数）"><a href="#前缀和优化-DP（数轴上移动的方案数）" class="headerlink" title="前缀和优化 DP（数轴上移动的方案数）"></a>前缀和优化 DP（数轴上移动的方案数）</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/480/problem/C">https://codeforces.com/contest/480/problem/C</a><br>输入整数 n a b k (2≤n≤5000, 1≤k≤5000, 1≤a,b≤n, a≠b)。<br>你需要从数轴上的 a 出发，移动恰好 k 次。<br>从整数 x 移动到整数 y，必须满足以下所有要求：</p>
<ol>
<li>1≤y≤n</li>
<li>y≠x</li>
<li>y≠b</li>
<li>|x-y|&lt;|x-b|<br> 输出不同移动方案的个数，模 1e9+7。</li>
</ol>
</blockquote>
<p><strong>难点在于第四个条件，会发现是不能移动到 b 及其右边的</strong></p>
<p>前缀和优化 DP。</p>
<p>为方便计算，如果 a&gt;b，根据对称性调整为 a&#x3D;n+1-a，b&#x3D;n+1-b。这样可以保证 a&lt;b。</p>
<p>定义 f[i][j] 表示 i 次移动后，移动到 j 的方案数。f[0][a] &#x3D; 1。1≤j&lt;b。</p>
<p>考虑从位置 x 转移过来：</p>
<p>如果 x&lt;j，可以移动到 j。</p>
<p>如果 x&gt;j，根据要求 4，解不等式得 x≤j+floor((b-y-1)&#x2F;2)。</p>
<p>所以 f[i][j] &#x3D; f[i-1][1] + … + f[i-1][j+floor((b-y-1)&#x2F;2)] - f[i-1][j]。</p>
<p>最后的减法是因为要求 2。</p>
<p>答案为 sum(f[k][j])。</p>
<pre><code class="cpp">if (a &gt; b) a = n + 1 - a, b = n + 1 - b;
    vector&lt;LL&gt; f(b), s(n + 1);
    f[a] = 1;
    while (k -- )
    &#123;
        for (int i = 0; i &lt; b; i++) s[i + 1] = s[i] + f[i];
        for (int y = 1; y &lt; b; y++)
            f[y] = (s[y + (b - y - 1) / 2 + 1] - f[y]) % MOD;
    &#125;
    LL res = 0;
    for (int i = 0; i &lt; b; i++) res += f[i];
    cout &lt;&lt; res % MOD &lt;&lt; endl;
</code></pre>
<h4 id="子序列和转换为背包问题"><a href="#子序列和转换为背包问题" class="headerlink" title="子序列和转换为背包问题"></a>子序列和转换为背包问题</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1516/problem/C">https://codeforces.com/contest/1516/problem/C</a><br>输入 n(2≤n≤100) 和长为 n 的数组 a(1≤a[i]≤2000)。<br>你需要删除 a 中的一些数，使 a <strong>无法</strong>分成两个元素和相等的子序列。<br>输出最少要删除多少个数，以及这些数的下标（从 1 开始）。<br>注：子序列不要求连续。</p>
</blockquote>
<p>分类讨论：</p>
<ol>
<li>如果 sum(a) 是奇数，显然没法分，无需删除任何数字，输出 0。</li>
<li>如果无法从 a 中选出元素和等于 sum(a)&#x2F;2 的子序列，那么也没法分，输出 0。这可以用 0-1 背包判断。</li>
<li>否则就可以分，那么要如何删除呢？此时 sum(a) 是偶数，由于偶数 - 奇数 &#x3D; 奇数，所以减去一个奇数即可。</li>
<li>要是没有奇数呢？此时每个 a[i] 都是偶数，那么把每个 a[i] 都除以 2，是不会影响答案的。反复除以 2 直到 a 中有奇数为止。</li>
</ol>
<p>代码实现时，**无需反复除以 2，而是除以最小的 lowbit(a[i])**。如果要删除数字，也是删除 lowbit 最小的数。</p>
<pre><code class="cpp">for (int i = 0; i &lt; n; i++) 
    &#123;
        cin &gt;&gt; a[i];
        tot += a[i];
        int lb = lowbit(a[i]);
        if (lb &lt; mn) 
        &#123;
            mn = lb;
            idx = i;
        &#125;
    &#125;
    tot /= mn;
    if (tot % 2) cout &lt;&lt; 0 &lt;&lt; endl;
    else
    &#123;
        f[0] = 1;
        for (int i = 0; i &lt; n; i++)
        &#123;
            a[i] /= mn;
            for (int j = tot; j &gt;= a[i]; j--)
                f[j] |= f[j - a[i]];
        &#125;
        f[tot / 2] ? (cout &lt;&lt; 1 &lt;&lt; endl &lt;&lt; idx + 1 &lt;&lt; endl) : (cout &lt;&lt; 0 &lt;&lt; endl);
    &#125;
</code></pre>
<h4 id="位运算结合划分型-DP"><a href="#位运算结合划分型-DP" class="headerlink" title="位运算结合划分型 DP"></a>位运算结合划分型 DP</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/981/D">https://codeforces.com/problemset/problem/981/D</a><br>输入 n k(1≤k≤n≤50) 和长为 n 的数组 a(0&lt;a[i]&lt;2^50)。<br>把 a 划分成恰好 k 个非空连续子数组。<br>把第 i 个子数组记作 b[i]。<br>最大化 sum(b[0]) AND sum(b[1]) AND … AND sum(b[k-1])。<br>这里 AND 表示按位与。</p>
</blockquote>
<p>涉及到二进制的题目，其中一种思路是拆位。</p>
<p>设最高位为 m。</p>
<p>第 m 位能不能是 1？如果能，那么答案至少是 1&lt;&lt;m。</p>
<p>怎么判断？标准的划分型 DP，定义 f[i][r] 表示 a[0] 到 a[r-1] 能否分成 i 段，且每一段的第 m 位都是 1。</p>
<p>设 target &#x3D; 1&lt;&lt;m，有</p>
<p>f[i][r] |&#x3D; f[i-1][l] &amp;&amp; ((sum[r] - sum[l]) &amp; target) &#x3D;&#x3D; target</p>
<p>其中 sum[0] &#x3D; 0, sum[i] &#x3D; a[0] + … + a[i-1]</p>
<p>初始值 f[0][0] &#x3D; true，如果最后 f[k][n] &#x3D; true 则说明第 m 位可以是 1。</p>
<p>然后继续判断，第 m-1 位能不能是 1？第 m-2 位能不能是 1？……</p>
<p>注意如果第 m 位是 1，那么在判断其余位的时候，要带着第 m 位是 1 一块判断。（代码中压缩成一维，所以每轮循环后 f[0] &#x3D; 0）</p>
<pre><code class="cpp">for (int i = 64 - __builtin_clzll(sum[n]); i &gt;= 0; i--)
    &#123;
        LL bit = 1LL &lt;&lt; i;
        LL target = res | bit;
        vector&lt;bool&gt; f(n + 1);
        f[0] = 1;
        for (int i = 0; i &lt; k; i++)
        &#123;
            for (int r = n; r; r--)
            &#123;
                f[r] = 0;
                for (int l = 0; l &lt; r; l++)
                    if (f[l] &amp;&amp; ((sum[r] - sum[l]) &amp; target) == target)
                    &#123;
                        f[r] = 1;
                        break;
                    &#125;
            &#125;
            f[0] = 0;
        &#125;
        if (f[n]) res = target;
    &#125;
</code></pre>
<h4 id="前后缀积解决逆元-换根-DP"><a href="#前后缀积解决逆元-换根-DP" class="headerlink" title="前后缀积解决逆元 + 换根 DP"></a>前后缀积解决逆元 + 换根 DP</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/543/D">https://codeforces.com/problemset/problem/543/D</a><br>输入 n(2≤n≤2e5) 和 n-1 个数 p2,p3,…,pn，表示一棵 n 个节点的无根树，节点编号从 1 开始，i 与 pi(1≤pi≤i-1) 相连。<br>定义 a(x) 表示以 x 为根时的合法标记方案数，模 1e9+7。其中【合法标记】定义为：对树的某些边做标记，使得 x 到任意点的简单路径上，<strong>至多</strong>有一条边是被标记的。<br>输出 a(1),a(2),…,a(n)。</p>
</blockquote>
<p>先来计算 a(1)，此时 1 为树根。</p>
<p>定义 f(i) 表示子树 i 的合法标记方案数。</p>
<p>对于 i 的儿子 j，考虑 i-j 这条边是否标记：</p>
<ul>
<li>标记：那么子树 j 的所有边都不能标记，方案数为 1。</li>
<li>不标记：那么方案数就是 f(j)。</li>
</ul>
<p>i 的每个儿子互相独立，所以根据乘法原理有</p>
<p>f(i) &#x3D; (f(j1)+1) * (f(j2)+1) * … * (f(jm)+1)</p>
<p>其中 j1,j2,…,jm 是 i 的儿子。</p>
<p>然后来计算其余 a(i)。</p>
<p>考虑把根从 i 换到 j：</p>
<p>对于 j 来说，方案数需要在 f(j) 的基础上，再乘上【父亲 i】这棵子树的方案数，即 a(i) &#x2F; (f(j)+1)。</p>
<p>所以 a(j) &#x3D; f(j) * (a(i)&#x2F;(f(j)+1) + 1)</p>
<p>本题的一个易错点是，f(j)+1 可能等于 M&#x3D;1e9+7，取模会变成 0，但是 0 没有逆元。<strong>用前后缀积来解决，即不乘 f(j)+1</strong></p>
<pre><code class="cpp">vector&lt;LL&gt; pre[N], suf[N]; // 前缀积 后缀积

void dfs(int u, int fa)
&#123;
    f[u] = 1;
    for (int v: g[u])
        if (v != fa)
        &#123;
            dfs(v, u);
            f[u] = f[u] * (f[v] + 1) % MOD;
        &#125;
&#125;

void dp(int u, int fa)
&#123;
    res[u] = 1;
    for (int v: g[u])
    &#123;
        res[u] = res[u] * (f[v] + 1) % MOD;
        if (v != fa) 
            pre[u].push_back(f[v] + 1), suf[u].push_back(f[v] + 1);
    &#125;
    for (int i = 1; i &lt; pre[u].size(); i++) 
        pre[u][i] = pre[u][i] * pre[u][i - 1] % MOD;
    for (int i = suf[u].size() - 2; i &gt;= 0; i--)
        suf[u][i] = suf[u][i] * suf[u][i + 1] % MOD;
    int cnt = 0; // 对应上面 push_back 的顺序
    for (int v: g[u])
    &#123;
        if (v == fa) continue;
        f[u] = (fa ? f[fa] + 1 : 1);
        if (cnt &gt; 0) f[u] = f[u] * pre[u][cnt - 1] % MOD;
        if (cnt &lt; suf[u].size() - 1) f[u] = f[u] * suf[u][cnt + 1] % MOD;
        dp(v, u);
        cnt ++;
    &#125;
&#125;
</code></pre>
<h4 id="字符串操作求方案数（区间-DP）"><a href="#字符串操作求方案数（区间-DP）" class="headerlink" title="字符串操作求方案数（区间 DP）"></a>字符串操作求方案数（区间 DP）</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1336/C">https://codeforces.com/problemset/problem/1336/C</a><br>输入长度不超过 3000 的字符串 S，只包含小写字母。设 S 的长度为 n。<br>输入长度不超过 n 的字符串 T，只包含小写字母。<br>从一个空字符串 A 开始，执行如下操作不超过 n 次：<br>删除 S 的第一个字母，然后加到 A 的开头或者末尾。<br>问：要使 T 是 A 的前缀，有多少种不同的操作方式？模 998244353。</p>
</blockquote>
<p>先假设 s 和 t 一样长。</p>
<p>我们不知道 s 的第一个字母和谁匹配，但我们知道 s 的最后一个字母只能与 t[0] 或者 t[m-1] 匹配（加到开头或者末尾）。</p>
<p>假如与 t[0] 匹配，那么问题变成 s[:n-1] 与 t[1:] 匹配的方案数。这是一个规模更小的子问题。</p>
<p>这启发我们得到下面的区间 DP。</p>
<p>把 t 扩充成和 s 一样长，扩充的字母视作任意字符（一定可以与 s[i] 匹配）。</p>
<p>定义 f[i][j] 表示操作前缀 s[0]<del>s[j-i] 得到子串 t[i]</del>t[j] 的方案数。</p>
<p>那么答案就是 f[0][m-1]+f[0][m]+…+f[0][n-1]。</p>
<p>考虑 s[j-i] 与 t[i] 还是 t[j] 匹配，可以得到</p>
<p>f[i][j] &#x3D; (i&gt;&#x3D;m || s[j-i]&#x3D;&#x3D;t[i] ? f[i+1][j] : 0) + (j&gt;&#x3D;m || s[j-i]&#x3D;&#x3D;t[j] ? f[i][j-1] : 0)</p>
<p>初始值 f[i][i] &#x3D; (i&gt;&#x3D;m || s[0]&#x3D;&#x3D;t[i] ? 2 : 0)</p>
<pre><code class="cpp">for (int i = 0; i &lt; n; i++)
        f[i][i] = (i &gt;= m || s[0] == t[i]) ? 2 : 0;
    for (int len = 2; len &lt;= n; len++)
        for (int i = 0; i + len - 1 &lt; n; i++)
        &#123;
            int j = i + len - 1;
            if (i &gt;= m || s[j - i] == t[i])
                f[i][j] = (f[i][j] + f[i + 1][j]) % mod;
            if (j &gt;= m || s[j - i] == t[j])
                f[i][j] = (f[i][j] + f[i][j - 1]) % mod;
        &#125;
    LL res = 0;
    for (int i = m - 1; i &lt; n; i++) 
        res = (res + f[0][i]) % mod;
</code></pre>
<h4 id="逆向思维-转化为背包问题"><a href="#逆向思维-转化为背包问题" class="headerlink" title="逆向思维 转化为背包问题"></a>逆向思维 转化为背包问题</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/730/J">https://codeforces.com/problemset/problem/730/J</a><br>输入 n(1≤n≤100) 和两个长为 n 的数组 a b (1≤a[i]≤b[i]≤100)。<br>有 n 个水桶，第 i 个水桶装了 a[i] 单位的水，水桶容量为 b[i]。<br>花费 1 秒，可以从某个水桶中，转移 1 个单位的水，到另一个水桶。<br>输出两个数：<br>把水汇集起来，最少需要多少个桶（换句话说需要倒空尽量多的桶），该情况下至少要多少秒完成？</p>
</blockquote>
<p>最少需要多少个桶？这可以贪心地按照 b[i] 从大到小选择，直到选择的 b[i] 之和 &gt;&#x3D; sum(a) 为止。</p>
<p>假设最少需要 m 个桶。</p>
<p>在 m 个桶的前提下，至少要多少秒完成？</p>
<p>正难则反，考虑最多有多少单位的水是不需要转移的。</p>
<p>把 b[i] 看成物品体积，a[i] 看成物品价值，变成 0-1 背包问题：</p>
<p>定义 f[i][j][k] 表示从前 i 个桶中恰好选 j 个桶，这 j 个桶的容量之和恰好为 k 的情况下，最多有 f[i][j][k] 单位的水是不需要转移的。</p>
<p>状态转移方程为：f[i][j][k] &#x3D; max(f[i-1][j][k], f[i-1][j-1][k-b[i]]+a[i])。</p>
<p>初始值：f[0][0][0] &#x3D; 0，其余为负无穷大。</p>
<p>答案为：sum(a)-max(f[n][m][sum(a):])。</p>
<p>（注意这里我是用【恰好】定义的，k 需要从 sum(a) 枚举到 sum(b)。用【至少】定义 k 也是可以的。）</p>
<pre><code class="cpp">int f[m + 1][sb + 1];
    memset(f, -0x3f, sizeof f);
    f[0][0] = 0;
    for (int i = 0; i &lt; n; i++)
        for (int j = m; j; j--)
            for (int k = sb; k &gt;= p[i].y; k--)
                f[j][k] = max(f[j][k], f[j - 1][k - p[i].y] + p[i].x);
    
    int mx = 0;
    for (int i = sa; i &lt;= sb; i++)
        mx = max(mx, f[m][i]);
    cout &lt;&lt; m &lt;&lt; &#39; &#39; &lt;&lt; sa - mx &lt;&lt; endl;
</code></pre>
<h4 id="字符串-方案数-转化为背包"><a href="#字符串-方案数-转化为背包" class="headerlink" title="字符串 方案数 转化为背包"></a>字符串 方案数 转化为背包</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2679">https://www.luogu.com.cn/problem/P2679</a><br>输入 n(1≤n≤1000) m k(1≤k≤m≤200) 和长为 n 的字符串 s，长为 m 的字符串 t，只包含小写英文字母。<br>你需要从 s 中取出 k 个互不重叠的非空连续子串，然后把这 k 个子串按照其在 s 中的出现顺序依次连接起来，得到一个新的字符串。<br>输出有多少种方案可以使得这个新串与 t 相等。<br>答案模 1e9+7。<br>注意：子串相同但取出的位置不同，也认为是不同的方案。</p>
</blockquote>
<p>朴素想法是枚举 f[i][j][k]，然后看最后一段的长度，复杂度太高</p>
<p>优化：引入新维度，0&#x2F;1 表示第 i 个字符包不包含在最后一个子串中</p>
<p>此外，本题还卡空间，观察转移方程，发现 f[i] 只与 f[i-1] 有关，于是优化掉一维</p>
<pre><code class="cpp">cin &gt;&gt; n &gt;&gt; m &gt;&gt; K &gt;&gt; a &gt;&gt; b;
    // 看 a[i]: 0 表示不含，1 表示包含
    // a[i] = b[j]: f[i][j][k][0] = f[i - 1][j][k][0] + f[i - 1][j][k][1] 即前面选或不选
    //              f[i][j][k][1] = f[i - 1][j - 1][k][1] + f[i - 1][j - 1][k - 1][0] + f[i - 1][j - 1][k - 1][1]
    // a[i] != b[j]: f[i][j][k][0] = f[i - 1][j][k][0] + f[i - 1][j][k][1]
    //               f[i][j][k][1] = 0 由于选不了
    f[0][0][0][0] = f[1][0][0][0] = 1;
    bool t = 0;
    for (int i = 1; i &lt;= n; i++, t ^= 1)
        for (int j = 1; j &lt;= m; j++)
            for (int k = 1; k &lt;= K; k++)
            &#123;
                f[t][j][k][0] = ((LL)f[t ^ 1][j][k][0] + f[t ^ 1][j][k][1]) % MOD;
                if (a[i - 1] == b[j - 1])
                    f[t][j][k][1] = ((LL)f[t ^ 1][j - 1][k][1] + f[t ^ 1][j - 1][k - 1][0] + f[t ^ 1][j - 1][k - 1][1]) % MOD;
                else f[t][j][k][1] = 0;
            &#125;
    cout &lt;&lt; ((LL)f[t ^ 1][m][K][0] + f[t ^ 1][m][K][1]) % MOD &lt;&lt; endl;
</code></pre>
<h4 id="至少型-01-背包"><a href="#至少型-01-背包" class="headerlink" title="至少型 01 背包"></a>至少型 01 背包</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/tenka1-2019/tasks/tenka1_2019_d">https://atcoder.jp/contests/tenka1-2019/tasks/tenka1_2019_d</a><br>输入 n(3≤n≤300) 和长为 n 的数组 a(1≤a[i]≤300)。<br>把每个 a[i] 都涂成红&#x2F;绿&#x2F;蓝三种颜色中的一种。（相当于把 a 分成 3 个子序列）<br>记红色元素和为 R，绿色元素和为 G，蓝色元素和为 B。<br>问：有多少种涂色方案，使得 R,G,B 组成了一个非退化三角形的三条边。模 998244353。</p>
</blockquote>
<p>正难则反 + 至少型 0-1 背包</p>
<pre><code class="cpp">int main()
&#123;
    scanf(&quot;%d&quot;, &amp;n);
    f[0] = g[0] = 3;
    int pow3 = 1;
    while (n -- )
    &#123;
        scanf(&quot;%d&quot;, &amp;v);
        s += v;
        for (int j = s; j &gt;= 0; j--)
        &#123;
            f[j] = (2LL * f[j] + f[max(j - v, 0)]) % mod; // 至少装满
            if (j &gt;= v) g[j] = ((LL)g[j] + g[j - v]) % mod; // 恰好装满
        &#125;
        pow3 = 3LL * pow3 % mod;
    &#125;
    if (s % 2 == 0) dup = g[s / 2]; // 恰好装满 s/2
    int res = (LL)pow3 - (f[(s + 1) / 2] - dup);
    printf(&quot;%d\n&quot;, (res % mod + mod) % mod);
    return 0;
&#125;
</code></pre>
<h4 id="排列型状压"><a href="#排列型状压" class="headerlink" title="排列型状压"></a>排列型状压</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1238/E">https://codeforces.com/problemset/problem/1238/E</a><br>输入 n(1≤n≤1e5) m(1≤m≤20) 和长为 n 的字符串 s，由前 m 个小写字母组成。<br>你需要构造一个长为 m 的小写字母排列，例如 m&#x3D;3 时的 bac，把这个排列当成一个只有一排的键盘。<br>在只用一根手指的情况下，用这个键盘打出 s。<br>问：构造一个怎样的键盘，可以使手指的移动距离之和最小？输出这个最小值。</p>
</blockquote>
<p>本质是要最小化 pos[x]-pox[y]，其中 x，y 为 s 中相邻字符，因此要统计字符串中相邻字母对的个数，记作 cnt。</p>
<p>用状态 s 表示前面填了 |s| 个字母的键盘，这里 |s| 表示 s 中二进制 1 的个数</p>
<p>假设当前填字母 c，那么 c 的位置 pos[c]&#x3D;|s|。</p>
<p>对于前面已经填的字母 x，贡献为 cnt[c][x] * (pos[c] - pos[x])，</p>
<p>对于后面没有填的字母 y，贡献为 cnt[c][y] * (pos[y] - pos[c])。</p>
<p>但是此时还不知道 y 的具体位置，怎么转化？只统计 c 对答案的贡献！把 cnt[c][x] * pos[c] 单独分离出来，这样每个字母怎么填，就不需要知道前后字母的【具体位置】了。</p>
<p>总贡献 cost(c) &#x3D; sum(cnt[c][x] * pos[c] for x in s) - sum(cnt[c][y] * pos[c] for y not in s)</p>
<p>定义 f[s] 表示状态 s 的 cost 之和的最小值，有</p>
<p>f[s|c] &#x3D; min(f[s] + cost(c) for c not in s)</p>
<p>初始值 f[0] &#x3D; 0，答案为 f[-1]。</p>
<pre><code class="cpp">for (int i = 0; i &lt; n - 1; i++)
    &#123;
        int x = s[i] - &#39;a&#39;, y = s[i + 1] - &#39;a&#39;;
        if (x != y)
            cnt[x][y] ++, cnt[y][x] ++;
    &#125;
    int f[1 &lt;&lt; m];
    memset(f, 0x3f, sizeof f);
    f[0] = 0;
    for (int s = 0; s &lt; 1 &lt;&lt; m; s++)
    &#123;
        int one = __builtin_popcount(s);
        for (int i = 0; i &lt; m; i++)
            if ((s &gt;&gt; i &amp; 1) == 0)
            &#123;
                // 加第 i 个字母
                int sum = 0;
                for (int j = 0; j &lt; m; j++)
                    if (s &gt;&gt; j &amp; 1) sum += cnt[i][j] * one;
                    else sum -= cnt[i][j] * one;
                f[s | (1 &lt;&lt; i)] = min(f[s | (1 &lt;&lt; i)], f[s] + sum);
            &#125;
    &#125;
    cout &lt;&lt; f[(1 &lt;&lt; m) - 1] &lt;&lt; endl;
</code></pre>
<h4 id="MEX-子序列"><a href="#MEX-子序列" class="headerlink" title="MEX 子序列"></a>MEX 子序列</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1613/D">https://codeforces.com/problemset/problem/1613/D</a><br>输入 T(≤1e5) 表示 T 组数据。所有数据的 n 之和 ≤5e5。<br>每组数据输入 n(1≤n≤5e5) 和长为 n 的数组 a(0≤a[i]≤n)。<br>称序列 b 为 MEX 序列，如果对所有 i 都有 abs(b[i] - mex(b[0],…,b[i])) ≤ 1 成立，其中 mex(S) 表示不在 S 中的最小非负整数。<br>输出 a 的非空 MEX 子序列的个数，模 998244353。<br>两个子序列只要有元素下标不同，就算不同的子序列。例如 a&#x3D;[0,0,0] 有 7 个不同的非空子序列。<br>注：子序列不要求连续。</p>
</blockquote>
<p>MEX 序列只能有两种形式：</p>
<ol>
<li>[0,…,0, <strong>1,…,1,</strong> …, <strong>x-1,…,x-1,</strong> x,…,x]</li>
<li>[0,…,0, <strong>1,…,1,</strong> …, <strong>x-1,…,x-1,</strong> x+1,…,x+1, <strong>x-1,…,x-1,</strong> x+1,…]</li>
</ol>
<p>设 dp1(i,j) 表示考虑前 i 个数，mex&#x3D;j 的第一种 mex 序列个数，dp2(i,j) 表示第二种</p>
<p>当前是 dp1(i,j)，考虑 x 怎么更新答案（当前是 dp2(i,j)）</p>
<ul>
<li>若 x&lt;j-1，不能更新 （不能更新）</li>
<li>若 x&#x3D;j-1，不改变 mex 的值，可转移到 dp1(i+1,j) （不改变，转移到 dp2(i+1,j)）</li>
<li>若 x&#x3D;j，mex 的值会 +1，可转移到 dp1(i+1,j+1) （mex 的值会 +2，不能更新）</li>
<li>若 x&#x3D;j+1，mex 的值不变，但是转移到 dp2(i+1,j) （不改变，转移到 dp2(i+1,j)）</li>
<li>若 x&gt;j+1，不能更新 不能更新</li>
</ul>
<p>代码实现时可优化第一个维度，原地更新</p>
<pre><code class="cpp">vector&lt;LL&gt; f1(n + 2), f2(n + 2);
        f1[0] = 1;
        while (n -- )
        &#123;
            cin &gt;&gt; x;
            f1[x + 1] = (f1[x + 1] + f1[x + 1]) % mod;
            f1[x + 1] = (f1[x + 1] + f1[x]) % mod;
            if (x &gt; 0) f2[x - 1] = (f2[x - 1] + f2[x - 1]) % mod;
            if (x &gt; 0) f2[x - 1] = (f2[x - 1] + f1[x - 1]) % mod;
            f2[x + 1] = (f2[x + 1] + f2[x + 1]) % mod;
        &#125;
        LL res = 0;
        for (int x: f1) res = (res + x) % mod;
        for (int x: f2) res = (res + x) % mod;
        cout &lt;&lt; (res - 1) % mod &lt;&lt; endl; // 非空 -1
</code></pre>
<h4 id="字符矩阵中的回文路径数"><a href="#字符矩阵中的回文路径数" class="headerlink" title="字符矩阵中的回文路径数"></a>字符矩阵中的回文路径数</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/570/E">https://codeforces.com/problemset/problem/570/E</a><br>输入 n m (1≤n,m≤500) 和 n 行 m 列的字符矩阵，只包含小写字母。<br>你需要从左上角的 (1,1) 出发，到达右下角的 (n,m)。<br>每次只能向下或向右走。<br>问：有多少条路径对应的字符串是回文串？（见右图）<br>模 1e9+7。</p>
</blockquote>
<p>转换成两个人同时从左上和右下出发，定义 f[i][r1][r2] 表示走了 i 步，两人分别在第 r1 行和第 r2 行的方案数。这样只需要三个数就能表示坐标 (r1,c1) 和 (r2,c2)。</p>
<p>f[0][1][n] &#x3D; 1（如果 a[1][1] !&#x3D; a[n][m] 直接输出 0）</p>
<p>如果 a[r1][c1] &#x3D; a[r2][c2]，那么 f[i][r1][r2] &#x3D; f[i-1][r1][r2] + f[i-1][r1][r2+1] + f[i-1][r1-1][r2] + f[i-1][r1-1][r2+1]，否则就是 0</p>
<p>代码实现时，第一个维度可以去掉。</p>
<p>最后答案按照字符串长度的奇偶性讨论。</p>
<p>如果是奇回文串，那么答案为 sum(f[i][i])，否则答案为 sum(f[i][i]+f[i][i+1])。</p>
<pre><code class="cpp">LL f[n + 1][n + 2];
    memset(f, 0, sizeof f);
    f[1][n] = 1;
    for (int i = 1; i &lt; (n + m) / 2; i++) // 路径长度 n+m-1 步数除以2 上取整
        for (int r1 = n; r1 &gt; 0; r1--)
            for (int r2 = 1; r2 &lt;= n; r2++) &#123;
                int c1 = i + 2 - r1, c2 = m + n - i - r2;
                if (c1 &gt; 0 &amp;&amp; c1 &lt;= m &amp;&amp; c2 &gt; 0 &amp;&amp; c2 &lt;= m) &#123;
                    if (a[r1 - 1][c1 - 1] == a[r2 - 1][c2 - 1]) 
                        f[r1][r2] = (f[r1][r2] + f[r1 - 1][r2] + f[r1][r2 + 1] + f[r1 - 1][r2 + 1]) % MOD;
                    else f[r1][r2] = 0;
                &#125;
            &#125;
    LL res = 0;
    if ((n + m) % 2) &#123;
        for (int i = 1; i &lt;= n; i++)
            res = (res + f[i][i] + f[i][i + 1]) % MOD;
    &#125; else &#123;
        for (int i = 1; i &lt;= n; i++)
            res = (res + f[i][i]) % MOD;
    &#125;
</code></pre>
<h4 id="数位-DP-预处理"><a href="#数位-DP-预处理" class="headerlink" title="数位 DP + 预处理"></a>数位 DP + 预处理</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/55/D">https://codeforces.com/problemset/problem/55/D</a></p>
<p>输入 T(≤10) 表示 T 组数据。<br>每组数据输入 L R(1≤L≤R≤9e18)。</p>
<p>输出 [L,R] 内有多少个数字，能被其每个非零数位整除？<br>例如 240 能被 2 和 4 整除，符合要求。</p>
</blockquote>
<p>如果一个数字 num 被多个数整除，那么 num 也被这些数的最小公倍数（LCM）整除。</p>
<p>比如 num 被 6,4,3 整除，那么 num 也必然被 12 整除。</p>
<p>考虑到 LCM(1,2,3,…,9) &#x3D; 2520，我们无需在记忆化搜索时记录 num，而是记录 num % 2520。</p>
<p>如果 num % 2520 能被 num 的所有非零数位的 LCM 整除，那么 num 也同样能被 LCM 整除。</p>
<p>定义 dfs(i,j,rem) 表示当前枚举到第 i 个数位，之前枚举的数位的 LCM 为 j，num % 2520 &#x3D; rem。</p>
<p>递归终点：如果 i &#x3D; n 时 rem % j &#x3D; 0，则说明构造的 num 是合法的，返回 1，否则返回 0。</p>
<p>由于 j 最大是 2520，直接创建 9<em>2520</em>2520 的 64 位整形数组是会 MLE 的（约 436MB）。</p>
<p>可以预处理 {1,2,3,..,9} 的所有非空子集的 LCM（这有 48 个），把这 48 个数离散化一下，就可以大大减少空间了。</p>
<p>另外在 dfs 中算 LCM 可能有点慢，可以打表预处理这 48 个数与 1~9 的 LCM 的结果。</p>
<pre><code class="cpp">int lcms[] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 
14, 15, 18, 20, 21, 24, 28, 30, 35, 36, 40, 
42, 45, 56, 60, 63, 70, 72, 84, 90, 105, 120, 
126, 140, 168, 180, 210, 252, 280, 315, 360, 420, 504, 630, 840, 1260, 2520&#125;;
int idx[2521], lcmRes[48][10];
void init() &#123;
    for (int i = 0; i &lt; 48; i++) idx[lcms[i]] = i;
    for (int i = 0; i &lt; 48; i++) &#123;
        int v = lcms[i];
        lcmRes[i][0] = lcmRes[i][1] = i;
        for (int j = 2; j &lt; 10; j++) lcmRes[i][j] = idx[(int)lcm(v, j)];
    &#125;
&#125;
LL dfs(int i, int j, int rem, bool limitLow, bool limitHigh) &#123;
    if (i == n) return rem % lcms[j] ? 0LL : 1LL;
    if (!limitLow &amp;&amp; !limitHigh &amp;&amp; f[i][j][rem] != -1) return f[i][j][rem];
    int lo = limitLow ? low[i] - &#39;0&#39; : 0;
    int hi = limitHigh ? high[i] - &#39;0&#39; : 9;
    LL res = 0;
    for (int d = lo; d &lt;= hi; d++)
        res += dfs(i + 1, lcmRes[j][d], (rem * 10 + d) % 2520, limitLow &amp;&amp; d == lo, limitHigh &amp;&amp; d == hi);
    if (!limitLow &amp;&amp; !limitHigh) f[i][j][rem] = res;
    return res;
&#125;
</code></pre>
<h4 id="括号：最长合法子串个数"><a href="#括号：最长合法子串个数" class="headerlink" title="括号：最长合法子串个数"></a>括号：最长合法子串个数</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/5/C">https://codeforces.com/problemset/problem/5/C</a><br>给出一个括号序列，求出最长合法子串和它的数量。 合法的定义：这个序列中左右括号匹配</p>
</blockquote>
<p>用栈模拟，如果可以匹配则把值置为 1，然后求最长的连续 1 的个数即可</p>
<pre><code class="cpp">/*
**()()))())()()(()**
**1111001101111011**
*/
    vector&lt;bool&gt; st(n + 1);
    stack&lt;int&gt; s;
    for (int i = 0; i &lt; n; i++)
        if (str[i] == &#39;(&#39;) s.push(i);
        else if (s.size()) &#123;
            st[s.top()] = st[i] = 1;
            s.pop();
        &#125;
    int mx = 0, cnt = 0;
    for (int i = 0; i &lt;= n; i++)
        if (st[i]) cnt ++;
        else mx = max(mx, cnt), cnt = 0;
    int tot = 0;
    for (int i = 0; i &lt;= n; i++)
        if (st[i]) cnt ++;
        else &#123;
            if (cnt == mx) tot ++;
            cnt = 0;
        &#125;
</code></pre>
<h4 id="子序列乘积为完全平方数"><a href="#子序列乘积为完全平方数" class="headerlink" title="子序列乘积为完全平方数"></a>子序列乘积为完全平方数</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/895/C">https://codeforces.com/problemset/problem/895/C</a></p>
<p>输入 n(1≤n≤1e5) 和长为 n 的数组 a(1≤a[i]≤70)。<br>输出有多少个非空子序列，其元素乘积是完全平方数。模 1e9+7。</p>
</blockquote>
<p>统计每个元素的出现次数，记到 cnt 数组中。</p>
<p>70 以内有 19 个质数，考虑状压 DP。</p>
<p>定义 f[x][s] 表示考虑从 1 到 x 中选择子序列的方案数，满足子序列乘积的质因子分解中出现奇数次的质因子的集合是 s。</p>
<p>设 x 出现了 c&#x3D;cnt[x] 次。</p>
<p>如果选择<strong>偶数</strong>个 x（这样的方案有 <strong>pow(2,c-1) 个</strong>），那么 s 不变，有</p>
<p>f[x][s] +&#x3D; f[x-1][s] * pow(2,c-1)</p>
<p>如果选择<strong>奇数</strong>个 x（这样的方案有 <strong>pow(2,c-1) 个</strong>），那么 s 变成 s XOR mask，其中 mask 是 x 的质因子分解中出现奇数次的质因子的集合，有</p>
<p>f[x][s XOR mask] +&#x3D; f[x-1][s] * pow(2,c-1)</p>
<p>注：转移方程是用刷表法思考的。</p>
<p>初始值 f[0][0] &#x3D; 1。</p>
<p>答案为 f[70][0]。</p>
<p>代码实现时，可以用滚动数组优化空间。</p>
<pre><code class="cpp">vector&lt;LL&gt; f(1 &lt;&lt; primes.size());
    f[0] = 1;
    for (int i = 1; i &lt;= 70; i++) &#123;
        int x = i, c = cnt[i];
        if (c == 0) continue;
        int mask = 0;
        for (int j = 0; j &lt; primes.size(); j++)
            for (; x % primes[j] == 0; x /= primes[j])
                mask ^= 1 &lt;&lt; j;
        vector&lt;LL&gt; g(f.size());
        for (int j = 0; j &lt; f.size(); j++) &#123;
            g[j] = (g[j] + f[j] * pow2[c - 1]) % MOD;
            g[j ^ mask] = (g[j ^ mask] + f[j] * pow2[c - 1]) % MOD;
        &#125;
        f = std::move(g);
    &#125;
    cout &lt;&lt; (f[0] - 1 + MOD) % MOD &lt;&lt; endl;
</code></pre>

  </div>
  
  
    
    <div class='footer'>
       <!-- 参考资料、相关资料等 -->
      
       <!-- 相关文章 -->
      
      <!-- 版权声明组件 -->
      
      <!-- 打赏组件 -->
      
    </div>
  
  
    


  <div class='article-meta' id="bottom">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateModified" datetime="2024-07-14T16:17:31+08:00">
  <a class='notlink'>
    <i class="fa-solid fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：2024年7月14日</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/%E9%A2%98%E7%9B%AE/" rel="nofollow"><i class="fa-solid fa-hashtag fa-fw" aria-hidden="true"></i><p>题目</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="nofollow"><i class="fa-solid fa-hashtag fa-fw" aria-hidden="true"></i><p>动态规划</p></a></div>
  <span hidden itemprop="keywords">题目 动态规划</span>


        
      
    </div>
    <!-- Custom Files bottomMeta begin -->
    
    <!-- Custom Files bottomMeta end -->
  </div>


  
  

  
    <div class="prev-next">
      
      
        <a class='next' href='/2024/07/14/%E7%AE%97%E6%B3%95%E9%A2%98%E8%AE%B0%E4%B8%80/'>
          <p class='title'>算法题记一<i class="fa-solid fa-chevron-right" aria-hidden="true"></i></p>
          <p class='content'>单调栈 + 二次差分题源 2735. 收集巧克力 的线性做法
题意延申为：对于 j ∈ [1,k]，求出数组的每一个长为 j 的窗口的最小值之和
朴素做法是 O(nk) 的，假如 j 给定，对于...</p>
        </a>
      
    </div>
  
  <!-- Custom Files postEnd begin-->
  
  <!-- Custom Files postEnd end-->
</article>


  


  <article class="post white-box shadow floatable blur" id="comments">
    <span hidden>
      <meta itemprop="discussionUrl" content="/2024/07/14/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86/index.html#comments">
    </span>
    <p ct><i class='fa-solid fa-comments'></i> 评论</p>
    

    <div id="layoutHelper-comments"></div>

  </article>






</div>
<aside id='l_side' itemscope itemtype="http://schema.org/WPSideBar">
  

  
    
    
      
    
  


<div class="widget-sticky pjax">

  
  


  <section class="widget toc-wrapper desktop mobile " id="toc-div" >
    
  <header>
    
      <i class="fa-solid fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E6%84%9F%E6%83%B3"><span class="toc-text">小感想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E8%AE%BE%E8%AE%A1"><span class="toc-text">状态设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%82-1-%E5%8F%B7%E7%82%B9%E5%88%B0-n-%E5%8F%B7%E7%82%B9%E9%95%BF%E5%BA%A6%E4%B8%8D%E8%B6%85%E8%BF%87-d-n-K-%E7%9A%84%E8%B7%AF%E5%BE%84%E6%95%B0"><span class="toc-text">求 1 号点到 n 号点长度不超过 d[n]+K 的路径数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E4%B8%8A%E8%83%8C%E5%8C%85"><span class="toc-text">树上背包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E8%AF%BE"><span class="toc-text">选课</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%96%E6%B0%94%E7%90%83"><span class="toc-text">取气球</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B4%9B%E8%B0%B7-P1273-%E6%9C%89%E7%BA%BF%E7%94%B5%E8%A7%86%E7%BD%91"><span class="toc-text">洛谷 P1273 有线电视网</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%92%E5%88%86%E5%9E%8B-DP"><span class="toc-text">划分型 DP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#K-%E4%B8%AA%E4%B8%8D%E7%9B%B8%E4%BA%A4%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86"><span class="toc-text">K 个不相交子数组的最大得分</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4-DP"><span class="toc-text">区间 DP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BF%BB%E8%BD%AC%E5%AD%90%E6%AE%B5"><span class="toc-text">翻转子段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A0%96%E5%9D%97%E6%B6%82%E8%89%B2"><span class="toc-text">砖块涂色</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%AF%E5%BD%A2%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E9%97%B4-DP"><span class="toc-text">环形数组的区间 DP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E6%9E%9A%E4%B8%BE%E9%A1%BA%E5%BA%8F"><span class="toc-text">注意枚举顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E4%B8%8D%E5%90%8C%E7%9A%84%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">统计不同的回文子序列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E5%8C%85-DP"><span class="toc-text">背包 DP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#01-%E8%83%8C%E5%8C%85%E6%B1%82%E6%96%B9%E6%A1%88%E6%95%B0"><span class="toc-text">01 背包求方案数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E6%92%A4%E9%94%80%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E6%96%B9%E6%A1%88%E6%95%B0"><span class="toc-text">可撤销多重背包方案数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E6%B1%82%E6%9C%80%E5%80%BC"><span class="toc-text">多重背包求最值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A0%9D%E7%A0%81%E7%A7%B0%E9%87%8D"><span class="toc-text">砝码称重</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E5%8C%96%E4%B8%BA%E8%83%8C%E5%8C%85-%E5%88%86%E6%B2%BB"><span class="toc-text">转化为背包 + 分治</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%88%96%E5%92%8C%E4%B9%9F%E8%83%BD%E8%BD%AC%E5%8C%96%E4%B8%BA%E8%83%8C%E5%8C%85%EF%BC%9F%EF%BC%81"><span class="toc-text">异或和也能转化为背包？！</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E7%BF%BB%E8%AF%91"><span class="toc-text">背包问题的翻译</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#01-%E8%83%8C%E5%8C%85%E5%8F%98%E5%BD%A2%E9%A2%98"><span class="toc-text">01 背包变形题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%8C%E5%8C%85-%E5%AE%B9%E6%96%A5"><span class="toc-text">背包 + 容斥</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6%E4%B9%9F%E8%83%BD%E6%98%AF%E8%83%8C%E5%8C%85"><span class="toc-text">石子合并也能是背包</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96-DP"><span class="toc-text">数据结构优化 DP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%92%8C"><span class="toc-text">最大上升子序和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%81%E5%89%AA%E5%BA%8F%E5%88%97"><span class="toc-text">裁剪序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C%E6%88%96%E6%BB%91%E7%AA%97-%E4%BC%98%E5%8C%96%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85"><span class="toc-text">前缀和或滑窗 优化多重背包</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E5%BD%A2-DP"><span class="toc-text">树形 DP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91"><span class="toc-text">最小高度树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%82%E6%A0%91%E4%B8%8A%E9%95%BF%E5%BA%A6%E6%81%B0%E5%A5%BD%E4%B8%BA-k-%E7%9A%84%E8%B7%AF%E5%BE%84%E4%B8%AA%E6%95%B0"><span class="toc-text">求树上长度恰好为 k 的路径个数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8D%A2%E6%A0%B9-DP-%E8%A7%A3%E5%86%B3%E7%99%BD%E8%89%B2%E7%82%B9-%E9%BB%91%E8%89%B2%E7%82%B9%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-text">换根 DP 解决白色点-黑色点的最大值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%82-sigma-d-i-a-i-for-%E6%AF%8F%E4%B8%AA%E7%82%B9%E4%B8%BA%E6%A0%B9"><span class="toc-text">求 sigma(d[i]*a[i]) for 每个点为根</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%81%AF%E9%A5%B0%E2%80%94%E2%80%94%E7%8A%B6%E6%80%81%E8%AE%BE%E8%AE%A1"><span class="toc-text">二叉树灯饰——状态设计</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96-DP"><span class="toc-text">优化 DP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E7%BC%80%E5%92%8C%E4%BC%98%E5%8C%96"><span class="toc-text">后缀和优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CF1913D-%E5%8D%95%E8%B0%83%E6%A0%88%E4%BC%98%E5%8C%96-DP"><span class="toc-text">CF1913D 单调栈优化 DP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%82-min-max-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C%EF%BC%8C-%E6%9C%80%E5%B0%8F%E5%AD%90%E6%AE%B5%E5%92%8C"><span class="toc-text">求 min(max(最大子段和，| 最小子段和 |))</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%BC%80-max-%E4%BC%98%E5%8C%96-DP"><span class="toc-text">前缀 max 优化 DP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%92%E5%88%86%E6%95%B0%E5%AD%97%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0"><span class="toc-text">划分数字的方案数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%86%E5%BA%8F%E5%AF%B9%E7%9B%B8%E5%85%B3%E7%9A%84-DP"><span class="toc-text">逆序对相关的 DP</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B8%E9%A2%98"><span class="toc-text">典题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E9%95%BF%E5%BA%A6"><span class="toc-text">最长公共上升子序列长度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%9A%E9%9A%8F%E6%9C%BA%E5%8C%96"><span class="toc-text">不同的子序列：随机化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C"><span class="toc-text">最大子段和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E4%BF%AE%E6%94%B9%E5%BA%8F%E5%88%97%E7%9A%84%E4%B8%80%E4%B8%AA%E6%95%B0%EF%BC%8C%E9%97%AE%E4%B9%8B%E5%90%8E%E7%9A%84-LIS-%E9%95%BF%E5%BA%A6"><span class="toc-text">任意修改序列的一个数，问之后的 LIS 长度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%8A%E6%95%B0%E7%BB%84%E5%88%92%E6%88%90-k-%E4%B8%AA%E5%8C%BA%E9%97%B4%EF%BC%8C%E7%BB%99%E5%AE%9A%E6%AF%8F%E4%B8%AA%E5%8C%BA%E9%97%B4%E7%9A%84%E6%9D%83%E5%80%BC%EF%BC%8C%E9%97%AE-sigma-%E5%8C%BA%E9%97%B4%E5%92%8C-%E6%9D%83%E5%80%BC-%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-text">把数组划成 k 个区间，给定每个区间的权值，问 sigma(区间和*权值)最大值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%91%98%E6%A8%B1%E6%A1%83"><span class="toc-text">摘樱桃</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%B1%BB%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0"><span class="toc-text">第一类斯特林数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%B1%BB%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0"><span class="toc-text">第二类斯特林数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#262144"><span class="toc-text">262144</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0-DP"><span class="toc-text">计数 DP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97"><span class="toc-text">括号序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B4%BB%E5%AD%97%E5%8D%B0%E5%88%B7"><span class="toc-text">活字印刷</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E6%A0%BC%E5%9B%BE%E4%B8%8A%E6%94%BE%E7%A7%AF%E6%9C%A8"><span class="toc-text">网格图上放积木</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E5%8E%8B-DP"><span class="toc-text">状压 DP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B8%E4%B8%AD%E5%85%B8%EF%BC%9ALCP-69-Hello-LeetCode"><span class="toc-text">典中典：LCP 69. Hello LeetCode!</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A3%9E%E6%9C%BA%E9%99%8D%E8%90%BD"><span class="toc-text">飞机降落</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E5%AD%90%E9%9B%86"><span class="toc-text">二进制表示子集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E5%BF%85%E8%A6%81%E5%9B%A2%E9%98%9F"><span class="toc-text">最小必要团队</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%88%97%E5%9E%8B%E7%8A%B6%E5%8E%8B-DP"><span class="toc-text">排列型状压 DP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P1357-%E8%8A%B1%E5%9B%AD%EF%BC%88%E7%8E%AF%E5%BD%A2%E3%80%81%E7%9F%A9%E9%98%B5%EF%BC%89"><span class="toc-text">P1357 花园（环形、矩阵）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E6%97%A0%E5%90%91%E5%9B%BE%E4%B8%AD%E7%9A%84%E7%AE%80%E5%8D%95%E7%8E%AF"><span class="toc-text">统计无向图中的简单环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%B6%E5%83%8F%E5%87%BA%E5%88%97%EF%BC%81"><span class="toc-text">偶像出列！</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DP-%E6%9E%84%E9%80%A0"><span class="toc-text">DP + 构造</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E5%85%AC%E5%85%B1%E8%B6%85%E5%BA%8F%E5%88%97"><span class="toc-text">最短公共超序列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%9C%BA-DP"><span class="toc-text">状态机 DP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%95%BF%E4%B8%BA-n-%E7%9A%84%E4%B8%B2%EF%BC%8C%E5%90%AB%E6%9C%89-l-e-e-t%EF%BC%8C%E9%97%AE%E6%96%B9%E6%A1%88%E6%95%B0"><span class="toc-text">问长为 n 的串，含有 l e e t，问方案数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84-7-%E8%BF%9B%E5%88%B6%E7%8A%B6%E5%8E%8B%E2%80%94%E2%80%94%E9%AD%94%E6%B3%95%E6%A3%8B%E7%9B%98"><span class="toc-text">基于状态机的 7 进制状压——魔法棋盘</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SOS-DP"><span class="toc-text">SOS-DP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%82-a-i-a-j-a-i-a-j-%E7%9A%84%E6%95%B0%E5%AF%B9%E6%95%B0"><span class="toc-text">求 a[i]+a[j]&#x3D;a[i]^a[j] 的数对数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E9%81%93-SOS-DP-%E7%9A%84%E7%BB%8F%E5%85%B8%E9%A2%98"><span class="toc-text">两道 SOS-DP 的经典题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8C%B6%E4%B8%AD-DP"><span class="toc-text">茶中 DP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%88%92%E5%88%86%E4%B8%BA-k-%E6%AE%B5%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9A%84%E5%88%86"><span class="toc-text">数组划分为 k 段的最大的分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E4%B8%8A-DP-%E6%96%B0%E5%A5%87%E7%9A%84%E7%BB%B4%E5%BA%A6%E8%AE%BE%E8%AE%A1"><span class="toc-text">图上 DP 新奇的维度设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7-DP-%E6%B1%82%E6%96%B9%E6%A1%88%E6%95%B0"><span class="toc-text">线性 DP 求方案数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96-DP"><span class="toc-text">单调队列优化 DP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DP-%E6%9E%84%E9%80%A0-1"><span class="toc-text">DP + 构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F-DP"><span class="toc-text">延迟 DP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%81%E8%BF%9B%E5%88%B6-SOS-DP"><span class="toc-text">十进制 SOS DP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80-DP-%E4%BD%86%E8%A6%81%E4%BC%98%E5%8C%96%E7%A9%BA%E9%97%B4"><span class="toc-text">基础 DP 但要优化空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TSP-%E9%97%AE%E9%A2%98"><span class="toc-text">TSP 问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C%E4%BC%98%E5%8C%96-DP"><span class="toc-text">前缀和优化 DP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%99%E6%95%B0%E8%83%8C%E5%8C%85-DP"><span class="toc-text">余数背包 DP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%9F%E6%9C%9B-DP-%E5%85%A5%E9%97%A8"><span class="toc-text">期望 DP 入门</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E6%B1%82%E6%AF%8F%E6%AE%B5%E4%B9%98%E7%A7%AF%E5%92%8C"><span class="toc-text">分割数组求每段乘积和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%95%B0%E5%88%86%E7%B1%BB-DP"><span class="toc-text">模数分类 DP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E5%A5%87-DP-%E4%B8%80%E6%AC%A1%E8%80%83%E8%99%91%E8%BF%9E%E7%BB%AD%E4%B8%89%E4%B8%AA%E7%82%B9"><span class="toc-text">新奇 DP 一次考虑连续三个点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%AD%90%E5%BA%8F%E5%88%97-DP"><span class="toc-text">简单子序列 DP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E5%BA%8F%E5%88%97%E4%B8%8D%E5%90%AB-hard-%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0"><span class="toc-text">子序列不含 hard 的方案数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E6%96%B0%E5%BD%A2%E5%BC%8F%E7%9A%84-DP"><span class="toc-text">全新形式的 DP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E4%BA%86%E5%BE%88%E4%B9%85%E7%9A%84%E5%8D%95%E8%B0%83%E6%A0%88-DP"><span class="toc-text">理解了很久的单调栈 DP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88%EF%BC%8C%E7%94%A8%E6%A0%91%E5%BD%A2-DP-%E6%9D%A5-check"><span class="toc-text">二分答案，用树形 DP 来 check</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E4%B8%AD%E4%B8%8A%E4%B8%8B%E8%B5%B0%E7%9A%84%E6%8D%A2%E6%A0%B9-DP"><span class="toc-text">树中上下走的换根 DP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%B1-1-%E5%92%8C-1-%E6%9E%84%E6%88%90%E7%9A%84%E7%9F%A9%E9%98%B5%EF%BC%8C%E9%97%AE%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E5%92%8C%E4%B8%BA-0-%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-text">由 1 和-1 构成的矩阵，问是否存在和为 0 的路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E4%B8%AD%E4%B8%8E%E8%B7%9D%E7%A6%BB%E6%9C%80%E8%BF%9C%E7%9A%84%E7%82%B9%E6%9C%89%E5%85%B3%E7%9A%84%E6%8D%A2%E6%A0%B9-DP"><span class="toc-text">树中与距离最远的点有关的换根 DP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%92%E5%88%86%E6%96%B9%E6%A1%88-DP"><span class="toc-text">字符串划分方案 DP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%E5%AE%9E%E7%8E%B0%E5%8C%BA%E9%97%B4-DP"><span class="toc-text">用记忆化搜索实现区间 DP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C%E4%BC%98%E5%8C%96-DP%EF%BC%88%E6%95%B0%E8%BD%B4%E4%B8%8A%E7%A7%BB%E5%8A%A8%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0%EF%BC%89"><span class="toc-text">前缀和优化 DP（数轴上移动的方案数）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C%E8%BD%AC%E6%8D%A2%E4%B8%BA%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-text">子序列和转换为背包问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%BB%93%E5%90%88%E5%88%92%E5%88%86%E5%9E%8B-DP"><span class="toc-text">位运算结合划分型 DP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E5%90%8E%E7%BC%80%E7%A7%AF%E8%A7%A3%E5%86%B3%E9%80%86%E5%85%83-%E6%8D%A2%E6%A0%B9-DP"><span class="toc-text">前后缀积解决逆元 + 换根 DP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E6%B1%82%E6%96%B9%E6%A1%88%E6%95%B0%EF%BC%88%E5%8C%BA%E9%97%B4-DP%EF%BC%89"><span class="toc-text">字符串操作求方案数（区间 DP）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%86%E5%90%91%E6%80%9D%E7%BB%B4-%E8%BD%AC%E5%8C%96%E4%B8%BA%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-text">逆向思维 转化为背包问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%96%B9%E6%A1%88%E6%95%B0-%E8%BD%AC%E5%8C%96%E4%B8%BA%E8%83%8C%E5%8C%85"><span class="toc-text">字符串 方案数 转化为背包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%B3%E5%B0%91%E5%9E%8B-01-%E8%83%8C%E5%8C%85"><span class="toc-text">至少型 01 背包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%88%97%E5%9E%8B%E7%8A%B6%E5%8E%8B"><span class="toc-text">排列型状压</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MEX-%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">MEX 子序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E5%9B%9E%E6%96%87%E8%B7%AF%E5%BE%84%E6%95%B0"><span class="toc-text">字符矩阵中的回文路径数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E4%BD%8D-DP-%E9%A2%84%E5%A4%84%E7%90%86"><span class="toc-text">数位 DP + 预处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%AC%E5%8F%B7%EF%BC%9A%E6%9C%80%E9%95%BF%E5%90%88%E6%B3%95%E5%AD%90%E4%B8%B2%E4%B8%AA%E6%95%B0"><span class="toc-text">括号：最长合法子串个数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E5%BA%8F%E5%88%97%E4%B9%98%E7%A7%AF%E4%B8%BA%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="toc-text">子序列乘积为完全平方数</span></a></li></ol></li></ol>
    </div>
  </section>

  

</div>


<!-- 没有 pjax 占位会报错 万恶的 pjax -->

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <!-- Custom Files side begin -->
  
  <!-- Custom Files side end -->
</aside>



          <!--此文件用来存放一些不方便取值的变量-->
<!--思路大概是将值藏到重加载的区域内-->

<pjax>
<script>
  window.pdata={}
  pdata.ispage=true;
  pdata.commentPath="";
  pdata.commentPlaceholder="";
  pdata.commentConfig={};
  //  see: /layout/_partial/scripts/_ctrl/coverCtrl.ejs
  
    // header
    var l_header=document.getElementById("l_header");
    
    l_header.classList.remove("show");
    
    
      // cover
      var cover_wrapper=document.querySelector('#l_cover .cover-wrapper');
      var scroll_down=document.getElementById('scroll-down');
      cover_wrapper.id="half";
      cover_wrapper.style.display="";
      scroll_down.style.display="none";
    
  
</script>
</pjax>
        </div>
        
  
  <footer class="footer clearfix"  itemscope itemtype="http://schema.org/WPFooter">
    <br><br>
    
      
        <div class="aplayer-container">
          


        </div>
      
    
      
        <br>
        <div class="social-wrapper" itemprop="about" itemscope itemtype="http://schema.org/Thing">
          
            
              <a href="https://leetcode.cn/u/ricky-daxia/"
                class="social fa-solid fa-code flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer" itemprop="url">
                
              </a>
            
          
            
              <a href="mailto:1915754435@qq.com"
                class="social fa-solid fa-envelope flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer" itemprop="url">
                
              </a>
            
          
            
              <a href="https://github.com/Ricky-Daxia"
                class="social fab fa-github flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer" itemprop="url">
                
              </a>
            
          
            
              <a href="https://space.bilibili.com/109098553"
                class="social fa-brands fa-bilibili flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer" itemprop="url">
                
              </a>
            
          
        </div>
      
    
      
        <div><p>博客内容遵循 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
      
    
      
        本站使用
        <a href="https://github.com/volantis-x/hexo-theme-volantis/#5.8.0" target="_blank" class="codename">Volantis</a>
        作为主题
      
    
    <!-- Custom Files footer begin-->
    
    <!-- Custom Files footer end-->
  </footer>


        <a id="s-top" class="fa-solid fa-arrow-up fa-fw" href="/" onclick="return false;" title="top"></a>
      </div>
    </div>
    <div>
      <script>
  /******************** volantis.dom ********************************/
  // 页面选择器 将dom对象缓存起来 see: /source/js/app.js etc.
  volantis.dom.bodyAnchor = volantis.dom.$(document.getElementById("safearea")); // 页面主体
  volantis.dom.topBtn = volantis.dom.$(document.getElementById('s-top')); // 向上
  volantis.dom.wrapper = volantis.dom.$(document.getElementById('wrapper')); // 整个导航栏
  volantis.dom.coverAnchor = volantis.dom.$(document.querySelector('#l_cover .cover-wrapper')); // 1个
  volantis.dom.switcher = volantis.dom.$(document.querySelector('#l_header .switcher .s-search')); // 搜索按钮   移动端 1个
  volantis.dom.header = volantis.dom.$(document.getElementById('l_header')); // 移动端导航栏
  volantis.dom.search = volantis.dom.$(document.querySelector('#l_header .m_search')); // 搜索框 桌面端 移动端 1个
  volantis.dom.mPhoneList = volantis.dom.$(document.querySelectorAll('#l_header .m-phone .list-v')); //  手机端 子菜单 多个
</script>

<script>
  
  volantis.css("https://unpkg.com/volantis-static@0.0.1654736714924/libs/@fortawesome/fontawesome-free/css/all.min.css");
  
  
  
</script>

<!-- required -->


<!-- internal -->

<script src="/js/app.js"></script>






<!-- rightmenu要在darkmode之前（ToggleButton） darkmode要在comments之前（volantis.dark.push）-->



<script>
  function loadIssuesJS() {
    
      const sites_api = document.getElementById('sites-api');
      if (sites_api != undefined && typeof SitesJS === 'undefined') {
        volantis.js("/js/plugins/tags/sites.js")
      }
    
    
      const friends_api = document.getElementById('friends-api');
      if (friends_api != undefined && typeof FriendsJS === 'undefined') {
        volantis.js("/js/plugins/tags/friends.js")
      }
    
    
      const contributors_api = document.getElementById('contributors-api');
      if (contributors_api != undefined && typeof ContributorsJS === 'undefined') {
        volantis.js("/js/plugins/tags/contributors.js")
      }
    
  };
  loadIssuesJS()
  volantis.pjax.push(()=>{
    loadIssuesJS();
  })

</script>




  <script defer src="https://unpkg.com/volantis-static@0.0.1654736714924/libs/vanilla-lazyload/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 0
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    lazyLoadInstance.update();
  });
  document.addEventListener('pjax:complete', function () {
    lazyLoadInstance.update();
  });
</script>




  

<script>
  window.FPConfig = {
	delay: 0,
	ignoreKeywords: ["#"],
	maxRPS: 6,
	hoverDelay: 0
  };
</script>
<script defer src="https://unpkg.com/volantis-static@0.0.1654736714924/libs/flying-pages/flying-pages.min.js"></script>









      <script>
  volantis.layoutHelper("comments",`<div id="giscus_container"></div>`)

  volantis.giscus = {};

  function check_giscus() {
    if (volantis.dark.mode === "dark") {
      volantis.giscus.Theme = 'dark';
    } else {
      volantis.giscus.Theme = 'light';
    }

    return document.getElementById("giscus_container");
  }

  function pjax_giscus() {
    const HEAD = check_giscus();
    if (!HEAD) return;
    let cfg = Object.assign({"theme":{"light":"light","dark":"dark"},"repo":"Ricky-Daxia/comments","repo-id":"R_kgDOMV5HSg","category":"Announcements","category-id":"DIC_kwDOMV5HSs4CgxFo","mapping":"pathname","reactions-enabled":"1","emit-metadata":"0","lang":"zh-CN"},pdata.commentConfig)
    const script = document.createElement('script');
    script.setAttribute('src', 'https://giscus.app/client.js');
    Object.keys(cfg).forEach(k=>{
      if (k != "theme") {
        script.setAttribute('data-'+k, cfg[k]);
      }
    })
    script.setAttribute('data-theme', volantis.giscus.Theme);
    script.setAttribute('crossorigin', "anonymous");
    HEAD.appendChild(script);
  }

  function dark_giscus() {
    const HEAD = check_giscus();
    if (!HEAD) return;

    const message = {
      setConfig: {
        theme: volantis.giscus.Theme
      }
    };
    const giscusIframe = document.querySelector('iframe.giscus-frame');
    giscusIframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
  }
  pjax_giscus();
  volantis.pjax.push(pjax_giscus);
  volantis.dark.push(dark_giscus);
</script>

    





<!-- optional -->

  <script>
  const SearchServiceDataPathRoot = ("/" || "/").endsWith("/") ?
    "/" || "/" :
    "//" || "/";
  const SearchServiceDataPath = SearchServiceDataPathRoot + "content.json";

  function loadSearchScript() {
    // see: layout/_partial/scripts/_ctrl/cdnCtrl.ejs
    return volantis.js("/js/search/hexo.js");
  }

  function loadSearchService() {
    loadSearchScript();
    document.querySelectorAll(".input.u-search-input").forEach((e) => {
      e.removeEventListener("focus", loadSearchService, false);
    });

    document.querySelectorAll(".u-search-form").forEach((e) => {
      e.addEventListener("submit", (event) => {
        event.preventDefault();
      }, false);
    });
  }

  // 打开并搜索 字符串 s
  function OpenSearch(s) {
    if (typeof SearchService === 'undefined')
      loadSearchScript().then(() => {
        SearchService.setQueryText(s);
        SearchService.search();
      });
    else {
      SearchService.setQueryText(s);
      SearchService.search();
    }
  }

  // 访问含有 ?s=xxx  的链接时打开搜索 // 与搜索引擎 structured data 相关: /scripts/helpers/structured-data/lib/config.js
  if (window.location.search && /^\?s=/g.test(window.location.search)) {
    let queryText = decodeURI(window.location.search)
      .replace(/\ /g, "-")
      .replace(/^\?s=/g, "");
    OpenSearch(queryText);
  }

  // 搜索输入框获取焦点时加载搜索
  document.querySelectorAll(".input.u-search-input").forEach((e) => {
    e.addEventListener("focus", loadSearchService, false);
  });
</script>







  <script>

  volantis.css("https://unpkg.com/@highlightjs/cdn-assets@11.5.1/styles/default.min.css");


  volantis.js("https://unpkg.com/@highlightjs/cdn-assets@11.5.1/highlight.min.js").then(()=>{
    volantis.requestAnimationFrame(hljs.highlightAll)
  })
  volantis.pjax.push(()=>{
    document.querySelectorAll('pre code').forEach((block) => {
      hljs.highlightElement(block);
    });
  },"highlightjs")


  function pjax_highlightjs_copyCode(){
    if (!(document.querySelector(".highlight .code pre") ||
      document.querySelector(".article pre code"))) {
      return;
    }
    VolantisApp.utilCopyCode(".highlight .code pre, .article pre code")
  }
  volantis.requestAnimationFrame(pjax_highlightjs_copyCode)
  volantis.pjax.push(pjax_highlightjs_copyCode)

</script>












  <script>
  function load_swiper() {
    if (!document.querySelectorAll(".swiper-container")[0]) return;
    volantis.css("https://unpkg.com/volantis-static@0.0.1654736714924/libs/swiper/swiper-bundle.min.css");
    volantis.js("https://unpkg.com/volantis-static@0.0.1654736714924/libs/swiper/swiper-bundle.min.js").then(() => {
      pjax_swiper();
    });
  }

  load_swiper();

  function pjax_swiper() {
    volantis.swiper = new Swiper('.swiper-container', {
      slidesPerView: 'auto',
      spaceBetween: 8,
      centeredSlides: true,
      loop: true,
      pagination: {
        el: '.swiper-pagination',
        clickable: true,
      },
      navigation: {
        nextEl: '.swiper-button-next',
        prevEl: '.swiper-button-prev',
      },
    });
  }

  volantis.pjax.push(() => {
    if (!document.querySelectorAll(".swiper-container")[0]) return;
    if (typeof volantis.swiper === "undefined") {
      load_swiper();
    } else {
      pjax_swiper();
    }
  });
</script>


<!-- pjax 标签必须存在于所有页面 否则 pjax error -->
<pjax>

        <script>
  // https://github.com/theme-next/hexo-theme-next/blob/master/layout/_third-party/math/mathjax.swig
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = "https://unpkg.com/volantis-static@0.0.1654736714924/libs/mathjax/es5/tex-mml-chtml.js";
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    // 文章章节标题不能为 “MathJax” ，否则会报错。
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typesetPromise();
  }
</script>



</pjax>

<script>
  function listennSidebarTOC() {
    const navItems = document.querySelectorAll(".toc li");
    if (!navItems.length) return;
    let targets = []
    const sections = [...navItems].map((element) => {
      const link = element.querySelector(".toc-link");
      const target = document.getElementById(
        decodeURI(link.getAttribute("href")).replace("#", "")
      );
      targets.push(target)
      // 解除 a 标签 href 的 锚点定位, a 标签 href 的 锚点定位 会随机启用?? 产生错位???
      link.setAttribute("onclick","return false;")
      link.setAttribute("toc-action","toc-"+decodeURI(link.getAttribute("href")).replace("#", ""))
      link.setAttribute("href","/")
      // 配置 点击 触发新的锚点定位
      link.addEventListener("click", (event) => {
        event.preventDefault();
        // 这里的 addTop 是通过错位使得 toc 自动展开.
        volantis.scroll.to(target,{addTop: 5, observer:true})
        // Anchor id
        history.pushState(null, document.title, "#" + target.id);
      });
      return target;
    });

    function activateNavByIndex(target) {
      if (target.classList.contains("active-current")) return;

      document.querySelectorAll(".toc .active").forEach((element) => {
        element.classList.remove("active", "active-current");
      });
      target.classList.add("active", "active-current");
      let parent = target.parentNode;
      while (!parent.matches(".toc")) {
        if (parent.matches("li")) parent.classList.add("active");
        parent = parent.parentNode;
      }
    }

    // 方案一：
    volantis.activateNavIndex=0
    activateNavByIndex(navItems[volantis.activateNavIndex])
    volantis.scroll.push(()=>{
      if (targets[0].getBoundingClientRect().top >= 0) {
        volantis.activateNavIndex = 0
      }else if (targets[targets.length-1].getBoundingClientRect().top < 0) {
        volantis.activateNavIndex = targets.length-1
      } else {
        for (let index = 0; index < targets.length; index++) {
          const target0 = targets[index];
          const target1 = targets[(index+1)%targets.length];
          if (target0.getBoundingClientRect().top < 0&&target1.getBoundingClientRect().top >= 0) {
            volantis.activateNavIndex=index
            break;
          }
        }
      }
      activateNavByIndex(navItems[volantis.activateNavIndex])
    })

    // 方案二：
    // IntersectionObserver 不是完美精确到像素级别 也不是低延时性的
    // function findIndex(entries) {
    //   let index = 0;
    //   let entry = entries[index];
    //   if (entry.boundingClientRect.top > 0) {
    //     index = sections.indexOf(entry.target);
    //     return index === 0 ? 0 : index - 1;
    //   }
    //   for (; index < entries.length; index++) {
    //     if (entries[index].boundingClientRect.top <= 0) {
    //       entry = entries[index];
    //     } else {
    //       return sections.indexOf(entry.target);
    //     }
    //   }
    //   return sections.indexOf(entry.target);
    // }
    // function createIntersectionObserver(marginTop) {
    //   marginTop = Math.floor(marginTop + 10000);
    //   let intersectionObserver = new IntersectionObserver(
    //     (entries, observe) => {
    //       let scrollHeight = document.documentElement.scrollHeight;
    //       if (scrollHeight > marginTop) {
    //         observe.disconnect();
    //         createIntersectionObserver(scrollHeight);
    //         return;
    //       }
    //       let index = findIndex(entries);
    //       activateNavByIndex(navItems[index]);
    //     }, {
    //       rootMargin: marginTop + "px 0px -100% 0px",
    //       threshold: 0,
    //     }
    //   );
    //   sections.forEach((element) => {
    //     element && intersectionObserver.observe(element);
    //   });
    // }
    // createIntersectionObserver(document.documentElement.scrollHeight);
  }

  document.addEventListener("DOMContentLoaded", ()=>{
    volantis.requestAnimationFrame(listennSidebarTOC)
  });
  document.addEventListener("pjax:success", ()=>{
    volantis.requestAnimationFrame(listennSidebarTOC)
  });
</script>



<script>
  document.onreadystatechange = function () {
    if (document.readyState == 'complete') {
      // 页面加载完毕 样式加载失败，或是当前网速慢，或是开启了省流模式
      const { saveData, effectiveType } = navigator.connection || navigator.mozConnection || navigator.webkitConnection || {}
      if (getComputedStyle(document.querySelector("#safearea"), null)["display"] == "none" || saveData || /2g/.test(effectiveType)) {
        document.querySelectorAll(".reveal").forEach(function (e) {
          e.style["opacity"] = "1";
        });
        document.querySelector("#safearea").style["display"] = "block";
      }
    }
  }
</script>


  <script type="application/ld+json">[{"@context":"http://schema.org","@type":"Organization","name":"Rikki's Blog","url":"https://ricky-daxia.github.io/","logo":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png","width":192,"height":192}},{"@context":"http://schema.org","@type":"Person","name":"Ligu","image":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png"},"url":"https://ricky-daxia.github.io/","sameAs":["https://github.com/volantis-x"],"description":"hhh"},{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://ricky-daxia.github.io/","name":"Rikki's Blog"}},{"@type":"ListItem","position":2,"item":{"@id":"https://ricky-daxia.github.io/categories/算法/","name":"算法"}},{"@type":"ListItem","position":3,"item":{"@id":"https://ricky-daxia.github.io/2024/07/14/动态规划题目整理/","name":"动态规划题目整理"}}]},{"@context":"http://schema.org","@type":"WebSite","name":"Rikki's Blog","url":"https://ricky-daxia.github.io/","keywords":null,"description":"hhh","author":{"@type":"Person","name":"Ligu","image":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png"},"url":"https://ricky-daxia.github.io/","description":"hhh"},"publisher":{"@type":"Organization","name":"Rikki's Blog","url":"https://ricky-daxia.github.io/","logo":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png","width":192,"height":192}},"potentialAction":{"@type":"SearchAction","name":"Site Search","target":{"@type":"EntryPoint","urlTemplate":"https://ricky-daxia.github.io?s={search_term_string}"},"query-input":"required name=search_term_string"}},{"@context":"http://schema.org","@type":"BlogPosting","headline":"动态规划题目整理","description":"DP 题目分类整理","inLanguage":["zh-CN","en","zh-TW","default"],"mainEntityOfPage":{"@type":"WebPage","@id":"https://ricky-daxia.github.io/2024/07/14/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86/"},"author":{"@type":"Person","name":"Ligu","image":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png"},"url":"https://ricky-daxia.github.io/"},"publisher":{"@type":"Organization","name":"Rikki's Blog","logo":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png","width":192,"height":192}},"url":"https://ricky-daxia.github.io/2024/07/14/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86/","wordCount":0,"datePublished":"2024-07-14T07:13:10.000Z","dateModified":"2024-07-14T08:17:31.834Z","articleSection":"算法","keywords":"题目,动态规划","image":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png","width":192,"height":192}}]</script>



      
        <!--
  pjax重载区域接口：
  1.  <pjax></pjax> 标签 pjax 标签必须存在于所有页面 否则 pjax error
  2.  script[data-pjax]
  3.  .pjax-reload script
  4.  .pjax
-->



<script src="https://unpkg.com/volantis-static@0.0.1654736714924/libs/pjax/pjax.min.js"></script>


<script>
    var pjax;
    document.addEventListener('DOMContentLoaded', function () {
      pjax = new Pjax({
        elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([pjax-fancybox]):not([onclick="return false;"]):not([onclick="return!1"]):not([target="_blank"]):not([target="view_window"]):not([href$=".xml"])',
        selectors: [
          "head title",
          "head meta[name=keywords]",
          "head meta[name=description]",
          
          "#l_main",
          "#pjax-header-nav-list",
          ".pjax",
          "pjax", // <pjax></pjax> 标签
          "script[data-pjax], .pjax-reload script" // script标签添加data-pjax 或 script标签外层添加.pjax-reload 的script代码段重载
        ],
        cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
        timeout: 5000,
        
      });
    });

    document.addEventListener('pjax:send', function (e) {
      //window.stop(); // 相当于点击了浏览器的停止按钮

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      // 使用 volantis.pjax.send 方法传入pjax:send回调函数 参见layout/_partial/scripts/global.ejs
      volantis.pjax.method.send.start();
    });

    document.addEventListener('pjax:complete', function () {
      // 使用 volantis.pjax.push 方法传入重载函数 参见layout/_partial/scripts/global.ejs
      volantis.pjax.method.complete.start();
    });

    document.addEventListener('pjax:error', function (e) {
      if(volantis.debug) {
        console.error(e);
        console.log('pjax error: \n' + JSON.stringify(e));
      }else{
        // 使用 volantis.pjax.error 方法传入pjax:error回调函数 参见layout/_partial/scripts/global.ejs
        volantis.pjax.method.error.start();
        window.location.href = e.triggerElement.href;
      }
    });
</script>

      
    </div>
    <!-- import body_end begin-->
    <!-- import body_end end-->
    <!-- Custom Files bodyEnd begin-->
    
    <!-- Custom Files bodyEnd end-->
    <!-- front-matter body_end begin -->
    <!-- front-matter body_end end -->
  </body>
</html>
