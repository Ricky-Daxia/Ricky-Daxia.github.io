## 最短路

### dijkstra

模板

```c++
// 朴素版
int dijkstra() {
  memset(dist, 0x3f, sizeof dist);  // 初始化所有距离为无穷

  dist[1] = 0;                   // 开始点距离为0
  for (int i = 0; i < n; i++) {  // 走图
    int t = -1;  // 找到当前未确定最短距离的点中 距离最小的点

    for (int j = 1; j <= n; j++)
      if (!st[j] &&
          (t == -1 ||
           dist[t] > dist[j]))  //如果没有标记过 而且是第一个点或者距离偏小
        t = j;                  // 找到这个点

    st[t] = true;                 // 走距离最小的那个点
    for (int j = 1; j <= n; j++)  // 给所有值全部赋最短的(更新)
      dist[j] = min(dist[j], dist[t] + g[t][j]);  // 取最短的
  }
  //	cout<<0x3f3f3f3f<<endl;
  if (dist[n] == 0x3f3f3f3f) return -1;  // 不连通
  return dist[n];                        // 返回最小距离
}

// 堆优化
int dijkstra() {
  memset(dist, 0x3f, sizeof(dist));
  dist[1] = 0;
  priority_queue<PII, vector<PII>, greater<PII>> heap;  // 定义一个小根堆

  heap.push({0, 1});
  // 这个顺序不能倒，pair排序时是先根据first，再根据second，这里显然要根据距离排序
  while (heap.size()) {
    PII k = heap.top();  // 取不在集合S中距离最短的点
    heap.pop();
    int ver = k.second, distance = k.first;

    if (st[ver]) continue;
    st[ver] = true;  // 被标记过 说明当前点是冗余的

    for (int i = h[ver]; i != -1; i = ne[i]) {
      int j = e[i];  // i只是个下标 e中在存的是i这个下标对应的点
      if (dist[j] > distance + w[i]) {
        dist[j] = distance + w[i];  // 更新距离
        heap.push({dist[j], j});
      }
    }
  }
  if (dist[n] == 0x3f3f3f3f)
    return -1;
  else
    return dist[n];
}
```

模板应用起来很容易，看一些变形

#### 二元组最短路

>   [LCP 35. 电动车游城市](https://leetcode.cn/problems/DFPeFJ/)
>
>   求解 start->end 的最短路（最短时间），但约束条件是
>
>   -   电动车行驶容量上限为 cnt
>   -   每个点都有一个 chrage[i]，表示充一格电的时间
>
>   数据范围：n<200, cnt<100, charge[i]<100
>
>   可能有重边！

容易想到设计 (u, power) 作为状态的表示，但在这种表示下如何求解最短路？

正确的抽象：进行一个映射，即有 n*cnt 个点，求解的终点就是 (end, 0) 对应的值

怎么更新最短路？分成两部分

-   (u, power) 不充电的情况下可以更新的距离：考虑邻居和边权
-   充电的话只充一格电，即 (u, power)->(u,power+1)，接下来的事情交给这个点的逻辑去处理

```c++
class Solution {
public:
    using PII = pair<int, int>;
    int electricCarPlan(vector<vector<int>>& paths, int cnt, int start, int end, vector<int>& charge) {
        int n = paths.size();
        int g[n][n];
        memset(g, 0x3f, sizeof g);
        for (auto &t: paths) 
            g[t[0]][t[1]] = g[t[1]][t[0]] = min(g[t[0]][t[1]], t[2]);
        
        auto encode = [&](int u, int p) -> int {
            return u * (cnt + 1) + p;
        };

        auto decode = [&](int mask) -> PII {
            return {mask / (cnt + 1), mask % (cnt + 1)};
        };

        int dist[n * (cnt + 1)];
        bool st[n * (cnt + 1)];
        memset(dist, 0x3f, sizeof dist);
        memset(st, 0, sizeof st);
        priority_queue<PII, vector<PII>, greater<PII>> q;

        dist[encode(start, 0)] = 0;
        q.push({0, encode(start, 0)});
        while (q.size()) {
            auto [d, mask] = q.top();
            q.pop();
            if (st[mask]) continue;
            st[mask] = 1;
            auto [u, p] = decode(mask);
            if (u == end) return d; // 第一次到达 此时 power=0
            // neighbor
            for (int i = 0; i < n; i++) {
                int len = g[u][i];
                if (len == 0x3f3f3f3f) continue;
                if (p >= len)
                    if (int nxt = encode(i, p - len); d + len < dist[nxt]) {
                        dist[nxt] = d + len;
                        q.push({d + len, nxt});
                    }
            }
            // charge
            if (p < cnt && d + charge[u] < dist[mask + 1]) {
                dist[mask + 1] = d + charge[u];
                q.push({d + charge[u], mask + 1});
            }
        }
        return -1;
    }
};
```









## 环相关

### 拓扑排序

模板，很容易记住了

```c++
bool topsort() {
	int hh = 0, tt = -1;
	for (int i = 1; i <= n; i++)
		if (!d[i])
			q[++tt] = i;
	while (hh <= tt) {
		int t = q[hh++];
		for (int i = h[t]; i != -1; i = ne[i]) {
			int j = e[i];
			d[j]--;
			if (d[j] == 0)
				q[++tt] = j;
		}
	}
	return tt == n - 1;
}
```

#### 无向图环相关

无向图判断有无环的话，可以 dfs 然后用 V == E/2+1 来判断

如果想知道哪些点在环上怎么办？

>   [LCP 21. 追逐游戏](https://leetcode.cn/problems/Za25hA/)
>
>   有 n 个点，n 条边构成无向连通图。A 要追 B，开始时在不同位置上，每秒钟 A 先行动，B 在行动
>
>   行动分为两种：不动，移动至邻点
>
>   问最少需要几秒追到，或追不到
>
>   数据范围 1e5

这道题自己想出了一部分，首先从样例可以得到提示，如果有一个环，那么就抓不到，否则的话，B 应该要逃到某个叶子节点上。那么首先要用 bfs 求最短路，知道 A 到每个点的最短距离，然后求 B 的最短路，也是 bfs，只是如果一个点 B 的最短距离大于 A 的话，就认为这个点不可达，因为不能途径这个点逃到别的点上去

然后就要考虑哪些点在环上了，这部分没想到

-   本题只有 n 条边，因此最多只有一个环！

-   B 如果先逃到环上，那么就抓不到

-   如果环长只有 3，就算先逃到环上，也一定会被抓住

-   怎么判环：类似于拓扑排序，记录每个点的出度，初始时把出度为 1 的点入队，最后出度为 2 的点就在环上

-   ```c++
    // 找环 拓扑排序 找环
    queue<int> q;
    for(int i = 1;i <= n;i ++) if(isRing[i] == 1) q.push(i);
    while(!q.empty()) {
        int t = q.front(); q.pop();
        for(auto& next : g[t]) {
            if(isRing[next] == 1) continue;
            isRing[next] --;
            if(isRing[next] == 1) q.push(next);
        }
    }
    ```

-   不被抓到的条件：B 在大于 3 的环上，或者 B 可以先逃到环上

-   否则，遍历每个点求最长时间差

```c++
class Solution {
public:
    const int INF = 0x3f3f3f3f;
    int chaseGame(vector<vector<int>>& edges, int startA, int startB) {
        int n = edges.size();
        vector<int> g[n + 1];
        vector<int> d(n + 1);
        for (auto &e: edges) {
            g[e[0]].push_back(e[1]);
            g[e[1]].push_back(e[0]);
            d[e[0]] ++, d[e[1]] ++;
            // 特判
            if (e[0] == startA && e[1] == startB) return 1;
            if (e[1] == startA && e[0] == startB) return 1;
        }
        vector<int> distA(n + 1, INF);
        vector<bool> st(n + 1);
        int cnt = -1;
        queue<int> q;
        q.push(startA);
        st[startA] = 1;
        while (q.size()) {
            ++ cnt;
            int sz = q.size();
            while (sz -- ) {
                int x = q.front();
                q.pop();
                distA[x] = cnt;
                for (int y: g[x])
                    if (!st[y]) {
                        st[y] = 1;
                        q.push(y);
                    }
            }
        }
        vector<int> distB(n + 1, INF);
        fill(st.begin(), st.end(), 0);
        cnt = -1;
        q.push(startB);
        st[startB] = 1;
        while (q.size()) {
            ++ cnt;
            int sz = q.size();
            while (sz -- ) {
                int x = q.front();
                q.pop();
                distB[x] = cnt;
                for (int y: g[x])
                    if (!st[y] && cnt + 1 < distA[y]) {
                        st[y] = 1;
                        q.push(y);
                    }
            }
        }
        for (int i = 1; i <= n; i++)
            if (d[i] == 1) q.push(i);
        while (q.size()) {
            int x = q.front();
            q.pop();
            // d[x] --;
            for (int y: g[x]) {
                if (d[y] == 1) continue;
                if (-- d[y] == 1) q.push(y);
            }
        }
        int ring = 0;
        for (int i = 1; i <= n; i++)
            if (d[i] == 2) ring ++;
        
        if (ring > 3) {
            if (d[startB] == 2) return -1;
            for (int i = 1; i <= n; i++)
                if (d[i] == 2 && distB[i] < distA[i] - 1) return -1;
        }
        int res = 0;
        for (int i = 1; i <= n; i++) {
            // cout << i << ' ' << distA[i] << ' ' << distB[i] << endl;
            if (distB[i] < distA[i] - 1) {
                res = max(res, distA[i]);
            }            
        }

        return res;
    }
};
```





### 二分图相关

#### 一道典题

>   [2493. 将节点分成尽可能多的组](https://leetcode.cn/problems/divide-nodes-into-the-maximum-number-of-groups/)
>
>   给一个无向图，不一定连通，把顶点分组，满足每个点都属于一个组，对于边 (a, b)，abs(group[a]-group[b])=1，问最多分成几个组
>
>   点数<500，边数是 1e4

每条边的两个顶点不属于同一个组，有点二分图的意思，又有点按层分组的意味，是不是要 bfs？

规定第 1 组里只有一个点，枚举这个点 s 并对整个连通块进行 BFS。设点 s 到同一连通块内点 u 的最短距离为 d(u)，那么点 u 就被分在第 d(u)+1 组。我们枚举连通块中的所有边 (u,v) 并检查是否合法，如果解合法，那么答案就是 max(d(u))+1

接下来证明这个做法的最优性。

首先说明如果该做法无法求出解，则原图一定无解。

根据最短路的三角不等式，任意一条边 (u,v) 都满足 ∣d(u)−d(v)∣≤1。
也就是说，当且仅当同一组内的两个点有连边时，该做法无法求出解。
而如果同一组内的两个点有连边，则说明原图有奇环，一定无解。

>   无奇环等价于二分图，也可以先用染色法判断二分图

接下来说明存在一个最优解，使得第 1 组一定只有一个点。

假设最优解中第 1 组有超过一个点，那么这些点肯定与第 2 组中的点有连边。因此我们可以把多余的点都移动到第 3 组，解仍然可行，且不会变差

```c++
class Solution {
public:
    int magnificentSets(int n, vector<vector<int>>& edges) {
        vector<int> e[n + 1];
        for (auto &edge : edges) {
            e[edge[0]].push_back(edge[1]);
            e[edge[1]].push_back(edge[0]);
        }

        // mp[i] 表示 i 代表的连通块的答案
        unordered_map<int, int> mp;

        // 以 S 作为 BFS 的起点
        // 以连通块中编号最小的点 mn 为代表
        // 把这个连通块的解记到 mp[mn] 里
        auto bfs = [&](int S) {
            int mn = S;
            queue<int> q;
            int dis[n + 1];
            memset(dis, 0, sizeof(dis));
            q.push(S); dis[S] = 1;
            while (!q.empty()) {
                int sn = q.front(); q.pop();
                mn = min(mn, sn);
                for (int fn : e[sn]) {
                    if (dis[fn]) continue;
                    q.push(fn);
                    dis[fn] = dis[sn] + 1;
                }
            }

            int &ret = mp[mn];
            // 检查分组的合法性
            for (int i = 1; i <= n; i++) if (dis[i]) for (int fn : e[i]) if (abs(dis[i] - dis[fn]) != 1) return;
            // 求最大距离
            for (int i = 1; i <= n; i++) if (dis[i]) ret = max(ret, dis[i]);
        };

        // 枚举以每个点作为 BFS 的起点，并更新所属连通块的答案
        for (int i = 1; i <= n; i++) bfs(i);

        int ans = 0;
        // 枚举所有连通块
        for (auto it = mp.begin(); it != mp.end(); it++) {
            // 只要有一个连通块无解就无解
            if (it->second == 0) return -1;
            // 否则答案就是所有连通块的解的总和
            ans += it->second;
        }
        return ans;
    }
};
```

