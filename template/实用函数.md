`__bulitin_ctz(int)` / `builtin_ctzll(long long)` 

返回二进制表示中末尾 0 的个数

---

`__bulitin_clz(int)` / `__builtin_clzll(long long)`

返回二进制表示中前导 0 的个数

---

`__builtin_popcount()` / `__builtin_popcountll()`

不谈

库函数的实现思路见 [2859. 计算 K 置位下标对应元素的和](https://leetcode.cn/problems/sum-of-values-at-indices-with-k-set-bits/) 的官方题解

---

`__builtin_ffs()`

返回二进制表示中最后一个 1 在第几位（从后往前）

---

`void iota(It first, It last, T val)`

作用是 `first=val` `first + 1 = ++ val` 以此类推

---

`void fill(It first, It last, T val)`

作用是把 `[first, last)` 都填上相同的值

---

`bool next_permutation(iterator start,iterator end)`

---

找一个数有几个二进制位

`32 - __builtin_clz(x)` 或者 `64 - __builtin_clzll(x)`

---

前缀和函数

`std::partial_sum(first, last, d_first)`

计算 [first, last) 的前缀和，放到 d_first 中，例如 `partial_sum(nums.begin(), nums.end(), s.begin() + 1);`

---

排序函数 `ranges::sort()` 

支持 `ranges::sort(nums, [](int x, int y) {return x < y;});`，或者 `ranges::sort(nums);`

`ranges::partial_sort(a.begin(), a.begin() + middle, a.end());` 用于把 [begin, last) 内 middle-begin 个最小的数放到前面，其余数的位置未定义

求最大最小值：`ranges::max(nums)` 

---

统计元素出现次数，可以用 `std::count()` 

---

计算全排列，返回 true 或 false，取决于是否存在下一个排列，默认按照 operator< 来排，或字典序，写法为

```c++
  vector<char> chars = {'a', 'b', 'c'};
  do {
    cout << chars[0] << chars[1] << chars[2] << endl;
  } while (next_permutation(chars.begin(), chars.end()));
```

---

